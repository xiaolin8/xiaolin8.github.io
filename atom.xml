<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiaoLin&#39;s Blog</title>
  <subtitle>回首向来萧瑟处，归去，也无风雨也无晴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaolin.site/"/>
  <updated>2016-07-19T04:09:54.580Z</updated>
  <id>http://xiaolin.site/</id>
  
  <author>
    <name>XiaoLin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用AngularJS</title>
    <link href="http://xiaolin.site/2016/07/19/use_angularjs/"/>
    <id>http://xiaolin.site/2016/07/19/use_angularjs/</id>
    <published>2016-07-19T02:43:24.000Z</published>
    <updated>2016-07-19T04:09:54.580Z</updated>
    
    <content type="html">&lt;h4 id=&quot;AngularJS是什么？&quot;&gt;&lt;a href=&quot;#AngularJS是什么？&quot; class=&quot;headerlink&quot; title=&quot;AngularJS是什么？&quot;&gt;&lt;/a&gt;AngularJS是什么？&lt;/h4&gt;
&lt;p&gt;AngularJS 通过新的属性和表达式扩展了 HTML，是一种构建动态Web应用的结构化框架。&lt;br&gt;它提供了现代Web应用中要用到的一系列高级功能，例如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;解耦应用逻辑、数据模型和视图；&lt;/li&gt;
  &lt;li&gt;Ajax服务；&lt;/li&gt;
  &lt;li&gt;依赖注入；&lt;/li&gt;
  &lt;li&gt;浏览历史（使书签和前进、后退按钮能够像在普通Web应用中一样工作）；&lt;/li&gt;
  &lt;li&gt;便于测试；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;为什么使用AngularJS？&quot;&gt;&lt;a href=&quot;#为什么使用AngularJS？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用AngularJS？&quot;&gt;&lt;/a&gt;为什么使用AngularJS？&lt;/h4&gt;
&lt;p&gt;AngularJS比Jquery等类库的抽象层级更高，通过将逻辑代码直接关联到相关的DOM元素上，使得开发者可以站在更高的一个层次上来简化应用的开发。如同其他的抽象技术一样，这会损失一部分的灵活性。换句话说，并不是所有的应用都适合用AngularJS来做。AngularJS主要考虑的是构建CRUD的单页面应用，而DOM操作很频繁的一些应用则不适用。&lt;/p&gt;
&lt;h4 id=&quot;使用AngularJS&quot;&gt;&lt;a href=&quot;#使用AngularJS&quot; class=&quot;headerlink&quot; title=&quot;使用AngularJS&quot;&gt;&lt;/a&gt;使用AngularJS&lt;/h4&gt;
&lt;p&gt;AngularJS 模块（Module） 定义了 AngularJS 应用。&lt;br&gt;AngularJS 控制器（Controller） 用于控制 AngularJS 应用。&lt;br&gt;ng-app指令定义了应用, ng-controller 定义了控制器。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-app&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;myApp&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-controller&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;myCtrl&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;名: &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-model&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;姓: &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-model&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;姓名: &amp;#123;&amp;#123;firstName + &quot; &quot; + lastName&amp;#125;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;javascript&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//angular.module 模块定义应用myApp，这个方法能够接受两个参数，第一个是模块的名称，第二个是依赖列表，也就是可以被注入到模块中的对象列表。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; app = angular.module(&lt;span class=&quot;string&quot;&gt;&#39;myApp&#39;&lt;/span&gt;, []);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//调用这个方法时如果只传递一个参数，就可以用它来引用模块。例如，可以通过以下代码来引用myApp模块：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这个方法用于获取应用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;angular.module(&lt;span class=&quot;string&quot;&gt;&#39;myApp&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//ng-controller 定义了控制器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;app.controller(&lt;span class=&quot;string&quot;&gt;&#39;myCtrl&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;$scope&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $scope.firstName= &lt;span class=&quot;string&quot;&gt;&quot;John&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $scope.lastName= &lt;span class=&quot;string&quot;&gt;&quot;Doe&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;我们使用ng-model指令将内部数据模型对象（$scope）中的name属性绑定到了文本输入字段上。&lt;br&gt;数据模型对象（model object）是指$scope对象。 $scope对象是一个简单的JavaScript对象，其中的属性可以被视图访问，也可以同控制器进行交互。&lt;/p&gt;
&lt;h5 id=&quot;作用域scope&quot;&gt;&lt;a href=&quot;#作用域scope&quot; class=&quot;headerlink&quot; title=&quot;作用域scope&quot;&gt;&lt;/a&gt;作用域scope&lt;/h5&gt;
&lt;p&gt;$scope的所有属性，都可以自动被视图访问到。&lt;br&gt;$scope对象是定义应用业务逻辑、控制器方法和视图属性的地方。&lt;br&gt;作用域是应用状态的基础。基于动态绑定，我们可以依赖视图在修改数据时立刻更新$scope，也可以依赖$scope在其发生变化时立刻重新渲染视图。&lt;br&gt;AngularJS将$scope设计成和DOM类似的结构，因此$scope可以进行嵌套，也就是说我们可以引用父级$scope中的属性。&lt;/p&gt;
&lt;p&gt;$rootScope是所有$scope对象的最上层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$scope 的生命周期&lt;/strong&gt;&lt;br&gt;每当事件被处理时， $scope就会对定义的表达式求值。此时事件循环会启动，并且Angular应用会监控应用程序内的所有对象，脏值检测循环也会运行。&lt;/p&gt;
&lt;p&gt;$scope对象的生命周期处理有四个不同阶段。&lt;/p&gt;
&lt;p&gt;创建：在创建控制器或指令时， AngularJS会用$injector创建一个新的作用域，并在这个新建的控&lt;br&gt;制器或指令运行时将作用域传递进去。&lt;br&gt;链接：当Angular开始运行时，所有的$scope对象都会附加或者链接到视图中。所有创建$scope对象的函数也会将自身附加到视图中。这些作用域将会注册当Angular应用上下文中发生变化时需要运行的$watch函数，Angular通过这些函数获知何时启动事件循环。&lt;br&gt;更新:当事件循环运行时，它通常执行在顶层$scope对象上（被称作$rootScope），每个子作用域都执行自己的脏值检测。每个监控函数都会检查变化。如果检测到任意变化，
  $scope对象就会触发指定的回调函数。&lt;br&gt;销毁:当一个$scope在视图中不再需要时，这个作用域将会清理和销毁自己。&lt;/p&gt;
&lt;h5 id=&quot;控制器&quot;&gt;&lt;a href=&quot;#控制器&quot; class=&quot;headerlink&quot; title=&quot;控制器&quot;&gt;&lt;/a&gt;控制器&lt;/h5&gt;
&lt;p&gt;AngularJS中的控制器是一个函数。我们用它来给作用域对象设置初始状态，并添加自定义行为。&lt;/p&gt;
&lt;p&gt;AngularJS同其他JavaScript框架最主要的一个区别就是，控制器并不适合用来执行DOM操作、格式化或数据操作，以及除存储数据模型之外的状态维护操作。它只是视图和$scope之间的桥梁。&lt;br&gt;&lt;strong&gt;控制器嵌套（作用域包含作用域）&lt;/strong&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;AngularJS是什么？&quot;&gt;&lt;a href=&quot;#AngularJS是什么？&quot; class=&quot;headerlink&quot; title=&quot;AngularJS是什么？&quot;&gt;&lt;/a&gt;AngularJS是什么？&lt;/h4&gt;
&lt;p&gt;AngularJS 通过新的属性和表达式扩展了 H
    
    </summary>
    
      <category term="前端" scheme="http://xiaolin.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="AngularJS" scheme="http://xiaolin.site/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>使用redis</title>
    <link href="http://xiaolin.site/2016/07/17/redis/"/>
    <id>http://xiaolin.site/2016/07/17/redis/</id>
    <published>2016-07-17T08:10:42.000Z</published>
    <updated>2016-07-18T07:35:46.480Z</updated>
    
    <content type="html">&lt;h4 id=&quot;Redis-介绍&quot;&gt;&lt;a href=&quot;#Redis-介绍&quot; class=&quot;headerlink&quot; title=&quot;Redis 介绍&quot;&gt;&lt;/a&gt;Redis 介绍&lt;/h4&gt;
&lt;p&gt;Redis(REmote DIctionary Server)&lt;/p&gt;
&lt;p&gt;开源（C语言）、Key-Value数据库&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
  &lt;li&gt;它通常被称为&lt;strong&gt;数据结构服务器&lt;/strong&gt;，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Redis-优势&quot;&gt;&lt;a href=&quot;#Redis-优势&quot; class=&quot;headerlink&quot; title=&quot;Redis 优势&quot;&gt;&lt;/a&gt;Redis 优势&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。&lt;/li&gt;
  &lt;li&gt;丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。&lt;/li&gt;
  &lt;li&gt;原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。&lt;/li&gt;
  &lt;li&gt;丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Why-Key-Value&quot;&gt;&lt;a href=&quot;#Why-Key-Value&quot; class=&quot;headerlink&quot; title=&quot;Why Key-Value?&quot;&gt;&lt;/a&gt;Why Key-Value?&lt;/h4&gt;
&lt;p&gt;当网站数据量极大时，需要进行数据库的扩展。有2种方式：一种是仍然采用RDBMS，然后通过对数据库的垂直或水平切割将数据库部署到一个集群上，由于应用的不同，切割的方法也是不同的。另一种方式就是抛弃RDBMS而使用NoSQL。这样可极其方便地增强系统的可扩展性。如果要处理的数据量持续增大，多增加机器就可以了。也可以支持数量更多的并发查询。&lt;/p&gt;
&lt;h4 id=&quot;Redis-连接&quot;&gt;&lt;a href=&quot;#Redis-连接&quot; class=&quot;headerlink&quot; title=&quot;Redis 连接&quot;&gt;&lt;/a&gt;Redis 连接&lt;/h4&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ redis-cli -h host -p port -a password&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;h4 id=&quot;String类型及操作&quot;&gt;&lt;a href=&quot;#String类型及操作&quot; class=&quot;headerlink&quot; title=&quot;String类型及操作&quot;&gt;&lt;/a&gt;String类型及操作&lt;/h4&gt;
&lt;p&gt;string类型是Redis最基本的数据类型，它是二进制安全的。&lt;/p&gt;
&lt;h4 id=&quot;hash类型及操作&quot;&gt;&lt;a href=&quot;#hash类型及操作&quot; class=&quot;headerlink&quot; title=&quot;hash类型及操作&quot;&gt;&lt;/a&gt;hash类型及操作&lt;/h4&gt;
&lt;p&gt;Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Redis-介绍&quot;&gt;&lt;a href=&quot;#Redis-介绍&quot; class=&quot;headerlink&quot; title=&quot;Redis 介绍&quot;&gt;&lt;/a&gt;Redis 介绍&lt;/h4&gt;
&lt;p&gt;Redis(REmote DIctionary Server)&lt;/p&gt;
&lt;p&gt;开源（C语言
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redis" scheme="http://xiaolin.site/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>搜房网一周年的工作反思</title>
    <link href="http://xiaolin.site/2016/06/05/one_year-review/"/>
    <id>http://xiaolin.site/2016/06/05/one_year-review/</id>
    <published>2016-06-05T14:49:36.000Z</published>
    <updated>2016-07-18T07:34:50.786Z</updated>
    
    <content type="html">&lt;p&gt;&amp;emsp;&amp;emsp;今天是入职搜房网满一年的日子。经前辈指点和自我反思，发现自己过去对于工作这件事情的认识确实还很不够深刻，故重新思考和整理经验和教训如下：&lt;/p&gt;
&lt;font size=&quot;6px&quot;&gt;一个职场人最重要的素质和能力（重要性依次递减）&lt;/font&gt;
&lt;h4 id=&quot;基本素质&quot;&gt;&lt;a href=&quot;#基本素质&quot; class=&quot;headerlink&quot; title=&quot;基本素质&quot;&gt;&lt;/a&gt;&lt;font size=&quot;5px&quot;&gt;&lt;strong&gt;基本素质&lt;/strong&gt;&lt;/font&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 责任感&lt;/strong&gt;&lt;br&gt;重要程度：
  &lt;font color=&quot;red&quot;&gt;★★★★★&lt;/font&gt;
&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;有一句谚语说得好，世上无难事，只怕有心人。现实的工作生活是满足80/20法则的，工作中遇到的80%的问题，一个普通水平的人都是可以完成的，甚至可以完成得比一些聪明人更好，而剩下20%的难题往往只要我们多花点心思，实在不行请教请教高手，都是可以完成得很漂亮的。所以能否很好地完成工作，自己的工作质量怎么样，这些很大程度上是和自己的责任心是一种正相关的关系，责任心起了根本性的作用。&lt;br&gt;&amp;emsp;&amp;emsp;同时责任感也是一个人在一个团队中立足的根本，一个没有责任感的人往往对工作缺乏激情，也很难在工作中得到满足感。更多的时候是一种得过且过的态度，是很被动的。一个没有责任感的人永远不知道努力承担起自己责任的意义，给自己找借口，给别人添麻烦。所以，一个缺乏责任感的人是不会受到其他合作伙伴的尊重的。&lt;br&gt;&amp;emsp;&amp;emsp;逃避责任的人，其实也就是在逃避成长，这样的人担不起责，难以成长，自然也不是做领导的料。&lt;br&gt;&amp;emsp;&amp;emsp;可以说以下绝大部分讨论的素质都是责任感的体现和衍生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 靠谱&lt;/strong&gt;&lt;br&gt;重要程度：
  &lt;font color=&quot;red&quot;&gt;★★★★&lt;/font&gt;
&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;百度的用人标准中有一条叫做“简单可依赖”。这个“可依赖”在我看来就是靠谱的官方陈述。一个不靠谱的人表现在总是失信于他人乃至自己的承诺。同时承诺没有兑现时，会有各种各样外在的“理由”。这种人，不管理由听起来多么正当，多么理直气壮，一次两次也就罢了，次数多了就再没有人会信了，在大家的眼里你就是个不靠谱的人，大家不信任你。合作伙伴与你合作总是提心吊胆，领导也不信任你的能力，会认为你不叫人放心，不堪大用。&lt;br&gt;&amp;emsp;&amp;emsp;靠谱说起来很简单，但是做起来其实也并不是那么容易的，需要我们对自己严格要求，不要随便对他人承诺，但是一旦承诺了便一定要信守自己的诺言。我们都喜欢与靠谱的人合作，所以如果我们想要很好地与他人合作，就得首先保证自己是一个靠谱的人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 主动性&lt;/strong&gt;&lt;br&gt;重要程度：
  &lt;font color=&quot;red&quot;&gt;★★★★&lt;/font&gt;
&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;职场中的我们都已是成年人。早已不是高中老师管着我们这管着我们那的未成年毛孩子了。在职场上大家都在努力干活，忙于处理自己的事物。所以有时候，如果你在这个团队里是个新人的话，你很有可能发现领导没有安排给你事情做。那么这个时候要发挥主动性，主动沟通有什么是需要自己做的。自己的工作不要等，永远不要别人来督促你，一定要自己主动去推进这件事，把他按时保质保量地完成。被动的人总是成长得很慢的。&lt;/p&gt;
&lt;h4 id=&quot;综合素质&quot;&gt;&lt;a href=&quot;#综合素质&quot; class=&quot;headerlink&quot; title=&quot;综合素质&quot;&gt;&lt;/a&gt;综合素质&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 逻辑思维能力&lt;/strong&gt;&lt;br&gt;逻辑思维能力是指正确、合理思考的能力。即对事物进行观察、比较、分析、综合、抽象、概括、判断、推理的能力。&lt;br&gt;一个逻辑思维能力好的人在我看来在工作中重要的表现就是头脑清醒，做事有条理。&lt;br&gt;思维全面，考虑周到。&lt;br&gt;&lt;strong&gt;2. 语言表达能力&lt;/strong&gt;&lt;br&gt;有效沟通（沟通方式、沟通）情商、主动沟通、注意表达方式方法。&lt;br&gt;&lt;strong&gt;3. 一些好的工作习惯&lt;/strong&gt;&lt;br&gt;自我反思、总结、计划&lt;/p&gt;
&lt;h4 id=&quot;专业技能&quot;&gt;
  &lt;a href=&quot;#专业技能&quot; class=&quot;headerlink&quot; title=&quot;专业技能&quot;&gt;&lt;/a&gt;专业技能&lt;/h4&gt;
  &lt;p&gt;&lt;strong&gt;1．业务是目的而技术只是手段&lt;/strong&gt;&lt;br&gt;重技术而轻业务是绝对不可取的；&lt;br&gt;&lt;strong&gt;2.学技术要思想而非细节&lt;/strong&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;今天是入职搜房网满一年的日子。经前辈指点和自我反思，发现自己过去对于工作这件事情的认识确实还很不够深刻，故重新思考和整理经验和教训如下：&lt;/p&gt;
&lt;font size=&quot;6px&quot;&gt;一个职场人最重要的素质和能力（重要性依次递减）&lt;/font&gt;
&lt;h4 
    
    </summary>
    
      <category term="随笔" scheme="http://xiaolin.site/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="思考" scheme="http://xiaolin.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Web缓存概述（一）</title>
    <link href="http://xiaolin.site/2016/05/31/cache/"/>
    <id>http://xiaolin.site/2016/05/31/cache/</id>
    <published>2016-05-31T14:14:20.000Z</published>
    <updated>2016-07-18T07:34:06.661Z</updated>
    
    <content type="html">&lt;h4 id=&quot;什么是缓存？&quot;&gt;&lt;a href=&quot;#什么是缓存？&quot; class=&quot;headerlink&quot; title=&quot;什么是缓存？&quot;&gt;&lt;/a&gt;什么是缓存？&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。&lt;/p&gt;
&lt;h4 id=&quot;Web缓存的作用&quot;&gt;
  &lt;a href=&quot;#Web缓存的作用&quot; class=&quot;headerlink&quot; title=&quot;Web缓存的作用&quot;&gt;&lt;/a&gt;Web缓存的作用&lt;/h4&gt;
  &lt;p&gt;&lt;strong&gt;减少网络带宽消耗&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;无论对于网站运营者还是用户，带宽都代表着金钱，过多的带宽消耗，只会便宜了网络运营商。当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。&lt;br&gt;&lt;strong&gt;降低服务器压力&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。&lt;br&gt;&lt;strong&gt;减少网络延迟，加快页面打开速度&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;带宽对于个人网站运营者来说是十分重要，而对于大型的互联网公司来说，可能有时因为钱多而真的不在乎。那Web缓存还有作用吗？答案是肯定的，对于最终用户，缓存的使用能够明显加快页面打开速度，达到更好的体验。&lt;/p&gt;
  &lt;h4 id=&quot;Web缓存的类型&quot;&gt;
    &lt;a href=&quot;#Web缓存的类型&quot; class=&quot;headerlink&quot; title=&quot;Web缓存的类型&quot;&gt;&lt;/a&gt;Web缓存的类型&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;浏览器端缓存&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;浏览器会在你的硬盘上专门开辟一个空间专门为你存储资源副本。浏览器缓存的工作规则很简单：检查以确保副本是最新的，通常只要一次会话（就是当前浏览器调用的这次）。&lt;br&gt;&amp;emsp;&amp;emsp;浏览器缓存在用户触发“后退”操作或点击一个之前看过的链接的时候很管用。同样，如果你在网站上访问同一张图片，该图片可以从浏览器缓存中调出并几乎立即显现出来。&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;服务器端缓存&lt;/strong&gt;&lt;/p&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;代理服务器缓存&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有
      &lt;a href=&quot;http://www.squid-cache.org/&quot; title=&quot;squid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Squid&lt;/a&gt;等，这里不再详述。&lt;/p&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;CDN缓存&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的可扩展性。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，本文讨论浏览器和服务器之间的缓存机制，在这种架构下同样适用。&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;应用层缓存&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;缓存数据库的查询结果,减少数据库的压力。这个在大型网站是必须做的；&lt;/li&gt;
      &lt;li&gt;缓存磁盘文件的数据。比如常用的数据可以放到内存，不用每次都去读取磁盘，特别是密集计算的程序，比如中文分词的词库；&lt;/li&gt;
      &lt;li&gt;缓存某个耗时的计算操作，比如数据统计；&lt;/li&gt;
      &lt;li&gt;缓存频繁写入的数据（需要写到数据库），比如页面点击量操作可以暂时利用缓存，然后定期的写到数据库；&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;应用层缓存的架构也可以分几种：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;嵌入式，也就是缓存和应用在同一个机器。比如单机的文件缓存，java中用hashMap来缓存数据等等。这种缓存速度快，没有网络消耗。&lt;/li&gt;
      &lt;li&gt;分布式缓存，把缓存的数据独立到不同的机器，通过网络来请求数据，比如常用的memcache就是这一类。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;分布式缓存一般可以分为几种:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;按应用切分数据到不同的缓存服务器，这是一种比较简单和实用的方式。&lt;/li&gt;
      &lt;li&gt;按照某种规则（hash,路由等等）把数据存储到不同的缓存服务器。&lt;/li&gt;
      &lt;li&gt;代理模式，应用在获取数据的时候都由代理透明的处理，缓存机制有代理服务器来处理。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header&lt;/p&gt;
    &lt;figure class=&quot;highlight java&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;java.util.Date date = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; java.util.Date();    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;response.setDateHeader(&lt;span class=&quot;string&quot;&gt;&quot;Expires&quot;&lt;/span&gt;,date.getTime()+&lt;span class=&quot;number&quot;&gt;20000&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//Expires:过时期限值 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;response.setHeader(&lt;span class=&quot;string&quot;&gt;&quot;Cache-Control&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;public&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;response.setHeader(&lt;span class=&quot;string&quot;&gt;&quot;Pragma&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Pragma&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;response.setHeader( &lt;span class=&quot;string&quot;&gt;&quot;Pragma&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;no-cache&quot;&lt;/span&gt; );   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;response.setDateHeader(&lt;span class=&quot;string&quot;&gt;&quot;Expires&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;response.addHeader( &lt;span class=&quot;string&quot;&gt;&quot;Cache-Control&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;no-cache&quot;&lt;/span&gt; );&lt;span class=&quot;comment&quot;&gt;//浏览器和缓存服务器都不应该缓存页面信息&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;当然还可以通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header，比如tomcat提供的&lt;a href=&quot;http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Expires_Filter&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ExpiresFilter&lt;/a&gt;。&lt;br&gt;&lt;strong&gt;数据库端缓存&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;这个可以用以“空间换时间”来说。比如建一个表来存储耗时的数据统计结果，在每次更新数据的时候同时更新基本数据表和统计结果的表。&lt;/p&gt;
    &lt;h4 id=&quot;缓存规则和运用&quot;&gt;
      &lt;a href=&quot;#缓存规则和运用&quot; class=&quot;headerlink&quot; title=&quot;缓存规则和运用&quot;&gt;&lt;/a&gt;缓存规则和运用&lt;/h4&gt;
      &lt;p&gt;&lt;strong&gt;浏览器端的缓存规则&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;对于浏览器端来讲，这些规则是在HTTP协议头和HTML页面的Meta标签中定义的。他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本。&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;strong&gt;新鲜度（过期机制）&lt;/strong&gt;&lt;br&gt;也就是缓存副本的有效期。一个缓存副本如果满足以下条件之一，浏览器就会认为它是有效的，足够新的：&lt;/li&gt;
      &lt;/ul&gt;
      &lt;ol&gt;
        &lt;li&gt;含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内；&lt;/li&gt;
        &lt;li&gt;浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度；&lt;/li&gt;
      &lt;/ol&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;strong&gt;校验值（验证机制）&lt;/strong&gt;：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;&lt;strong&gt;浏览器缓存的控制&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;使用HTML Meta 标签&lt;/p&gt;
      &lt;figure class=&quot;highlight html&quot;&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
            &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;META&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;HTTP-EQUIV&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Pragma&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;CONTENT&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;no-cache&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;
      &lt;/figure&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。&lt;br&gt;&amp;emsp;&amp;emsp;可以通过这个页面测试你的浏览器是否支持：&lt;a href=&quot;http://www.procata.com/cachetest/tests/pragma/index.php&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pragma No-Cache Test&lt;/a&gt; 。&lt;br&gt;&lt;strong&gt;使用缓存有关的HTTP消息报头&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;一个URI的完整HTTP协议交互过程是由HTTP请求和HTTP响应组成的。有关HTTP详细内容可参考《
        &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hypertext Transfer Protocol — HTTP/1.1&lt;/a&gt;》、《&lt;a href=&quot;http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTP协议详解&lt;/a&gt;》等。&lt;br&gt;在HTTP请求和响应的消息报头中，常见的与缓存有关的消息报头有：&lt;br&gt;&amp;emsp;&amp;emsp;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/http-header1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;Cache-Control与Expires&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;
        &lt;font color=&quot;red&quot;&gt;如果设了max-age就会覆盖expires&lt;/font&gt;&lt;br&gt;&amp;emsp;&amp;emsp;Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control是http 1.1中为了弥补 Expires缺陷新加入的，所以可选择设置得更细致，如果同时设置的话，其优先级高于Expires。&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;Last-Modified/ETag与Cache-Control/Expires&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;配置Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器；&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;strong&gt;Cache-control: public&lt;/strong&gt;表示缓存的版本可以被代理服务器或者其他中间服务器识别；&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Cache-control: private&lt;/strong&gt;意味着这个文件对不同的用户是不同的。只有用户自己的浏览器能够进行缓存，公共的代理服务器不允许缓存；&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;Cache-Control/Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。&lt;br&gt;&amp;emsp;&amp;emsp;一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间,
        当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;使用Expires HTTP头信息控制不过期&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;Expires HTTP头是控制缓存的基本手段，Expires的中文意思是“有效期”，显然，就是告诉浏览器缓存的有效期。如果过期，缓存会检查源服务器以确定文件是否改变了。Expires头几乎每个缓存都支持。&lt;br&gt;&amp;emsp;&amp;emsp;大部分的服务器允许你以多种方式设置Expires响应头。通常，他们允许设置一个绝对过期时间，然后对比最后一次访问的时候或者最后一次文档修改的时候决定客户端内容的获取方式。&lt;br&gt;&amp;emsp;&amp;emsp;对于静态图片（如导航或按钮的图片）而言，Expires头信息是相当有用的，因为图片不怎么修改，您可以给图片设置一个相当长的过期时间，这回让你的用户感觉网站变快了。Expires对于控制有改变规律的网页也很有用，例如：你有一个新闻聚合页面，每天早上6点钟准时更新，您可以设置缓存的过期时间也是这个点，于是缓存就可以很聪明地知道什么时候该去重载新的内容，什么时候睡大觉。&lt;br&gt;&amp;emsp;&amp;emsp;Expires头唯一的有效值是HTTP时间，其他值都会被认为是“前男友前女友”之类，不会去缓存的。注意：时间是格林威治时间（GMT），而不是本地时间。如下所示：&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;p&gt;Expires: Fri, 30 Oct 1998 14:19:41 GMT&lt;/p&gt;
      &lt;/blockquote&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;尽管Expires头很有用，但它有一定的局限性。首先，因为牵扯到时间，Web服务器端的时钟必须和缓存的同步，否则很可能实现不了预期的结果——缓存把前女友当初现女友，把现女友当作过去式——那就悲剧了。&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;Last-Modified与ETag&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度；&lt;/li&gt;
        &lt;li&gt;如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存；&lt;/li&gt;
        &lt;li&gt;有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形；&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。Etag的服务器生成规则和强弱Etag的相关内容可以参考，《&lt;a href=&quot;http://www.hudong.com/wiki/Etag&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;互动百科-Etag&lt;/a&gt;》和《&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTP Header definition&lt;/a&gt;》，这里不再深入。&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;用户操作行为与缓存&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;用户在使用浏览器的时候，会有各种操作，比如输入地址后回车，按F5刷新等，这些行为会对缓存有什么影响呢？&lt;br&gt;&amp;emsp;&amp;emsp;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/user-action2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;通过上表我们可以看到，当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；而当用户使用Ctrl+F5进行强制刷新的时候，只是所有的缓存机制都将失效，重新从服务器拉去资源。&lt;br&gt;&amp;emsp;&amp;emsp;相关有趣的分享：&lt;br&gt;&amp;emsp;&amp;emsp;《
        &lt;a href=&quot;http://www.laruence.com/2010/03/05/1332.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;浏览器缓存机制&lt;/a&gt;》：不同浏览器对用户操作行为处理比较&lt;br&gt;&amp;emsp;&amp;emsp;《&lt;a href=&quot;http://spyrise.org/blog/http-304-not-modified-header-setting-optimize/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTP 304客户端缓存优化的神奇作用和用法&lt;/a&gt;》：强行在代码层面比对文件的Last-Modified时间，保证用户使用Ctrl+F5进行刷新的时候也能正常返回304&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;数据库端&lt;/strong&gt;&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;利用普通表或内存表来缓存一些统计数据。&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;&lt;strong&gt;应用层端&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;比较常见的应用层分布式缓存容器，Memcache、共享文件服务器、MemcacheDb、Tokyo Tyrant。java实现的缓存也比较多，比如oscache,jcache ,ehcached等等。&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;前端比较常用的就是squid,Varnish Cache,ncache等等。&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;哪些请求不能被缓存？&lt;/strong&gt;&lt;/p&gt;
      &lt;p&gt;无法被浏览器缓存的请求：&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求；&lt;/li&gt;
        &lt;li&gt;需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的；&lt;/li&gt;
        &lt;li&gt;经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTPS的七个误解&lt;/a&gt;》）；&lt;/li&gt;
        &lt;li&gt;POST请求无法被缓存；&lt;/li&gt;
        &lt;li&gt;HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存；&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4 id=&quot;构建可缓存的网络站点&quot;&gt;&lt;a href=&quot;#构建可缓存的网络站点&quot; class=&quot;headerlink&quot; title=&quot;构建可缓存的网络站点&quot;&gt;&lt;/a&gt;构建可缓存的网络站点&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;同一个资源保证URL的稳定性；&lt;/li&gt;
        &lt;li&gt;万不得已不要变动文件：否则你要设置一个新的Last-Modified值。另外，当你更新站点的时候，只要上传改动的那些文件，而不要把整个站点都覆盖过去;&lt;/li&gt;
        &lt;li&gt;不同地方的图片和其他元素使用同一库，推荐使用公共CDN库，比如&lt;a href=&quot;http://www.bootcdn.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BootCDN&lt;/a&gt;等，有利于最大限度使用缓存；&lt;/li&gt;
        &lt;li&gt;对于不经常改变的图片/页面，将Cache-Control: max-age头信息的值设大一点，
          &lt;font color=&quot;red&quot;&gt;而对于html页面这种入口文件，不建议设置缓存&lt;/font&gt;。这样既能保证在静态资源不变了情况下，可以不重发请求或直接通过304避免重复下载，又能保证在资源有更新的，只要通过给资源增加时间戳或者更换路径，就能让用户访问最新的资源；&lt;/li&gt;
        &lt;li&gt;如果资源改变了（尤其下载文件），改变其名字。由于一般这种资源会有很长的过期时间，而服务器上一直是正确的版本；因此，链接这个下载资源的页面需要要比较短的过期时间。否则，会出现服务器的资源是新的，但页面被缓存了，其中的链接地址还是旧的，就会出现新旧版本冲突的可能；&lt;/li&gt;
        &lt;li&gt;Cookie能不用就不用：Cookie难以被缓存，且大多情境下是没有必要的。过多的使用Cookie会大大增加HTTP请求的负担，每次GET或POST请求，都会把Cookie都带上，增加网络传输流量，导致增长交互时间；如果你非得使用Cookie，建议只用在动态页面上;&lt;/li&gt;
        &lt;li&gt;减少HTTPS、SSL的使用：因为共享缓存不能存储认证页面，只在必要的时候使用，并且在SSL页面上减少图片的使用；&lt;/li&gt;
        &lt;li&gt;多用Get方式请求动态资源。虽然POST的请求方式比Get更安全，可以避免类似密码这种敏感信息在网络传输，被代理或其他人截获，但是Get请求方式更快，效率更高，而且能被缓存，建议对于那些不涉及敏感信息提交的请求尽量使用Get方式请求；&lt;/li&gt;
        &lt;li&gt;使用REDbot检查你的网站：可以帮助你应用本文所介绍的一些概念。
          &lt;blockquote&gt;
            &lt;p&gt;REDbot：REDbot = RED + robot，是个机器人，检查HTTP资源，看他们如何会表现，指出常见的问题，并提出改进建议。虽然它属于HTTP一致性测试仪，但却可以找到不少HTTP相关问题。&lt;/p&gt;
          &lt;/blockquote&gt;
        &lt;/li&gt;
      &lt;/ul&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是缓存？&quot;&gt;&lt;a href=&quot;#什么是缓存？&quot; class=&quot;headerlink&quot; title=&quot;什么是缓存？&quot;&gt;&lt;/a&gt;什么是缓存？&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="缓存" scheme="http://xiaolin.site/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>java基础拾遗——JVM优化经验总结</title>
    <link href="http://xiaolin.site/2016/05/30/jvm-optimal/"/>
    <id>http://xiaolin.site/2016/05/30/jvm-optimal/</id>
    <published>2016-05-30T13:47:38.000Z</published>
    <updated>2016-07-18T07:33:51.992Z</updated>
    
    <content type="html">&lt;p&gt;&amp;emsp;&amp;emsp;之前的文章&lt;a href=&quot;http://xiaolin.site/2016/05/30/jvm/&quot;&gt;《java基础拾遗——JVM垃圾回收原理》&lt;/a&gt;中已经介绍过年轻代、年老代、永生代，本文主要讲讲如何运用这些区域，为系统性能提供更好的帮助。本文不再赘述这些概念，直接进入主题。&lt;/p&gt;
&lt;h4 id=&quot;如何将新对象预留在年轻代&quot;&gt;&lt;a href=&quot;#如何将新对象预留在年轻代&quot; class=&quot;headerlink&quot; title=&quot;如何将新对象预留在年轻代&quot;&gt;&lt;/a&gt;如何将新对象预留在年轻代&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;众所周知，由于 Full GC 的成本远远高于 Minor GC，因此某些情况下需要尽可能将对象分配在年轻代，这在很多情况下是一个明智的选择。虽然在大部分情况下，JVM 会尝试在 Eden 区分配对象，但是由于空间紧张等问题，很可能不得不将部分年轻对象提前向年老代压缩。因此，在 JVM 参数调优时可以为应用程序分配一个合理的年轻代空间，以最大限度避免新对象直接进入年老代的情况发生。如下尝试分配 4MB 内存空间，观察一下它的内存使用情况。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PutInEden&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] b1,b2,b3,b4;&lt;span class=&quot;comment&quot;&gt;//定义变量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b1=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//分配 1MB 堆空间，考察堆空间的使用情况&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b2=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b3=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b4=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用 JVM 参数-XX:+PrintGCDetails -Xmx20M -Xms20M 运行以上代码，输出如下所示。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;[GC [DefNew: 5504K-&amp;gt;640K(6144K), 0.0114236 secs] 5504K-&amp;gt;5352K(19840K),&lt;br&gt;0.0114595 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]&lt;br&gt;[GC [DefNew: 6144K-&amp;gt;640K(6144K), 0.0131261 secs] 10856K-&amp;gt;10782K(19840K),&lt;br&gt;0.0131612 secs] [Times:
    user=0.02 sys=0.00, real=0.02 secs]&lt;br&gt;[GC [DefNew: 6144K-&amp;gt;6144K(6144K), 0.0000170 secs][Tenured: 10142K-&amp;gt;13695K(13696K),&lt;br&gt;0.1069249 secs] 16286K-&amp;gt;15966K(19840K), [Perm : 376K-&amp;gt;376K(12288K)],&lt;br&gt;0.1070058 secs] [Times: user=0.03 sys=0.00,
    real=0.11 secs]&lt;br&gt;[Full GC [Tenured: 13695K-&amp;gt;13695K(13696K), 0.0302067 secs] 19839K-&amp;gt;19595K(19840K),&lt;br&gt;[Perm : 376K-&amp;gt;376K(12288K)], 0.0302635 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]&lt;br&gt;[Full GC [Tenured: 13695K-&amp;gt;13695K(13696K),
    0.0311986 secs] 19839K-&amp;gt;19839K(19840K),&lt;br&gt;[Perm : 376K-&amp;gt;376K(12288K)], 0.0312515 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]&lt;br&gt;[Full GC [Tenured: 13695K-&amp;gt;13695K(13696K), 0.0358821 secs] 19839K-&amp;gt;19825K(19840K),&lt;br&gt;[Perm : 376K-&amp;gt;371K(12288K)],
    0.0359315 secs] [Times: user=0.05 sys=0.00, real=0.05 secs]&lt;br&gt;[Full GC [Tenured: 13695K-&amp;gt;13695K(13696K), 0.0283080 secs] 19839K-&amp;gt;19839K(19840K),&lt;br&gt;[Perm : 371K-&amp;gt;371K(12288K)], 0.0283723 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]&lt;br&gt;[Full
    GC [Tenured: 13695K-&amp;gt;13695K(13696K), 0.0284469 secs] 19839K-&amp;gt;19839K(19840K),&lt;br&gt;[Perm : 371K-&amp;gt;371K(12288K)], 0.0284990 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]&lt;br&gt;[Full GC [Tenured: 13695K-&amp;gt;13695K(13696K), 0.0283005 secs] 19839K-&amp;gt;19839K(19840K),&lt;br&gt;[Perm
    : 371K-&amp;gt;371K(12288K)], 0.0283475 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]&lt;br&gt;[Full GC [Tenured: 13695K-&amp;gt;13695K(13696K), 0.0287757 secs] 19839K-&amp;gt;19839K(19840K),&lt;br&gt;[Perm : 371K-&amp;gt;371K(12288K)], 0.0288294 secs] [Times: user=0.03
    sys=0.00, real=0.03 secs]&lt;br&gt;[Full GC [Tenured: 13695K-&amp;gt;13695K(13696K), 0.0288219 secs] 19839K-&amp;gt;19839K(19840K),&lt;br&gt;[Perm : 371K-&amp;gt;371K(12288K)], 0.0288709 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]&lt;br&gt;[Full GC [Tenured: 13695K-&amp;gt;13695K(13696K),
    0.0293071 secs] 19839K-&amp;gt;19839K(19840K),&lt;br&gt;[Perm : 371K-&amp;gt;371K(12288K)], 0.0293607 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]&lt;br&gt;[Full GC [Tenured: 13695K-&amp;gt;13695K(13696K), 0.0356141 secs] 19839K-&amp;gt;19838K(19840K),&lt;br&gt;[Perm : 371K-&amp;gt;371K(12288K)],
    0.0356654 secs] [Times: user=0.01 sys=0.00, real=0.03 secs]&lt;br&gt;Heap&lt;br&gt;def new generation total 6144K, used 6143K [0x35c10000, 0x362b0000, 0x362b0000)&lt;br&gt;eden space 5504K, 100% used [0x35c10000, 0x36170000, 0x36170000)&lt;br&gt;from space 640K, 99% used
    [0x36170000, 0x3620fc80, 0x36210000)&lt;br&gt;to space 640K, 0% used [0x36210000, 0x36210000, 0x362b0000)&lt;br&gt;tenured generation total 13696K, used 13695K [0x362b0000, 0x37010000, 0x37010000)&lt;br&gt;the space 13696K, 99% used [0x362b0000, 0x3700fff8, 0x37010000,
    0x37010000)&lt;br&gt;compacting perm gen total 12288K, used 371K [0x37010000, 0x37c10000, 0x3b010000)&lt;br&gt;the space 12288K, 3% used [0x37010000, 0x3706cd20, 0x3706ce00, 0x37c10000)&lt;br&gt;ro space 10240K, 51% used [0x3b010000, 0x3b543000, 0x3b543000, 0x3ba10000)&lt;br&gt;rw
    space 12288K, 55% used [0x3ba10000, 0x3c0ae4f8, 0x3c0ae600, 0x3c610000)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;日志输出显示年轻代 Eden 的大小有 5MB 左右。通过设置一个较大的年轻代预留新对象，设置合理的 Survivor 区并且提供 Survivor 区的使用率，可以将年轻对象保存在年轻代。一般来说，Survivor 区的空间不够，或者占用量达到 50%时，就会使对象进入年老代 (不管它的年龄有多大)。&lt;/p&gt;
&lt;h4 id=&quot;如何让大对象进入年老代&quot;&gt;&lt;a href=&quot;#如何让大对象进入年老代&quot; class=&quot;headerlink&quot; title=&quot;如何让大对象进入年老代&quot;&gt;&lt;/a&gt;如何让大对象进入年老代&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我们在大部分情况下都会选择将对象分配在年轻代。但是，对于占用内存较多的大对象而言，它的选择可能就不是这样的。因为大对象出现在年轻代很可能扰乱年轻代 GC，并破坏年轻代原有的对象结构。因为尝试在年轻代分配大对象，很可能导致空间不足，为了有足够的空间容纳大对象，JVM 不得不将年轻代中的年轻对象挪到年老代。因为大对象占用空间多，所以可能需要移动大量小的年轻对象进入年老代，这对 GC 相当不利。基于以上原因，可以将大对象直接分配到年老代，保持年轻代对象结构的完整性，这样可以提高
  GC 的效率。如果一个大对象同时又是一个短命的对象，假设这种情况出现很频繁，那对于 GC 来说会是一场灾难。原本应该用于存放永久对象的年老代，被短命的对象塞满，这也意味着对堆空间进行了洗牌，扰乱了分代内存回收的基本思路。因此，在软件开发过程中，应该尽可能避免使用短命的大对象。可以使用参数-XX:PetenureSizeThreshold 设置大对象直接进入年老代的阈值。当对象的大小超过这个值时，将直接在年老代分配。参数-XX:PetenureSizeThreshold 只对串行收集器和年轻代并行收集器有效，并行回收收集器不识别这个参数。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;创建一个大对象&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BigObj2Old&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] b;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//分配一个 1MB 的对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用 JVM 参数-XX:+PrintGCDetails –Xmx20M –Xms20MB 运行，可以得到如下日志输出：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Heap&lt;br&gt;def new generation total 6144K, used 1378K [0x35c10000, 0x362b0000, 0x362b0000)&lt;br&gt;eden space 5504K, 25% used [0x35c10000, 0x35d689e8, 0x36170000)&lt;br&gt;from space 640K, 0% used [0x36170000, 0x36170000, 0x36210000)&lt;br&gt;to space 640K, 0% used [0x36210000,
    0x36210000, 0x362b0000)&lt;br&gt;tenured generation total 13696K, used 0K [0x362b0000, 0x37010000, 0x37010000)&lt;br&gt;the space 13696K, 0% used [0x362b0000, 0x362b0000, 0x362b0200, 0x37010000)&lt;br&gt;compacting perm gen total 12288K, used 374K [0x37010000, 0x37c10000,
    0x3b010000)&lt;br&gt;the space 12288K, 3% used [0x37010000, 0x3706dac8, 0x3706dc00, 0x37c10000)&lt;br&gt;ro space 10240K, 51% used [0x3b010000, 0x3b543000, 0x3b543000, 0x3ba10000)&lt;br&gt;rw space 12288K, 55% used [0x3ba10000, 0x3c0ae4f8, 0x3c0ae600, 0x3c610000)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;可以看到该对象被分配在了年轻代，占用了 25%的空间。如果需要将 1MB 以上的对象直接在年老代分配，设置-XX:PetenureSizeThreshold=1000000，程序运行后输出如下所示：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Heap&lt;br&gt;def new generation total 6144K, used 354K [0x35c10000, 0x362b0000, 0x362b0000)&lt;br&gt;eden space 5504K, 6% used [0x35c10000, 0x35c689d8, 0x36170000)&lt;br&gt;from space 640K, 0% used [0x36170000, 0x36170000, 0x36210000)&lt;br&gt;to space 640K, 0% used [0x36210000,
    0x36210000, 0x362b0000)&lt;br&gt;tenured generation total 13696K, used 1024K [0x362b0000, 0x37010000, 0x37010000)&lt;br&gt;the space 13696K, 7% used [0x362b0000, 0x363b0010, 0x363b0200, 0x37010000)&lt;br&gt;compacting perm gen total 12288K, used 374K [0x37010000, 0x37c10000,
    0x3b010000)&lt;br&gt;the space 12288K, 3% used [0x37010000, 0x3706dac8, 0x3706dc00, 0x37c10000)&lt;br&gt;ro space 10240K, 51% used [0x3b010000, 0x3b543000, 0x3b543000, 0x3ba10000)&lt;br&gt;rw space 12288K, 55% used [0x3ba10000, 0x3c0ae4f8, 0x3c0ae600, 0x3c610000)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;可以看到当满 1MB 时进入到了年老代。&lt;/p&gt;
&lt;h4 id=&quot;如何设置对象进入年老代的年龄&quot;&gt;&lt;a href=&quot;#如何设置对象进入年老代的年龄&quot; class=&quot;headerlink&quot; title=&quot;如何设置对象进入年老代的年龄&quot;&gt;&lt;/a&gt;如何设置对象进入年老代的年龄&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;堆中的每一个对象都有自己的年龄。一般情况下，年轻对象存放在年轻代，年老对象存放在年老代。为了做到这点，虚拟机为每个对象都维护一个年龄。如果对象在 Eden 区，经过一次 GC 后依然存活，则被移动到 Survivor 区中，对象年龄加 1。以后，如果对象每经过一次 GC 依然存活，则年龄再加 1。当对象年龄达到阈值时，就移入年老代，成为老年对象。这个阈值的最大值可以通过参数-XX:MaxTenuringThreshold 来设置，默认值是 15。虽然-XX:MaxTenuringThreshold
  的值可能是 15 或者更大，但这不意味着新对象非要达到这个年龄才能进入年老代。事实上，对象实际进入年老代的年龄是虚拟机在运行时根据内存使用情况动态计算的，这个参数指定的是阈值年龄的最大值。即，实际晋升年老代年龄等于动态计算所得的年龄与-XX:MaxTenuringThreshold 中较小的那个。如下代码为 3 个对象申请了若干内存。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;申请内存&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MaxTenuringThreshold&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String args[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] b1,b2,b3;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;512&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b3 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;参数设置为：-XX:+PrintGCDetails -Xmx20M -Xms20M -Xmn10M -XX:SurvivorRatio=2&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;[GC [DefNew: 2986K-&amp;gt;690K(7680K), 0.0246816 secs] 2986K-&amp;gt;2738K(17920K),&lt;br&gt;0.0247226 secs] [Times: user=0.00 sys=0.02, real=0.03 secs]&lt;br&gt;[GC [DefNew: 4786K-&amp;gt;690K(7680K), 0.0016073 secs] 6834K-&amp;gt;2738K(17920K),&lt;br&gt;0.0016436 secs] [Times: user=0.00
    sys=0.00, real=0.00 secs]&lt;br&gt;Heap&lt;br&gt;def new generation total 7680K, used 4888K [0x35c10000, 0x36610000, 0x36610000)&lt;br&gt;eden space 5120K, 82% used [0x35c10000, 0x36029a18, 0x36110000)&lt;br&gt;from space 2560K, 26% used [0x36110000, 0x361bc950, 0x36390000)&lt;br&gt;to
    space 2560K, 0% used [0x36390000, 0x36390000, 0x36610000)&lt;br&gt;tenured generation total 10240K, used 2048K [0x36610000, 0x37010000, 0x37010000)&lt;br&gt;the space 10240K, 20% used [0x36610000, 0x36810010, 0x36810200, 0x37010000)&lt;br&gt;compacting perm gen total
    12288K, used 374K [0x37010000, 0x37c10000, 0x3b010000)&lt;br&gt;the space 12288K, 3% used [0x37010000, 0x3706db50, 0x3706dc00, 0x37c10000)&lt;br&gt;ro space 10240K, 51% used [0x3b010000, 0x3b543000, 0x3b543000, 0x3ba10000)&lt;br&gt;rw space 12288K, 55% used [0x3ba10000,
    0x3c0ae4f8, 0x3c0ae600, 0x3c610000)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;更改参数为-XX:+PrintGCDetails -Xmx20M -Xms20M -Xmn10M -XX:SurvivorRatio=2 -XX:MaxTenuringThreshold=1。第一次运行时 b1 对象在程序结束后依然保存在年轻代。第二次运行前，我们减小了对象晋升年老代的年龄，设置为 1。即，所有经过一次 GC 的对象都可以直接进入年老代。程序运行后，可以发现 b1 对象已经被分配到年老代。如果希望对象尽可能长时间地停留在年轻代，可以设置一个较大的阈值。&lt;/p&gt;
&lt;h4 id=&quot;稳定的-Java-堆-VS-动荡的-Java-堆&quot;&gt;
  &lt;a href=&quot;#稳定的-Java-堆-VS-动荡的-Java-堆&quot; class=&quot;headerlink&quot; title=&quot;稳定的 Java 堆 VS 动荡的 Java 堆&quot;&gt;&lt;/a&gt;稳定的 Java 堆 VS 动荡的 Java 堆&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;一般来说，稳定的堆大小对垃圾回收是有利的。获得一个稳定的堆大小的方法是使-Xms 和-Xmx 的大小一致，即最大堆和最小堆 (初始堆) 一样。如果这样设置，系统在运行时堆大小理论上是恒定的，稳定的堆空间可以减少 GC 的次数。因此，很多服务端应用都会将最大堆和最小堆设置为相同的数值。但是，一个不稳定的堆并非毫无用处。稳定的堆大小虽然可以减少 GC 次数，但同时也增加了每次 GC 的时间。让堆大小在一个区间中震荡，在系统不需要使用大内存时，压缩堆空间，使 GC 应对一个较小的堆，可以加快单次
    GC 的速度。基于这样的考虑，JVM 还提供了两个参数用于压缩和扩展堆空间。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;-XX:MinHeapFreeRatio 参数用来设置堆空间最小空闲比例，默认值是 40。当堆空间的空闲内存小于这个数值时，JVM 便会扩展堆空间。&lt;/li&gt;
    &lt;li&gt;-XX:MaxHeapFreeRatio 参数用来设置堆空间最大空闲比例，默认值是 70。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆。&lt;/li&gt;
    &lt;li&gt;当-Xmx 和-Xms 相等时，-XX:MinHeapFreeRatio 和-XX:MaxHeapFreeRatio 两个参数无效。&lt;/li&gt;
  &lt;/ul&gt;
  &lt;h4 id=&quot;增大吞吐量提升系统性能&quot;&gt;&lt;a href=&quot;#增大吞吐量提升系统性能&quot; class=&quot;headerlink&quot; title=&quot;增大吞吐量提升系统性能&quot;&gt;&lt;/a&gt;增大吞吐量提升系统性能&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;吞吐量优先的方案将会尽可能减少系统执行垃圾回收的总时间，故可以考虑关注系统吞吐量的并行回收收集器。在拥有高性能的计算机上，进行吞吐量优先优化，可以使用参数：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;java –Xmx3800m –Xms3800m –Xmn2G –Xss128k –XX:+UseParallelGC&lt;br&gt;–XX:ParallelGC-Threads=20 –XX:+UseParallelOldGC&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;–Xmx380m –Xms3800m：设置 Java 堆的最大值和初始值。一般情况下，为了避免堆内存的频繁震荡，导致系统性能下降，我们的做法是设置最大堆等于最小堆。假设这里把最小堆减少为最大堆的一半，即 1900m，那么 JVM 会尽可能在 1900MB 堆空间中运行，如果这样，发生 GC 的可能性就会比较高；&lt;/li&gt;
    &lt;li&gt;-Xss128k：减少线程栈的大小，这样可以使剩余的系统内存支持更多的线程；&lt;/li&gt;
    &lt;li&gt;-Xmn2g：设置年轻代区域大小为 2GB；&lt;/li&gt;
    &lt;li&gt;–XX:+UseParallelGC：年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能地减少 GC 时间。&lt;/li&gt;
    &lt;li&gt;–XX:ParallelGC-Threads：设置用于垃圾回收的线程数，通常情况下，可以设置和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的；&lt;/li&gt;
    &lt;li&gt;–XX:+UseParallelOldGC：设置年老代使用并行回收收集器。&lt;/li&gt;
  &lt;/ul&gt;
  &lt;h4 id=&quot;尝试使用大的内存分页&quot;&gt;&lt;a href=&quot;#尝试使用大的内存分页&quot; class=&quot;headerlink&quot; title=&quot;尝试使用大的内存分页&quot;&gt;&lt;/a&gt;尝试使用大的内存分页&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;CPU 是通过寻址来访问内存的。32 位 CPU 的寻址宽度是 0~0xFFFFFFFF ，计算后得到的大小是 4G，也就是说可支持的物理内存最大是 4G。但在实践过程中，碰到了这样的问题，程序需要使用 4G 内存，而可用物理内存小于 4G，导致程序不得不降低内存占用。为了解决此类问题，现代 CPU 引入了 MMU（Memory Management Unit 内存管理单元）。MMU 的核心思想是利用虚拟地址替代物理地址，即 CPU 寻址时使用虚址，由 MMU 负责将虚址映射为物理地址。MMU
    的引入，解决了对物理内存的限制，对程序来说，就像自己在使用 4G 内存一样。内存分页 (Paging) 是在使用 MMU 的基础上，提出的一种内存管理机制。它将虚拟地址和物理地址按固定大小（4K）分割成页 (page) 和页帧 (page frame)，并保证页与页帧的大小相同。这种机制，从数据结构上，保证了访问内存的高效，并使 OS 能支持非连续性的内存分配。在程序内存不够用时，还可以将不常用的物理内存页转移到其他存储设备上，比如磁盘，这就是大家耳熟能详的虚拟内存。&lt;br&gt;&amp;emsp;&amp;emsp;在
    Solaris 系统中，JVM 可以支持 Large Page Size 的使用。使用大的内存分页可以增强 CPU 的内存寻址能力，从而提升系统的性能。&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;java –Xmx2506m –Xms2506m –Xmn1536m –Xss128k –XX:++UseParallelGC&lt;br&gt;–XX:ParallelGCThreads=20 –XX:+UseParallelOldGC –XX:+LargePageSizeInBytes=256m&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;–XX:+LargePageSizeInBytes：设置大页的大小。&lt;br&gt;过大的内存分页会导致 JVM 在计算 Heap 内部分区（perm, new, old）内存占用比例时，会出现超出正常值的划分，最坏情况下某个区会多占用一个页的大小。&lt;/li&gt;
  &lt;/ul&gt;
  &lt;h4 id=&quot;使用非占有的垃圾回收器&quot;&gt;&lt;a href=&quot;#使用非占有的垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;使用非占有的垃圾回收器&quot;&gt;&lt;/a&gt;使用非占有的垃圾回收器&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;为降低应用软件的垃圾回收时的停顿，首先考虑的是使用关注系统停顿的 CMS 回收器，其次，为了减少 Full GC 次数，应尽可能将对象预留在年轻代，因为年轻代 Minor GC 的成本远远小于年老代的 Full GC。&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;java –Xmx3550m –Xms3550m –Xmn2g –Xss128k –XX:ParallelGCThreads=20&lt;br&gt;–XX:+UseConcMarkSweepGC –XX:+UseParNewGC –XX:+SurvivorRatio=8 –XX:TargetSurvivorRatio=90&lt;br&gt;–XX:MaxTenuringThreshold=31&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;–XX:ParallelGCThreads=20：设置 20 个线程进行垃圾回收；&lt;/li&gt;
    &lt;li&gt;–XX:+UseParNewGC：年轻代使用并行回收器；&lt;/li&gt;
    &lt;li&gt;–XX:+UseConcMarkSweepGC：年老代使用 CMS 收集器降低停顿；&lt;/li&gt;
    &lt;li&gt;–XX:+SurvivorRatio：设置 Eden 区和 Survivor 区的比例为 8:1。稍大的 Survivor 空间可以提高在年轻代回收生命周期较短的对象的可能性，如果 Survivor 不够大，一些短命的对象可能直接进入年老代，这对系统来说是不利的。&lt;/li&gt;
    &lt;li&gt;–XX:TargetSurvivorRatio=90：设置 Survivor 区的可使用率。这里设置为 90%，则允许 90%的 Survivor 空间被使用。默认值是 50%。故该设置提高了 Survivor 区的使用率。当存放的对象超过这个百分比，则对象会向年老代压缩。因此，这个选项更有助于将对象留在年轻代。&lt;/li&gt;
    &lt;li&gt;–XX:MaxTenuringThreshold：设置年轻对象晋升到年老代的年龄。默认值是 15 次，即对象经过 15 次 Minor GC 依然存活，则进入年老代。这里设置为 31，目的是让对象尽可能地保存在年轻代区域。&lt;/li&gt;
  &lt;/ul&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前的文章&lt;a href=&quot;http://xiaolin.site/2016/05/30/jvm/&quot;&gt;《java基础拾遗——JVM垃圾回收原理》&lt;/a&gt;中已经介绍过年轻代、年老代、永生代，本文主要讲讲如何运用这些区域，为系统性能提供更好的帮助。本文不
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://xiaolin.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础拾遗——JVM垃圾回收原理</title>
    <link href="http://xiaolin.site/2016/05/30/jvm/"/>
    <id>http://xiaolin.site/2016/05/30/jvm/</id>
    <published>2016-05-30T08:20:10.000Z</published>
    <updated>2016-07-18T07:33:51.997Z</updated>
    
    <content type="html">&lt;h4 id=&quot;垃圾回收是个什么鬼？&quot;&gt;&lt;a href=&quot;#垃圾回收是个什么鬼？&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收是个什么鬼？&quot;&gt;&lt;/a&gt;垃圾回收是个什么鬼？&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;拥有自动垃圾回收机制可以说是Java与C++的一项显著区别。在C++语言中，程序员必须小心谨慎地处理每一项内存分配，且内存使用完后必须手工释放曾经占用的内存空间。当内存释放不够完全时，即存在分配但永不释放的内存块，就会引起内存泄漏，严重时甚至导致程序瘫痪，而java拥有自带的垃圾回收器可以自动释放没用的对象并清除内存记录碎片以减轻编程的负担。&lt;/p&gt;
&lt;h4 id=&quot;垃圾回收器常用的算法&quot;&gt;&lt;a href=&quot;#垃圾回收器常用的算法&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器常用的算法&quot;&gt;&lt;/a&gt;垃圾回收器常用的算法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;引用计数法 (Reference Counting)&lt;/strong&gt;&lt;br&gt;引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。&lt;br&gt;引用计数器的实现也非常简单，只需要为每个对象配置一个整形的计数器即可。但是引用计数器有一个严重的问题，即无法处理循环引用的情况。因此，在 Java 的垃圾回收器中没有使用这种算法。&lt;br&gt;一个简单的循环引用问题描述如下：有对象
      A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;标记-清除算法 (Mark-Sweep)&lt;/strong&gt;&lt;br&gt;标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。该算法最大的问题是存在大量的空间碎片，因为回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;复制算法 (Copying)&lt;/strong&gt;&lt;br&gt;将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，然后清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。&lt;br&gt;如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;标记-压缩算法 (Mark-Compact)&lt;/strong&gt;&lt;br&gt;复制算法的高效性是建立在存活对象少而垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。&lt;br&gt;标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。也首先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;增量算法 (Incremental Collecting)&lt;/strong&gt;&lt;br&gt;在垃圾回收过程中，应用软件将处于一种 CPU 消耗很高的状态。在这种 CPU 消耗很高的状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。&lt;br&gt;增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;分代 (Generational Collecting)&lt;/strong&gt;&lt;br&gt;根据垃圾回收对象的特性，不同阶段最优的方式是使用合适的算法用于本阶段的垃圾回收，分代算法即是基于这种思想，它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。以 Hot Spot 虚拟机为例，它将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。在老生代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老生代，将需要复制大量对象。再加上老生代的回收性价比也要低于新生代，因此这种做法也是不可取的。根据分代的思想，可以对老年代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;对分代算法通俗的理解就是：假设你是一个普通的 Java 对象，你出生在 Eden 区，在 Eden 区有许多和你差不多的小兄弟、小姐妹，可以把 Eden 区当成幼儿园，在这个幼儿园里大家玩了很长时间。Eden 区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到学校去上学，这里假设从小学到高中都称为 Survivor 区。开始的时候你在 Survivor 区里面划分出来的的“From”区，读到高年级了，就进了 Survivor 区的“To”区，中间由于学习成绩不稳定，还经常来回折腾。直到你
  18 岁的时候，高中毕业了，该去社会上闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里，你生活了 20 年 (每次 GC 加一岁)，最后寿终正寝，被 GC 回收。有一点没有提，你在年老代遇到了一个同学，他的名字叫爱德华 (慕光之城里的帅哥吸血鬼)，他以及他的家族永远不会死，那么他们就生活在永生代。&lt;/p&gt;
&lt;p&gt;从不同角度分析垃圾收集器，可以将其分为不同的类型。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。串行垃圾回收器一次只使用一个线程进行垃圾回收；并行垃圾回收器一次将开启多个线程同时进行垃圾回收。在并行能力较强的 CPU 上，使用并行垃圾回收器可以缩短 GC 的停顿时间。&lt;/li&gt;
  &lt;li&gt;按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间；独占式垃圾回收器 (Stop the world) 一旦运行，就停止应用程序中的其他所有线程，直到垃圾回收过程完全结束。&lt;/li&gt;
  &lt;li&gt;按碎片处理方式可分为压缩式垃圾回收器和非压缩式垃圾回收器。压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片；非压缩式的垃圾回收器不进行这步操作。&lt;/li&gt;
  &lt;li&gt;按工作的内存区间，又可分为新生代垃圾回收器和老年代垃圾回收器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以用以下指标评价一个垃圾处理器的好坏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：指在应用程序的生命周期内，应用程序所花费的时间和系统总运行时间的比值。系统总运行时间=应用程序耗时+GC 耗时。如果系统运行了 100min，GC 耗时 1min，那么系统的吞吐量就是 (100-1)/100=99%。&lt;br&gt;&lt;strong&gt;垃圾回收器负载&lt;/strong&gt;：和吞吐量相反，垃圾回收器负载指来记回收器耗时与系统运行总时间的比值。&lt;br&gt;&lt;strong&gt;停顿时间&lt;/strong&gt;：指垃圾回收器正在运行时，应用程序的暂停时间。对于独占回收器而言，停顿时间可能会比较长。使用并发的回收器时，由于垃圾回收器和应用程序交替运行，程序的停顿时间会变短，但是，由于其效率很可能不如独占垃圾回收器，故系统的吞吐量可能会较低。&lt;br&gt;&lt;strong&gt;垃圾回收频率&lt;/strong&gt;：指垃圾回收器多长时间会运行一次。一般来说，对于固定的应用而言，垃圾回收器的频率应该是越低越好。通常增大堆空间可以有效降低垃圾回收发生的频率，但是可能会增加回收产生的停顿时间。&lt;br&gt;&lt;strong&gt;反应时间&lt;/strong&gt;：指当一个对象被称为垃圾后多长时间内，它所占据的内存空间会被释放。&lt;br&gt;&lt;strong&gt;堆分配&lt;/strong&gt;：不同的垃圾回收器对堆内存的分配方式可能是不同的。一个良好的垃圾收集器应该有一个合理的堆内存区间划分。&lt;/p&gt;
&lt;h4 id=&quot;JVM-垃圾回收器分类&quot;&gt;
  &lt;a href=&quot;#JVM-垃圾回收器分类&quot; class=&quot;headerlink&quot; title=&quot;JVM 垃圾回收器分类&quot;&gt;&lt;/a&gt;JVM 垃圾回收器分类&lt;/h4&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;新生代串行收集器&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;串行收集器主要有两个特点：第一，它仅仅使用单线程进行垃圾回收；第二，它独占式的垃圾回收。&lt;br&gt;在串行收集器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收的完成，这样给用户体验造成较差效果。虽然如此，串行收集器却是一个成熟、经过长时间生产环境考验的极为高效的收集器。新生代串行处理器使用复制算法，实现相对简单，逻辑处理特别高效，且没有线程切换的开销。在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。在
      HotSpot 虚拟机中，使用-XX：+UseSerialGC 参数可以指定使用新生代串行收集器和老年代串行收集器。当 JVM 在 Client 模式下运行时，它是默认的垃圾收集器。一次新生代串行收集器的工作输出日志类似：&lt;/li&gt;
  &lt;/ul&gt;
  &lt;blockquote&gt;
    &lt;p&gt;[GC [DefNew: 3468K-&amp;gt;150K(9216K), 0.0028638 secs][Tenured:&lt;br&gt;1562K-&amp;gt;1712K(10240K), 0.0084220 secs] 3468K-&amp;gt;1712K(19456K),&lt;br&gt;[Perm : 377K-&amp;gt;377K(12288K)],&lt;br&gt;0.0113816 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;它显示了一次垃圾回收前的新生代的内存占用量和垃圾回收后的新生代内存占用量，以及垃圾回收所消耗的时间。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;老年代串行收集器&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;老年代串行收集器使用的是标记-压缩算法。和新生代串行收集器一样，它也是一个串行的、独占式的垃圾回收器。由于老年代垃圾回收通常会使用比新生代垃圾回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序很可能会因此停顿几秒甚至更长时间。虽然如此，老年代串行回收器可以和多种新生代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。若要启用老年代串行回收器，可以尝试使用以下参数：-XX:+UseSerialGC:
        新生代、老年代都使用串行回收器。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;并行收集器&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;并行收集器是工作在新生代的垃圾收集器，它只简单地将串行回收器多线程化。它的回收策略、算法以及参数和串行回收器一样。&lt;br&gt;&amp;emsp;&amp;emsp;并行回收器也是独占式的回收器，在收集过程中，应用程序会全部暂停。但由于并行回收器使用多线程进行垃圾回收，因此，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者并发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。&lt;br&gt;&amp;emsp;&amp;emsp;开启并行回收器可以使用参数-XX:+UseParNewGC，该参数设置新生代使用并行收集器，老年代使用串行收集器。&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;p&gt;[GC [ParNew: 825K-&amp;gt;161K(4928K), 0.0155258 secs][Tenured: 8704K-&amp;gt;661K(10944K),&lt;br&gt;0.0071964 secs] 9017K-&amp;gt;661K(15872K),&lt;br&gt;[Perm : 2049K-&amp;gt;2049K(12288K)], 0.0228090 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]&lt;br&gt;Heap&lt;br&gt;par new
          generation total 4992K, used 179K [0x0f010000, 0x0f570000, 0x14560000)&lt;br&gt;eden space 4480K, 4% used [0x0f010000, 0x0f03cda8, 0x0f470000)&lt;br&gt;from space 512K, 0% used [0x0f470000, 0x0f470000, 0x0f4f0000)&lt;br&gt;to space 512K, 0% used [0x0f4f0000,
          0x0f4f0000, 0x0f570000)&lt;br&gt;tenured generation total 10944K, used 8853K [0x14560000, 0x15010000, 0x1f010000)&lt;br&gt;the space 10944K, 80% used [0x14560000, 0x14e057c0, 0x14e05800, 0x15010000)&lt;br&gt;compacting perm gen total 12288K, used 2060K [0x1f010000,
          0x1fc10000, 0x23010000)&lt;br&gt;the space 12288K, 16% used [0x1f010000, 0x1f213228, 0x1f213400, 0x1fc10000)&lt;br&gt;No shared spaces configured.&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;并行收集器工作时的线程数量可以使用-XX:ParallelGCThreads 参数指定。一般，最好与 CPU 数量相当，避免过多的线程数影响垃圾收集性能。在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 数量，大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU_Count]/8]。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;新生代并行回收 (Parallel Scavenge) 收集器&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;新生代并行回收收集器也是使用复制算法的收集器。从表面上看，它和并行收集器一样都是多线程、独占式的收集器。但是，并行回收收集器有一个重要的特点：它非常关注系统的吞吐量。&lt;br&gt;新生代并行回收收集器可以使用以下参数启用：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;-XX:+UseParallelGC:新生代使用并行回收收集器，老年代使用串行收集器。&lt;br&gt;-XX:+UseParallelOldGC:新生代和老年代都是用并行回收收集器。&lt;br&gt;-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间，它的值是一个大于 0 的整数。收集器在工作时会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。如果希望减少停顿时间，而把这个值设置得很小，为了达到预期的停顿时间，JVM 可能会使用一个较小的堆
      (一个小堆比一个大堆回收快)，而这将导致垃圾回收变得很频繁，从而增加了垃圾回收总时间，降低了吞吐量。&lt;br&gt;-XX:+GCTimeRatio：设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。比如 GCTimeRatio 等于 19，则系统用于垃圾收集的时间不超过 1/(1+19)=5%。默认情况下，它的取值是 99，即不超过 1%的时间用于垃圾收集。&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;除此之外，并行回收收集器与并行收集器另一个不同之处在于，它支持一种自适应的 GC 调节策略，使用-XX:+UseAdaptiveSizePolicy 可以打开自适应 GC 策略。在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;老年代并行回收收集器&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;老年代的并行回收收集器也是一种多线程并发的收集器。和新生代并行回收收集器一样，它也是一种关注吞吐量的收集器。老年代并行回收收集器使用标记-压缩算法，JDK1.6 之后开始启用。&lt;br&gt;使用-XX:+UseParallelOldGC 可以在新生代和老生代都使用并行回收收集器，这是一对非常关注吞吐量的垃圾收集器组合，在对吞吐量敏感的系统中，可以考虑使用。参数-XX:ParallelGCThreads 也可以用于设置垃圾回收时的线程数量。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;CMS 收集器&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;与并行回收收集器不同，CMS 收集器主要关注于系统停顿时间。CMS 是 Concurrent Mark Sweep 的缩写，意为并发标记清除，从名称上可以得知，它使用的是标记-清除算法，同时它又是一个使用多线程并发回收的垃圾收集器。&lt;br&gt;&amp;emsp;&amp;emsp;CMS 工作时，主要步骤有：初始标记、并发标记、重新标记、并发清除和并发重置。其中初始标记和重新标记是独占系统资源的，而并发标记、并发清除和并发重置是可以和用户线程一起执行的。因此，从整体上来说，CMS
        收集不是独占式的，它可以在应用程序运行过程中进行垃圾回收。&lt;br&gt;&amp;emsp;&amp;emsp;根据标记-清除算法，初始标记、并发标记和重新标记都是为了标记出需要回收的对象。并发清理则是在标记完成后，正式回收垃圾对象；并发重置是指在垃圾回收完成后，重新初始化 CMS 数据结构和数据，为下一次垃圾回收做好准备。并发标记、并发清理和并发重置都是可以和应用程序线程一起执行的。&lt;br&gt;&amp;emsp;&amp;emsp;CMS 收集器在其主要的工作阶段虽然没有暴力地彻底暂停应用程序线程，但是由于它和应用程序线程并发执行，相互抢占
        CPU，所以在 CMS 执行期内对应用程序吞吐量造成一定影响。CMS 默认启动的线程数是 (ParallelGCThreads+3)/4),ParallelGCThreads 是新生代并行收集器的线程数，也可以通过-XX:ParallelCMSThreads 参数手工设定 CMS 的线程数量。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。&lt;br&gt;&amp;emsp;&amp;emsp;由于 CMS 收集器不是独占式的回收器，在 CMS 回收过程中，应用程序仍然在不停地工作。在应用程序工作过程中，又会不断地产生垃圾。这些新生成的垃圾在当前
        CMS 回收过程中是无法清除的。同时，因为应用程序没有中断，所以在 CMS 回收过程中，还应该确保应用程序有足够的内存可用。因此，CMS 收集器不会等待堆内存饱和时才进行垃圾回收，而是当前堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。&lt;br&gt;&amp;emsp;&amp;emsp;这个回收阈值可以使用-XX:CMSInitiatingOccupancyFraction 来指定，默认是 68。即当老年代的空间使用率达到 68%时，会执行一次
        CMS 回收。如果应用程序的内存使用率增长很快，在 CMS 的执行过程中，已经出现了内存不足的情况，此时，CMS 回收将会失败，JVM 将启动老年代串行收集器进行垃圾回收。如果这样，应用程序将完全中断，直到垃圾收集完成，这时，应用程序的停顿时间可能很长。因此，根据应用程序的特点，可以对-XX:CMSInitiatingOccupancyFraction 进行调优。如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。&lt;br&gt;&amp;emsp;&amp;emsp;标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的，为了解决这个问题，CMS
        收集器还提供了几个用于内存压缩整理的算法。&lt;br&gt;&amp;emsp;&amp;emsp;-XX:+UseCMSCompactAtFullCollection 参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。-XX:CMSFullGCsBeforeCompaction 参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;G1 收集器 (Garbage First)&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;G1 收集器的目标是作为一款服务器的垃圾收集器，因此，它在吞吐量和停顿控制上，预期要优于 CMS 收集器。&lt;br&gt;&amp;emsp;&amp;emsp;与 CMS 收集器相比，G1 收集器是基于标记-压缩算法的。因此，它不会产生空间碎片，也没有必要在收集完成后，进行一次独占式的碎片整理工作。G1 收集器还可以进行非常精确的停顿控制。它可以让开发人员指定当停顿时长为 M 时，垃圾回收时间不超过
        N。使用参数-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC 来启用 G1 回收器，设置 G1 回收器的目标停顿时间：-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200。&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;h4 id=&quot;收集器对系统性能的影响&quot;&gt;&lt;a href=&quot;#收集器对系统性能的影响&quot; class=&quot;headerlink&quot; title=&quot;收集器对系统性能的影响&quot;&gt;&lt;/a&gt;收集器对系统性能的影响&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;通过运行 1 万次循环，每次分配 512*100B 空间，采用不同的垃圾回收器，输出程序运行所消耗的时间。&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.HashMap;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GCTimeTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; HashMap map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; begintime = System.currentTimeMillis();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (map.size() * &lt;span class=&quot;number&quot;&gt;512&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt; &amp;gt;= &lt;span class=&quot;number&quot;&gt;400&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        map.clear();&lt;span class=&quot;comment&quot;&gt;// 保护内存不溢出&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;clean map&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] b1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; j++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        b1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;512&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        map.put(System.nanoTime(), b1);&lt;span class=&quot;comment&quot;&gt;// 不断消耗内存&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; endtime = System.currentTimeMillis();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(endtime - begintime);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;使用参数-Xmx512M -Xms512M -XX:+UseParNewGC 运行代码，输出如下：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;clean map 8565&lt;br&gt;cost time=1655&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;使用参数-Xmx512M -Xms512M -XX:+UseParallelOldGC –XX:ParallelGCThreads=8 运行代码，输出如下：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;clean map 8798&lt;br&gt;cost time=1998&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;使用参数-Xmx512M -Xms512M -XX:+UseSerialGC 运行代码，输出如下：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;clean map 8864&lt;br&gt;cost time=1717&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;使用参数-Xmx512M -Xms512M -XX:+UseConcMarkSweepGC 运行代码，输出如下：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;clean map 8862&lt;br&gt;cost time=1530&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;上面例子的 GC 输出可以看出，采用不同的垃圾回收机制及设定不同的线程数，对于代码段的整体执行时间有较大的影响。需要读者有针对性地选用适合自己代码段的垃圾回收机制。&lt;/p&gt;
  &lt;h4 id=&quot;GC-相关参数总结&quot;&gt;&lt;a href=&quot;#GC-相关参数总结&quot; class=&quot;headerlink&quot; title=&quot;GC 相关参数总结&quot;&gt;&lt;/a&gt;GC 相关参数总结&lt;/h4&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;与串行回收器相关的参数&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;p&gt;-XX:+UseSerialGC:在新生代和老年代使用串行回收器。&lt;br&gt;-XX:+SuivivorRatio:设置 eden 区大小和 survivor 区大小的比例。&lt;br&gt;-XX:+PretenureSizeThreshold:设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。&lt;br&gt;-XX:MaxTenuringThreshold:设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;与并行 GC 相关的参数&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;p&gt;-XX:+UseParNewGC: 在新生代使用并行收集器。&lt;br&gt;-XX:+UseParallelOldGC: 老年代使用并行回收收集器。&lt;br&gt;-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。&lt;br&gt;-XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在
          MaxGCPauseMills 以内。&lt;br&gt;-XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。&lt;br&gt;-XX:+UseAdaptiveSizePolicy:打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;与 CMS 回收器相关的参数&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;p&gt;-XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS+串行收集器。&lt;br&gt;-XX:+ParallelCMSThreads: 设定 CMS 的线程数量。&lt;br&gt;-XX:+CMSInitiatingOccupancyFraction:设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。&lt;br&gt;-XX:+UseFullGCsBeforeCompaction:设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。&lt;br&gt;-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收。&lt;br&gt;-XX:+CMSParallelRemarkEndable:启用并行重标记。&lt;br&gt;-XX:CMSInitatingPermOccupancyFraction:当永久区占用率达到这一百分比后，启动
          CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。&lt;br&gt;-XX:UseCMSInitatingOccupancyOnly:表示只在到达阈值的时候，才进行 CMS 回收。&lt;br&gt;-XX:+CMSIncrementalMode:使用增量模式，比较适合单 CPU。&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;与 G1 回收器相关的参数&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;p&gt;-XX:+UseG1GC：使用 G1 回收器。&lt;br&gt;-XX:+UnlockExperimentalVMOptions:允许使用实验性参数。&lt;br&gt;-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间。&lt;br&gt;-XX:+GCPauseIntervalMills:设置停顿间隔时间。&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;其他参数&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;p&gt;-XX:+DisableExplicitGC: 禁用显示 GC。&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
  &lt;/ol&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;垃圾回收是个什么鬼？&quot;&gt;&lt;a href=&quot;#垃圾回收是个什么鬼？&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收是个什么鬼？&quot;&gt;&lt;/a&gt;垃圾回收是个什么鬼？&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;拥有自动垃圾回收机制可以说是Java与C++的一项
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://xiaolin.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础拾遗——泛型</title>
    <link href="http://xiaolin.site/2016/05/30/java-generic/"/>
    <id>http://xiaolin.site/2016/05/30/java-generic/</id>
    <published>2016-05-30T02:50:10.000Z</published>
    <updated>2016-07-18T07:33:51.969Z</updated>
    
    <content type="html">&lt;h4 id=&quot;什么是泛型？&quot;&gt;&lt;a href=&quot;#什么是泛型？&quot; class=&quot;headerlink&quot; title=&quot;什么是泛型？&quot;&gt;&lt;/a&gt;什么是泛型？&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Java泛型（generics）是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面来说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。而从不好的地方来说，为了保证与旧有版本的兼容性，Java泛型的实现上存在着一些不够优雅的地方。当然这也是任何有历史的编程语言所需要承担的历史包袱。后续的版本更新会为早期的设计缺陷所累。&lt;br&gt;&amp;emsp;&amp;emsp;开发人员在使用泛型的时候，很容易根据自己的直觉而犯一些错误。比如一个方法如果接收List&lt;object&gt;作为形式参数，那么如果尝试将一个List&lt;string&gt;的对象作为实际参数传进去，却发现无法通过编译。虽然从直觉上来说，Object是String的父类，这种类型转换应该是合理的。但是实际上这会产生隐含的类型转换问题，因此编译器直接就禁止这样的行为。本文试图对Java泛型做一个概括性的说明。&lt;/string&gt;&lt;/object&gt;&lt;/p&gt;
&lt;h4 id=&quot;类型擦除&quot;&gt;
  &lt;a href=&quot;#类型擦除&quot; class=&quot;headerlink&quot; title=&quot;类型擦除&quot;&gt;&lt;/a&gt;类型擦除&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List&lt;object&gt;和List&lt;string&gt;等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。&lt;/string&gt;&lt;/object&gt;&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;泛型类并没有自己独有的Class类对象。比如并不存在List
      &lt;string&gt;.class或是List
        &lt;integer&gt;.class，而只有List.class。&lt;/integer&gt;
      &lt;/string&gt;
    &lt;/li&gt;
    &lt;li&gt;静态变量是被泛型类的所有实例所共享的。对于声明为MyClass
      &lt;t&gt;的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass
        &lt;string&gt;还是new MyClass
          &lt;integer&gt;创建的对象，都是共享一个静态变量。&lt;/integer&gt;
        &lt;/string&gt;
      &lt;/t&gt;
    &lt;/li&gt;
    &lt;li&gt;泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException
      &lt;string&gt;和MyException
        &lt;integer&gt;的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。&lt;/integer&gt;
      &lt;/string&gt;
    &lt;/li&gt;
    &lt;li&gt;类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉&amp;lt;&amp;gt;的内容。比如T get()方法声明就变成了Object get()；List
      &lt;string&gt;就变成了List。接下来就可能需要生成一些桥接方法（bridge method）。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：&lt;/string&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyString&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String str)&lt;/span&gt; &lt;/span&gt;&amp;#123;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;当类型信息被擦除之后，上述类的声明变成了class MyString implements Comparable。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的int compareTo(Object)方法。这个时候就由编译器来动态生成这个方法。&lt;/p&gt;
  &lt;h4 id=&quot;实例分析&quot;&gt;&lt;a href=&quot;#实例分析&quot; class=&quot;headerlink&quot; title=&quot;实例分析&quot;&gt;&lt;/a&gt;实例分析&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;了解了类型擦除机制之后，就会明白编译器承担了全部的类型检查工作。编译器禁止某些泛型的使用方式，正是为了确保类型的安全性。以上面提到的List&lt;object&gt;和List&lt;string&gt;为例来具体分析：&lt;/string&gt;&lt;/object&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inspect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Object&amp;gt; list)&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Object obj : list) &amp;#123;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(obj);    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    list.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//这个操作在当前方法的上下文是合法的。 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; strs = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    inspect(strs); &lt;span class=&quot;comment&quot;&gt;//编译错误 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;这段代码中，inspect方法接受List&lt;object&gt;作为参数，当在test方法中试图传入List&lt;string&gt;的时候，会出现编译错误。假设这样的做法是允许的，那么在inspect方法就可以通过list.add(1)来向集合中添加一个数字。这样在test方法看来，其声明为List&lt;string&gt;的集合中却被添加了一个Integer类型的对象。这显然是违反类型安全的原则的，在某个时候肯定会抛出ClassCastException。因此，编译器禁止这样的行为。编译器会尽可能的检查可能存在的类型安全问题。对于确定是违反相关原则的地方，会给出编译错误。当编译器无法判断类型的使用是否正确的时候，会给出警告信息。&lt;/string&gt;&lt;/string&gt;&lt;/object&gt;&lt;/p&gt;
  &lt;h4 id=&quot;通配符与上下界&quot;&gt;
    &lt;a href=&quot;#通配符与上下界&quot; class=&quot;headerlink&quot; title=&quot;通配符与上下界&quot;&gt;&lt;/a&gt;通配符与上下界&lt;/h4&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;在使用泛型类的时候，既可以指定一个具体的类型，如List
      &lt;string&gt;就声明了具体的类型是String；也可以用通配符?来表示未知类型，如List&amp;lt;?&amp;gt;就声明了List中包含的元素类型是未知的。 通配符所代表的其实是一组类型，但具体的类型是未知的。List&amp;lt;?&amp;gt;所声明的就是所有类型都是可以的。但是List&amp;lt;?&amp;gt;并不等同于List&lt;object&gt;。List&lt;object&gt;实际上确定了List中包含的是Object及其子类，在使用的时候都可以通过Object来进行引用。而List&amp;lt;?&amp;gt;则其中所包含的元素类型是不确定。其中可能包含的是String，也可能是 Integer。如果它包含了String的话，往里面添加Integer类型的元素就是错误的。正因为类型未知，就不能通过new ArrayList&amp;lt;?&amp;gt;()的方法来创建一个新的ArrayList对象。因为编译器无法知道具体的类型是什么。但是对于 List&amp;lt;?&amp;gt;中的元素确总是可以用Object来引用的，因为虽然类型未知，但肯定是Object及其子类。考虑下面的代码：&lt;/object&gt;&lt;/object&gt;
      &lt;/string&gt;
    &lt;/p&gt;
    &lt;figure class=&quot;highlight java&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wildcard&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;?&amp;gt; list)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    list.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//编译错误 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;如上所示，试图对一个带通配符的泛型类进行操作的时候，总是会出现编译错误。其原因在于通配符所表示的类型是未知的。&lt;/p&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;因为对于List&amp;lt;?&amp;gt;中的元素只能用Object来引用，在有些情况下不是很方便。在这些情况下，可以使用上下界来限制未知类型的范围。 如List&amp;lt;? extends Number&amp;gt;说明List中可能包含的元素类型是Number及其子类。而List&amp;lt;? super Number&amp;gt;则说明List中包含的是Number及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。比如访问 List&amp;lt;? extends Number&amp;gt;的时候，就可以使用Number类的intValue等方法。&lt;/p&gt;
    &lt;h4 id=&quot;类型系统&quot;&gt;
      &lt;a href=&quot;#类型系统&quot; class=&quot;headerlink&quot; title=&quot;类型系统&quot;&gt;&lt;/a&gt;类型系统&lt;/h4&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;在Java中，大家比较熟悉的是通过继承机制而产生的类型体系结构。比如String继承自Object。根据Liskov替换原则，子类是可以替换父类的。当需要Object类的引用的时候，如果传入一个String对象是没有任何问题的。但是反过来的话，即用父类的引用替换子类引用的时候，就需要进行强制类型转换。编译器并不能保证运行时刻这种转换一定是合法的。这种自动的子类替换父类的类型转换机制，对于数组也是适用的。 String[]可以替换Object[]。但是泛型的引入，对于这个类型系统产生了一定的影响。正如前面提到的List
        &lt;string&gt;是不能替换掉List&lt;object&gt;的。&lt;/object&gt;&lt;/string&gt;
      &lt;/p&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 List
        &lt;string&gt;和List&lt;object&gt;这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：&lt;/object&gt;&lt;/string&gt;
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即List
          &lt;string&gt;是Collection
            &lt;string&gt;的子类型，List
              &lt;string&gt;可以替换Collection
                &lt;string&gt;。这种情况也适用于带有上下界的类型声明。&lt;/string&gt;
              &lt;/string&gt;
            &lt;/string&gt;
          &lt;/string&gt;
        &lt;/li&gt;
        &lt;li&gt;当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对Collection&amp;lt;? extends Number&amp;gt;来说，其子类型可以在Collection这个维度上展开，即List&amp;lt;? extends Number&amp;gt;和Set&amp;lt;? extends Number&amp;gt;等；也可以在Number这个层次上展开，即Collection
          &lt;double&gt;和 Collection
            &lt;integer&gt;等。如此循环下去，ArrayList
              &lt;long&gt;和 HashSet
                &lt;double&gt;等也都算是Collection&amp;lt;? extends Number&amp;gt;的子类型。&lt;/double&gt;
              &lt;/long&gt;
            &lt;/integer&gt;
          &lt;/double&gt;
        &lt;/li&gt;
        &lt;li&gt;如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;理解了上面的规则之后，就可以很容易的修正实例分析中给出的代码了。只需要把List&lt;object&gt;改成List&amp;lt;?&amp;gt;即可。List&lt;string&gt;是List&amp;lt;?&amp;gt;的子类型，因此传递参数时不会发生错误。&lt;/string&gt;&lt;/object&gt;&lt;/p&gt;
      &lt;h4 id=&quot;开发自己的泛型类&quot;&gt;&lt;a href=&quot;#开发自己的泛型类&quot; class=&quot;headerlink&quot; title=&quot;开发自己的泛型类&quot;&gt;&lt;/a&gt;开发自己的泛型类&lt;/h4&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;泛型类与一般的Java类基本相同，只是在类和接口定义上多出来了用&amp;lt;&amp;gt;声明的类型参数。一个类可以有多个类型参数，如 MyClass
        &lt;x ,=&quot;&quot; y,=&quot;&quot; z=&quot;&quot;&gt;。 每个类型参数在声明的时候可以指定上界。所声明的类型参数在Java类中可以像一般的类型一样作为方法的参数和返回值，或是作为域和局部变量的类型。但是由于类型擦除机制，类型参数并不能用来创建对象或是作为静态变量的类型。考虑下面的泛型类中的正确和错误的用法。&lt;/x&gt;
      &lt;/p&gt;
      &lt;figure class=&quot;highlight java&quot;&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
            &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassTest&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Number&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Y&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Z&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; X x;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Y y; &lt;span class=&quot;comment&quot;&gt;//编译错误，不能用在静态变量中    &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; X &lt;span class=&quot;title&quot;&gt;getFirst&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//正确用法        &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wrong&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Z z = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Z(); &lt;span class=&quot;comment&quot;&gt;//编译错误，不能创建对象    &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;
      &lt;/figure&gt;
      &lt;h4 id=&quot;最佳实践&quot;&gt;&lt;a href=&quot;#最佳实践&quot; class=&quot;headerlink&quot; title=&quot;最佳实践&quot;&gt;&lt;/a&gt;最佳实践&lt;/h4&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;在使用泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;在代码中避免泛型类和原始类型的混用。比如List
          &lt;string&gt;和List不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。当需要利用JDK 5之前开发的遗留代码，而不得不这么做时，也尽可能的隔离相关的代码。&lt;/string&gt;
        &lt;/li&gt;
        &lt;li&gt;在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。&lt;/li&gt;
        &lt;li&gt;泛型类最好不要同数组一块使用。你只能创建new List&amp;lt;?&amp;gt;[10]这样的数组，无法创建new List
          &lt;string&gt;[10]这样的。这限制了数组的使用能力，而且会带来很多费解的问题。因此，当需要类似数组的功能时候，使用集合类即可。&lt;/string&gt;
        &lt;/li&gt;
        &lt;li&gt;不要忽视编译器给出的警告信息。&lt;/li&gt;
      &lt;/ul&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是泛型？&quot;&gt;&lt;a href=&quot;#什么是泛型？&quot; class=&quot;headerlink&quot; title=&quot;什么是泛型？&quot;&gt;&lt;/a&gt;什么是泛型？&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Java泛型（generics）是JDK 5中引入的一个新特性，允许在定义类和接口
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://xiaolin.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础拾遗——动态代理</title>
    <link href="http://xiaolin.site/2016/05/29/java-dynamic-proxy/"/>
    <id>http://xiaolin.site/2016/05/29/java-dynamic-proxy/</id>
    <published>2016-05-29T09:04:34.000Z</published>
    <updated>2016-07-18T07:33:51.964Z</updated>
    
    <content type="html">&lt;h4 id=&quot;什么是动态代理？&quot;&gt;&lt;a href=&quot;#什么是动态代理？&quot; class=&quot;headerlink&quot; title=&quot;什么是动态代理？&quot;&gt;&lt;/a&gt;什么是动态代理？&lt;/h4&gt;
&lt;p&gt;① 首先你要明白静态代理的作用&lt;br&gt;我们有一个字体提供类，有多种实现（从磁盘，从网络，从系统）&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FontProvider&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Font &lt;span class=&quot;title&quot;&gt;getFont&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ProviderFactory&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; FontProvider &lt;span class=&quot;title&quot;&gt;getFontProvider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FontProviderFromDisk();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; class &lt;span class=&quot;title&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        FontProvider fontProvider = ProviderFactory.getFontProvider();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Font font = fontProvider.getFont(&lt;span class=&quot;string&quot;&gt;&quot;微软雅黑&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ......&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;现在我们希望给他加上一个缓存功能，我们可以用静态代理来完成&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CachedFontProvider&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FontProvider&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; FontProvider fontProvider;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;String, Font&amp;gt; cached;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CachedFontProvider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(FontProvider fontProvider)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.fontProvider = fontProvider;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Font &lt;span class=&quot;title&quot;&gt;getFont&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Font font = cached.get(name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (font == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            font = fontProvider.getFont(name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            cached.put(name, font);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; font;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 对工厂类进行相应修改，代码使用处不必进行任何修改。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   这也是面向接口编程以及工厂模式的一个好处 */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ProviderFactory&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; FontProvider &lt;span class=&quot;title&quot;&gt;getFontProvider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CachedFontProvider(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FontProviderFromDisk());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;当然，我们直接修改FontProviderFromDisk类也可以实现目的，但是我们还有FontProviderFromNet, FontProviderFromSystem等多种实现类，一一修改太过繁琐且易出错。&lt;br&gt;况且将来还可能添加日志，权限检查，异常处理等功能显然用代理类更好一点。&lt;/p&gt;
&lt;p&gt;② 然而为什么要用动态代理？&lt;br&gt;考虑以下各种情况，有多个提供类，每个类都有getXxx(String name)方法，每个类都要加入缓存功能，使用静态代理虽然也能实现，但是也是略显繁琐，需要手动一一创建代理类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ProviderFactory&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; FontProvider &lt;span class=&quot;title&quot;&gt;getFontProvider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;...&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ImageProvider &lt;span class=&quot;title&quot;&gt;getImageProvider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;...&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; MusicProvider &lt;span class=&quot;title&quot;&gt;getMusicProvider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;...&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ......&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;使用动态代理怎么完成呢？&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CachedProviderHandler&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; cached = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Object target;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CachedProviderHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object target)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.target = target;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Type[] types = method.getParameterTypes();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (method.getName().matches(&lt;span class=&quot;string&quot;&gt;&quot;get.+&quot;&lt;/span&gt;) &amp;amp;&amp;amp; (types.length == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;amp;&amp;amp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                (types[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == String.class)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            String key = (String) args[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            Object value = cached.get(key);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (value == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                value = method.invoke(target, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                cached.put(key, value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; method.invoke(target, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ProviderFactory&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; FontProvider &lt;span class=&quot;title&quot;&gt;getFontProvider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Class&amp;lt;FontProvider&amp;gt; targetClass = FontProvider.class;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (FontProvider) Proxy.newProxyInstance(targetClass.getClassLoader(),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Class[] &amp;#123; targetClass &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CachedProviderHandler(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FontProviderFromDisk()));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;③ 这也是为什么Spring这么受欢迎的一个原因&lt;br&gt;Spring容器代替工厂，Spring AOP代替JDK动态代理，让面向切面编程更容易实现。&lt;br&gt;在Spring的帮助下轻松添加，移除动态代理，且对源代码无任何影响。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是动态代理？&quot;&gt;&lt;a href=&quot;#什么是动态代理？&quot; class=&quot;headerlink&quot; title=&quot;什么是动态代理？&quot;&gt;&lt;/a&gt;什么是动态代理？&lt;/h4&gt;
&lt;p&gt;① 首先你要明白静态代理的作用&lt;br&gt;我们有一个字体提供类，有多种实现（从磁盘，从网络，从
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://xiaolin.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础拾遗——反射</title>
    <link href="http://xiaolin.site/2016/05/29/java-reflection/"/>
    <id>http://xiaolin.site/2016/05/29/java-reflection/</id>
    <published>2016-05-29T05:05:39.000Z</published>
    <updated>2016-07-18T07:33:51.974Z</updated>
    
    <content type="html">&lt;h4 id=&quot;什么是反射？&quot;&gt;&lt;a href=&quot;#什么是反射？&quot; class=&quot;headerlink&quot; title=&quot;什么是反射？&quot;&gt;&lt;/a&gt;什么是反射？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Java 反射机制主要提供了以下功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在运行时判断任意一个对象所属的类。&lt;/li&gt;
  &lt;li&gt;在运行时构造任意一个类的对象。&lt;/li&gt;
  &lt;li&gt;在运行时判断任意一个类所具有的成员变量和方法。&lt;/li&gt;
  &lt;li&gt;在运行时调用任意一个对象的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;正如英文单词reflection的含义一样，使用反射API的时候就好像在看一个Java类在水中的倒影一样。通过反射API我们可以获取程序在运行时刻的内部结构。知道了Java类的内部结构之后，就可以与它进行交互，包括创建新的对象和调用对象中的方法等。这种交互方式与直接在源代码中使用的效果是相同的，但是又额外提供了运行时刻的灵活性。&lt;br&gt;&amp;emsp;&amp;emsp;“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。尽管在这样的定义与分类下Java不是动态语言，它却有着一个非常突出的动态相关机制：Reflection。这个字的意思是“反射、映象、倒影”，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。这种“看透class”的能力（the
  ability of the program to examine itself）被称为introspection（内省、内观、反省）。&lt;br&gt;&amp;emsp;&amp;emsp;使用反射的一个最大的弊端是&lt;strong&gt;性能比较差&lt;/strong&gt;。相同的操作，用反射API所需的时间大概比直接的使用要慢一两个数量级。不过现在的JVM实现中，反射操作的性能已经有了很大的提升。在灵活性与性能之间，总是需要进行权衡的。应用可以在适当的时机来使用反射API。&lt;/p&gt;
&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;第一个主要作用是获取程序在运行时刻的内部结构。这对于程序的检查工具和调试器来说，是非常实用的功能。只需要短短的十几行代码，就可以遍历出来一个Java类的内部结构，包括其中的构造方法、声明的域和定义的方法等。只要有了java.lang.Class类 的对象，就可以通过其中的方法来获取到该类中的构造方法、域和方法。对应的方法分别是getConstructor、getField和getMethod。这三个方法还有相应的getDeclaredXXX版本，区别在于getDeclaredXXX版本的方法只会获取该类自身所声明的元素，而不会考虑继承下来的。&lt;br&gt;&amp;emsp;&amp;emsp;反射API的另外一个作用是在运行时刻对一个Java对象进行操作。
  这些操作包括动态创建一个Java类的对象，获取某个域的值以及调用某个方法。在Java源代码中编写的对类和对象的操作，都可以在运行时刻通过反射API来实现。考虑下面一个简单的Java类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; start)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        count = start;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;increase&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        count = count + step;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用一般做法和反射API都非常简单。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;MyClass myClass = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyClass(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//一般做法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;myClass.increase(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Normal -&amp;gt; &quot;&lt;/span&gt; + myClass.count);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Constructor constructor = MyClass.class.getConstructor(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;.class); &lt;span class=&quot;comment&quot;&gt;//获取构造方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MyClass myClassReflect = constructor.newInstance(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//创建对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Method method = MyClass.class.getMethod(&lt;span class=&quot;string&quot;&gt;&quot;increase&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;.class);  &lt;span class=&quot;comment&quot;&gt;//获取方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    method.invoke(myClassReflect, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//调用方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Field field = MyClass.class.getField(&lt;span class=&quot;string&quot;&gt;&quot;count&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//获取域&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Reflect -&amp;gt; &quot;&lt;/span&gt; + field.getInt(myClassReflect)); &lt;span class=&quot;comment&quot;&gt;//获取域的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    e.printStackTrace();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;使用Java反射API的时候
  &lt;font color=&quot;red&quot;&gt;可以绕过Java默认的访问控制检查&lt;/font&gt;，比如可以直接获取到对象的私有域的值或是调用私有方法。只需要在获取到Constructor、Field和Method类的对象之后，调用setAccessible方法并设为true即可。有了这种机制，就可以很方便的在运行时刻获取到程序的内部状态。&lt;/p&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Java 反射API的存在，为Java语言添加了一定程度上的动态性，可以实现某些动态语言中的功能。比如在JavaScript的代码中，可以通过 obj[“set” + propName]()来根据变量propName的值找到对应的方法进行调用。虽然在Java源代码中不能这么写，但是通过反射API同样可以实现类似 的功能。这对于处理某些遗留代码来说是有帮助的。比如所需要使用的类有多个版本，每个版本所提供的方法名称和参数不尽相同。而调用代码又必须与这些不同的版本都能协同工作，就可以通过反射API来依次检查实际的类中是否包含某个方法来选择性的调用。&lt;br&gt;&amp;emsp;&amp;emsp;Java
  反射API实际上定义了一种相对于编译时刻而言更加松散的契约。如果被调用的Java对象中并不包含某个方法，而在调用者代码中进行引用的话，在编译时刻就会出现错误。而反射API则可以把这样的检查推迟到运行时刻来完成。通过把Java中的字节代码增强、类加载器和反射API结合起来，可以处理一些对灵活性要求很高的场景。&lt;br&gt;&amp;emsp;&amp;emsp;在有些情况下，可能会需要从远端加载一个Java类来执行。比如一个客户端Java程序可以通过网络从服务器端下载Java类来执行，从而可以实现自动更新 的机制。当代码逻辑需要更新的时候，只需要部署一个新的Java类到服务器端即可。一般的做法是通过自定义类加载器下载了类字节代码之后，定义出
  Class类的对象，再通过newInstance方法就可以创建出实例了。不过这种做法要求客户端和服务器端都具有某个接口的定义，从服务器端下载的是 这个接口的实现。这样的话才能在客户端进行所需的类型转换，并通过接口来使用这个对象实例。如果希望客户端和服务器端采用更加松散的契约的话，使用反射API就可以了。两者之间的契约只需要在方法的名称和参数这个级别就足够了。服务器端Java类并不需要实现特定的接口，可以是一般的Java类。&lt;br&gt;&amp;emsp;&amp;emsp;动态代理的使用场景就更加广泛了。需要使用AOP中的方法拦截功能的地方都可以用到动态代理。Spring框架的AOP实现默认也使用动态代理。不过JDK中的动态代理只支持对接口的代理，不能对一个普通的Java类提供代理。不过这种实现在大部分的时候已经够用了。&lt;br&gt;&amp;emsp;&amp;emsp;另外，java的JDBC加载数据库连接驱动时的Class.forName(Driver)也是用的反射。还有工厂模式中Factory类中用反射的话，就不需要再修改工厂类Factory了，非常方便。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是反射？&quot;&gt;&lt;a href=&quot;#什么是反射？&quot; class=&quot;headerlink&quot; title=&quot;什么是反射？&quot;&gt;&lt;/a&gt;什么是反射？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Java 反射机制主要提供了以下功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://xiaolin.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础拾遗——多线程</title>
    <link href="http://xiaolin.site/2016/05/29/java-thread/"/>
    <id>http://xiaolin.site/2016/05/29/java-thread/</id>
    <published>2016-05-29T01:42:47.000Z</published>
    <updated>2016-07-18T07:33:51.979Z</updated>
    
    <content type="html">&lt;h4 id=&quot;什么是线程？&quot;&gt;&lt;a href=&quot;#什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程？&quot;&gt;&lt;/a&gt;什么是线程？&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;简单的说进程就是在某种程度上相互隔离的、独立运行的程序，而线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，是CPU调度的基本单位，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。&lt;br&gt;&amp;emsp;&amp;emsp;进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，但你必须小心，确保它们不会妨碍同一进程里的其它线程。&lt;/p&gt;
&lt;h4 id=&quot;为什么使用线程？&quot;&gt;
  &lt;a href=&quot;#为什么使用线程？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用线程？&quot;&gt;&lt;/a&gt;为什么使用线程？&lt;/h4&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;使 UI 响应更快&lt;/strong&gt;&lt;br&gt;当需要完成一些耗时的操作时，把这些工作交给另一个线程去完成，而UI线程只关注UI事件，这样就不会使得程序看来似乎停滞了，让用户感到蒙圈。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;利用多处理器系统&lt;/strong&gt;&lt;br&gt;如果某个程序只有一个活动的线程，它一次只能在一个处理器上运行。如果某个程序有多个活动线程，那么可以同时调度多个线程。在精心设计的程序中，使用多个线程可以提高程序吞吐量和性能。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;异步或后台处理&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;h4 id=&quot;无处不在的线程&quot;&gt;&lt;a href=&quot;#无处不在的线程&quot; class=&quot;headerlink&quot; title=&quot;无处不在的线程&quot;&gt;&lt;/a&gt;无处不在的线程&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;每个 Java 程序都至少有一个线程 ― 主线程。当一个 Java 程序启动时，JVM 会创建主线程，并在该线程中调用程序的 main() 方法。&lt;br&gt;&lt;strong&gt;TimerTask 工具&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;JDK 1.3 中，引入了TimerTask 工具。这个便利的工具让你可以稍后在某个时间执行任务（例如从现在起十秒后运行一次任务），或者定期执行任务（例如每隔十秒运行任务）。&lt;br&gt;TimerTask 线程被标记成守护程序线程，这样它就不会阻止程序退出。&lt;br&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Timer timer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Timer();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; CalculatePrimes calculator = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CalculatePrimes();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;calculator.start();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;timer.schedule(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TimerTask() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                calculator.finished = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;, TEN_SECONDS);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;&lt;/p&gt;
    &lt;h4 id=&quot;多线程的一些坑&quot;&gt;&lt;a href=&quot;#多线程的一些坑&quot; class=&quot;headerlink&quot; title=&quot;多线程的一些坑&quot;&gt;&lt;/a&gt;多线程的一些坑&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;当多个线程访问同一数据项（如静态字段、可全局访问对象的实例字段或共享集合）时，需要确保它们协调了对数据的访问，这样它们都可以看到数据的一致视图，而且相互不会干扰另一方的更改，也就是必须确保对该访问正确地进行了同步。对于简单变量，将变量声明成 volatile 也许就足够了，但在大多数情况下，需要使用同步。&lt;/li&gt;
      &lt;li&gt;如果要使用同步来保护对共享变量的访问，那么必须确保在程序中所有访问该变量的地方都使用同步。&lt;/li&gt;
      &lt;li&gt;过度使用线程可能会危及程序的性能及其可维护性;&lt;br&gt;CPU上下文的切换开销也很重要，如果你创建了太多的线程，CPU花费在上下文的切换的时间将多于执行程序的时间！尤其在单处理器系统中，使用多个线程不会使主要消耗 CPU 资源的程序运行得更快。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;线程的生命周期&quot;&gt;&lt;a href=&quot;#线程的生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程的生命周期&quot;&gt;&lt;/a&gt;线程的生命周期&lt;/h4&gt;
    &lt;p&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;新建状态:&lt;br&gt;有两种方式创建一个新的线程：一种是继承java.lang.Thread类并覆写其中的run()方法，另外一种则是在创建java.lang.Thread类的对象的时候，在构造函数中提供一个实现了java.lang.Runnable接口的类的对象。在得到了java.lang.Thread类的对象之后，通过调用其
        &lt;font color=&quot;red&quot;&gt;start()方法&lt;/font&gt;就可以启动这个线程的执行。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;figure class=&quot;highlight java&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建一个新的线程&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 你可以重写该方法，重要的是理解的run()可以调用其他方法，使用其他类，并声明变量，就像主线程一样&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NewThread&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Child Thread1&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建一个新的线程&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 继承类必须重写run()方法，该方法是新线程的入口点。它也必须调用start()方法才能执行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NewThread2&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Thread&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Child Thread2&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NewThread().run();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NewThread2().run();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;实现Runnable接口比继承Thread类所具有的优势：&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;适合多个相同的程序代码的线程去处理同一个资源;&lt;br&gt;可以避免java中的单继承的限制;&lt;br&gt;增加程序的健壮性，代码可以被多个线程共享，代码和数据独立;&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;就绪状态:&lt;br&gt;当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。&lt;/li&gt;
      &lt;li&gt;运行状态:&lt;br&gt;如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。&lt;/li&gt;
      &lt;li&gt;阻塞状态:&lt;br&gt;如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。&lt;/li&gt;
      &lt;li&gt;死亡状态:&lt;br&gt;一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;线程的优先级&quot;&gt;&lt;a href=&quot;#线程的优先级&quot; class=&quot;headerlink&quot; title=&quot;线程的优先级&quot;&gt;&lt;/a&gt;线程的优先级&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;Java线程的优先级是一个整数，其取值范围是1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。&lt;/li&gt;
      &lt;li&gt;默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。&lt;/li&gt;
      &lt;li&gt;具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。只能将优先级作为一种很粗略的工具使用。最后的控制可以通过明智地使用 yield() 函数来完成。&lt;strong&gt;通常情况下，请不要依靠线程优先级来控制线程的状态。&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;Thread-方法&quot;&gt;&lt;a href=&quot;#Thread-方法&quot; class=&quot;headerlink&quot; title=&quot;Thread 方法&quot;&gt;&lt;/a&gt;Thread 方法&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;start()&lt;/strong&gt;&lt;br&gt;使该线程开始执行；Java 虚拟机调用该线程的 run 方法。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;run()&lt;/strong&gt;&lt;br&gt;如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。run 方法就相当于传统程序中的 main() 方法；线程会持续运行，直到 run() 返回为止，此时该线程便死了。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;setPriority(int priority)&lt;/strong&gt;&lt;br&gt;更改线程的优先级。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;setDaemon(boolean on)&lt;/strong&gt;&lt;br&gt;将该线程标记为守护线程或用户线程。&lt;br&gt;我们提到过当 Java 程序的所有线程都完成时，该程序就退出，但这并不完全正确。系统线程，如垃圾收集线程称作守护程序线程。Java 程序实际上是在它的所有非守护程序线程完成后退出的。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;join(long millisec)&lt;/strong&gt;&lt;br&gt;等待该线程终止的时间最长为 millis 毫秒。当调用 Thread.join() 时，调用线程将阻塞，直到目标线程完成为止。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;interrupt()&lt;/strong&gt;&lt;br&gt;中断线程。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;boolean isAlive()&lt;/strong&gt;&lt;br&gt;测试线程是否处于活动状态。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;yield()&lt;/strong&gt;&lt;br&gt;暂停当前正在执行的线程对象，将当前的线程从处理器中移出到准备就绪队列中，并执行其他线程。当较高优先级的线程调用 Thread.yield() 时，较低优先级的线程就不会运行。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;sleep(long millisec)&lt;/strong&gt;&lt;br&gt;在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;boolean holdsLock(Object x)&lt;/strong&gt;&lt;br&gt;当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Thread currentThread()&lt;/strong&gt;&lt;br&gt;返回对当前正在执行的线程对象的引用。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;font color=&quot;red&quot;&gt;stop()、suspend() 和 resume() 函数已不提倡使用。&lt;/font&gt;
    &lt;h4 id=&quot;Java线程的同步&quot;&gt;&lt;a href=&quot;#Java线程的同步&quot; class=&quot;headerlink&quot; title=&quot;Java线程的同步&quot;&gt;&lt;/a&gt;Java线程的同步&lt;/h4&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;要跨线程维护数据的一致性，如要在几个线程之间共享非 final 变量，就必须使用 synchronized（或 volatile）以确保一个线程可以看见另一个线程做的更改。&lt;br&gt;&amp;emsp;&amp;emsp;Synchronized 有两个重要含义：它确保了一次只有一个线程可以执行代码的受保护部分，而且它确保了一个线程更改的数据对于其它线程是可见的（更改的可见性）。&lt;br&gt;&amp;emsp;&amp;emsp;Volatile 比同步更简单，只适合于控制对基本变量（整数、布尔变量等）的单个实例的访问。当一个变量被声明成
      volatile，任何对该变量的写操作都会绕过高速缓存，直接写入主内存，而任何对该变量的读取也都绕过高速缓存，直接取自主内存。这表示所有线程在任何时候看到的 volatile 变量值都相同。&lt;/p&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;采用同步的话，可以使用同步代码块和同步方法两种来完成。&lt;br&gt;创建 synchronized 块的最简单方法是将方法声明成 synchronized。这表示在进入方法主体之前，调用者必须获得锁：&lt;br&gt;&lt;/p&gt;
    &lt;figure class=&quot;highlight java&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setXY&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;&lt;/p&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;对于普通的 synchronized方法，这个锁是一个对象，将针对它调用方法。对于静态 synchronized 方法，这个锁是与 Class 对象相关的监控器，在该对象中声明了方法。&lt;br&gt;&amp;emsp;&amp;emsp;synchronized 块的语法比 synchronized 方法稍微复杂一点，因为还需要显式地指定锁要保护哪个块：&lt;br&gt;&lt;/p&gt;
    &lt;figure class=&quot;highlight java&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setXY&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;&lt;/p&gt;
    &lt;p&gt;使用 this 引用作为锁很常见，但这并不是必需的。这表示该代码块将与这个类中的 synchronized 方法使用同一个锁。&lt;/p&gt;
    &lt;h4 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h4&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;只要你拥有多个进程，而且它们要争用对&lt;strong&gt;多个锁&lt;/strong&gt;的独占访问，那么就有可能发生死锁。如果有一组进程或线程，其中每个都在等待一个只有其它进程或线程才可以执行的操作，那么就称它们被&lt;strong&gt;死锁&lt;/strong&gt;了。&lt;br&gt;&amp;emsp;&amp;emsp;假设有两个线程，分别代表两个饥饿的人，他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁：共享刀和共享叉的锁。假如线程 “A” 获得了刀，而线程 “B” 获得了叉。线程 A 就会进入阻塞状态来等待获得叉，而线程
      B 则阻塞来等待 A 所拥有的刀。这两个线程永远都不会获得第二个锁，或者释放第一个锁。它们只会永远等待下去。&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;死锁的应对策略&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;让所有的线程按照同样的顺序获得一组锁。这种方法消除了 A 和 B 的拥有者分别等待对方的资源的问题;&lt;/li&gt;
      &lt;li&gt;将多个锁组成一组并放到同一个锁下。前面死锁的例子中，可以创建一个银器对象的锁。于是在获得刀或叉之前都必须获得这个银器的锁;&lt;/li&gt;
      &lt;li&gt;将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得银器对象的锁时，就可以通过检查变量来判断是否整个银器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;&lt;strong&gt;同步代码准则&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;当编写 synchronized 块时，有几个简单的准则可以遵循，这些准则在避免死锁和性能危险的风险方面大有帮助：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;使代码块保持简短&lt;/strong&gt;。Synchronized 块应该简短 ― 在保证相关数据操作的完整性的同时，尽量简短。把不随线程变化的预处理和后处理移出synchronized 块。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;不要阻塞&lt;/strong&gt;。 不要在 synchronized 块或方法中调用可能引起阻塞的方法，如 InputStream.read()。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;在持有锁的时候，不要对其它对象调用方法&lt;/strong&gt;。这听起来可能有些极端，但它消除了最常见的死锁源头。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;线程间通信&quot;&gt;&lt;a href=&quot;#线程间通信&quot; class=&quot;headerlink&quot; title=&quot;线程间通信&quot;&gt;&lt;/a&gt;线程间通信&lt;/h4&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;除了使用轮询（它可能消耗大量 CPU 资源，而且具有计时不精确的特征），Object 类还包括一些方法，可以让线程相互通知事件的发生。&lt;br&gt;&amp;emsp;&amp;emsp;Object 类定义了 wait()、notify() 和 notifyAll() 方法。要执行这些方法，必须拥有相关对象的锁。&lt;br&gt;&amp;emsp;&amp;emsp;Wait() 会让调用线程休眠，直到用 Thread.interrupt() 中断它、过了指定的时间、或者另一个线程用 notify() 或 notifyAll()
      唤醒它。&lt;br&gt;&amp;emsp;&amp;emsp;当对某个对象调用 notify() 时，如果有任何线程正在通过 wait() 等待该对象，那么就会唤醒其中一个线程。当对某个对象调用notifyAll() 时，会唤醒所有正在等待该对象的线程。&lt;br&gt;&amp;emsp;&amp;emsp;使用 notify() 来代替notifyAll() 是有风险的。除非你确实知道正在做什么，否则就使用 notifyAll()。&lt;/p&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;其实与其使用 wait() 和 notify() 来编写自己的调度程序、线程池、队列和锁，倒不如使用 JDK1.5中引入的util.concurrent 包，这是一个被广泛使用的开放源码工具箱，里面都是有用的并发性实用程序。&lt;/p&gt;
    &lt;h4 id=&quot;线程组与线程池&quot;&gt;&lt;a href=&quot;#线程组与线程池&quot; class=&quot;headerlink&quot; title=&quot;线程组与线程池&quot;&gt;&lt;/a&gt;线程组与线程池&lt;/h4&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;线程是被个别创建的，但可以将它们归类到 线程组中，以便于调试和监视。只能在创建线程的同时将它与一个线程组相关联。在使用大量线程的程序中，使用线程组组织线程可能很有帮助。可以将它们看作是计算机上的目录和文件结构。&lt;br&gt;&amp;emsp;&amp;emsp;在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资源”技术产生的原因。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是线程？&quot;&gt;&lt;a href=&quot;#什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程？&quot;&gt;&lt;/a&gt;什么是线程？&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;简单的说进程就是在某种程度上相互隔离的、独立运行的程序，而线程也称作轻量级进程。就
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="http://xiaolin.site/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础拾遗——IO流</title>
    <link href="http://xiaolin.site/2016/05/28/java-basic2/"/>
    <id>http://xiaolin.site/2016/05/28/java-basic2/</id>
    <published>2016-05-28T02:54:53.000Z</published>
    <updated>2016-07-18T07:33:51.955Z</updated>
    
    <content type="html">&lt;h4 id=&quot;流&quot;&gt;&lt;a href=&quot;#流&quot; class=&quot;headerlink&quot; title=&quot;流&quot;&gt;&lt;/a&gt;流&lt;/h4&gt;
&lt;p&gt;简单的来说，流是一个连续的字节的序列。输入流是用来读取这个序列，而输出流则构建这个序列。&lt;br&gt;InputStream和OutputStream所操纵的基本单元就是字节。每次读取和写入单个字节或是字节数组。如果从字节的层次来处理数据类型的话，操作会非常繁琐。可以用更易使用的流实现来包装基本的字节流。如果想读取或输出Java的基本数据类型，可以使用DataInputStream和DataOutputStream。它们所提供的类似readFloat和writeDouble这样的方法，会让处理基本数据类型变得很简单。如果希望读取或写入的是Java中的对象的话，可以使用ObjectInputStream和ObjectOutputStream。它们与对象的序列化机制一起，可以实现Java对象状态的持久化和数据传递。基本流所提供的对于输入和输出的控制比较弱。InputStream只提供了顺序读取、跳过部分字节和标记/重置的支持，而OutputStream则只能顺序输出。&lt;/p&gt;
&lt;p&gt;Java流操作有关的类或接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/384764/2012031413371190.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java流类图结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/384764/2012031413373126.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO流的分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根据处理数据类型的不同分为：字符流和字节流&lt;/li&gt;
  &lt;li&gt;根据数据流向不同分为：输入流和输出流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符流和字节流&lt;/strong&gt;&lt;br&gt;字符流的由来：&lt;br&gt;因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表;&lt;/p&gt;
&lt;p&gt;字节流和字符流的区别：&lt;br&gt;读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。&lt;br&gt;处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。&lt;/p&gt;
&lt;p&gt;结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。&lt;/p&gt;
&lt;h4 id=&quot;流的使用&quot;&gt;&lt;a href=&quot;#流的使用&quot; class=&quot;headerlink&quot; title=&quot;流的使用&quot;&gt;&lt;/a&gt;流的使用&lt;/h4&gt;
&lt;p&gt;每个打开的流都需要被正确的关闭以释放资源。所遵循的原则是谁打开谁释放。如果一个流只在某个方法体内使用，则通过finally语句或是JDK 7中的try-with-resources语句来确保在方法返回之前，流被正确的关闭。如果一个方法只是作为流的使用者，就不需要考虑流的关闭问题。典型的情况是在servlet实现中并不需要关闭HttpServletResponse中的输出流。如果你的代码需要负责打开一个流，并且需要在不同的对象之间进行传递的话，可以考虑使用Execute Around Method模式。如下面的代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(StreamUser user)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    InputStream input = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        input = open();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        user.use(input);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(IOException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        user.onError(e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (input != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                input.close();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                user.onError(e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;如上述代码中所看到的一样，由专门的类负责流的打开和关闭。流的使用者StreamUser并不需要关心资源释放的细节，只需要对流进行操作即可。&lt;/p&gt;
  &lt;h4 id=&quot;缓冲区&quot;&gt;&lt;a href=&quot;#缓冲区&quot; class=&quot;headerlink&quot; title=&quot;缓冲区&quot;&gt;&lt;/a&gt;缓冲区&lt;/h4&gt;
  &lt;p&gt;Java I/O默认是不缓冲流的&lt;br&gt;应用程序每次IO都要和设备进行通信，效率很低，因此缓冲区为了提高效率，当写入设备时，先写入缓冲区，每次等到缓冲区满了时，就将数据一次性整体写入设备，避免了每一个数据都和IO进行一次交互;&lt;br&gt;带关键字buffer的流&lt;/p&gt;
  &lt;p&gt;传统的缓冲区的实现是使用数组来完成。比如经典的从InputStream到OutputStream的复制的实现，就是使用一个字节数组作为中间的缓冲区。NIO中引入的Buffer类及其子类，可以很方便的用来创建各种基本数据类型的缓冲区。相对于数组而言，Buffer类及其子类提供了更加丰富的方法来对其中的数据进行操作。&lt;/p&gt;
  &lt;p&gt;在Buffer上进行的元素添加和删除操作，都围绕3个属性position、limit和capacity展开，分别表示Buffer当前的读写位置、可用的读写范围和容量限制。容量限制是在创建的时候指定的。Buffer提供的get/put方法都有相对和绝对两种形式。相对读写时的位置是相对于position的值，而绝对读写则需要指定起始的序号。在使用Buffer的常见错误就是在读写操作时没有考虑到这3个元素的值，因为大多数时候都是使用的是相对读写操作，而position的值可能早就发生了变化。一些应该注意的地方包括：将数据读入缓冲区之前，需要调用clear方法；将缓冲区中的数据输出之前，需要调用flip方法。&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ByteBuffer buffer = ByteBuffer.allocate(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CharBuffer charBuffer = buffer.asCharBuffer();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String content = charBuffer.put(&lt;span class=&quot;string&quot;&gt;&quot;Hello &quot;&lt;/span&gt;).put(&lt;span class=&quot;string&quot;&gt;&quot;World&quot;&lt;/span&gt;).flip().toString();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(content);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;上面的代码展示了Buffer子类的使用。首先可以在已有的ByteBuffer上面创建出其它数据类型的缓冲区视图，其次Buffer子类的很多方法是可以级联的，最后是要注意flip方法的使用。&lt;/p&gt;
    &lt;h4 id=&quot;字符与编码&quot;&gt;&lt;a href=&quot;#字符与编码&quot; class=&quot;headerlink&quot; title=&quot;字符与编码&quot;&gt;&lt;/a&gt;字符与编码&lt;/h4&gt;
    &lt;p&gt;NIO中的java.nio.charset包提供了与字符集相关的类，可以用来进行编码和解码。其中的CharsetEncoder和CharsetDecoder允许对编码和解码过程进行精细的控制，如处理非法的输入以及字符集中无法识别的字符等。通过这两个类可以实现字符内容的过滤。比如应用程序在设计的时候就只支持某种字符集，如果用户输入了其它字符集中的内容，在界面显示的时候就是乱码。对于这种情况，可以在解码的时候忽略掉无法识别的内容。&lt;/p&gt;
    &lt;figure class=&quot;highlight java&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String input = &lt;span class=&quot;string&quot;&gt;&quot;你123好&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Charset charset = Charset.forName(&lt;span class=&quot;string&quot;&gt;&quot;ISO-8859-1&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CharsetEncoder encoder = charset.newEncoder();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;encoder.onUnmappableCharacter(CodingErrorAction.IGNORE);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CharsetDecoder decoder = charset.newDecoder();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CharBuffer buffer = CharBuffer.allocate(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;buffer.put(input);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;buffer.flip();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ByteBuffer byteBuffer = encoder.encode(buffer);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CharBuffer cbuf = decoder.decode(byteBuffer);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(cbuf);  &lt;span class=&quot;comment&quot;&gt;//输出123&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (CharacterCodingException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    e.printStackTrace();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;在创建Reader/Writer子类实例的时候，总是应该使用两个参数的构造方法，即显式指定使用的字符集或编码解码器。如果不显式指定，使用的是JVM的默认字符集，有可能在其它平台上产生错误。&lt;/p&gt;
    &lt;h4 id=&quot;Java中的目录&quot;&gt;&lt;a href=&quot;#Java中的目录&quot; class=&quot;headerlink&quot; title=&quot;Java中的目录&quot;&gt;&lt;/a&gt;Java中的目录&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;创建目录：&lt;/strong&gt;&lt;br&gt;File类中有两个方法可以用来创建文件夹：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。&lt;/li&gt;
      &lt;li&gt;mkdirs()方法创建一个文件夹和它的所有父文件夹。
        &lt;figure class=&quot;highlight java&quot;&gt;
          &lt;table&gt;
            &lt;tr&gt;
              &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
              &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String dirname = &lt;span class=&quot;string&quot;&gt;&quot;/tmp/user/java/bin&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;File d = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(dirname);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 现在创建目录&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;d.mkdirs();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/table&gt;
        &lt;/figure&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;&lt;strong&gt;读取目录&lt;/strong&gt;&lt;br&gt;一个目录其实就是一个File对象，它包含其他文件和文件夹。&lt;br&gt;如果创建一个File对象并且它是一个目录，那么调用isDirectory( )方法会返回true。&lt;br&gt;可以通过调用该对象上的list()方法，来提取它包含的文件和文件夹的列表。&lt;br&gt;&lt;/p&gt;
    &lt;figure class=&quot;highlight java&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String dirname = &lt;span class=&quot;string&quot;&gt;&quot;/tmp&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      File f1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(dirname);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (f1.isDirectory()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         System.out.println( &lt;span class=&quot;string&quot;&gt;&quot;Directory of &quot;&lt;/span&gt; + dirname);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         String s[] = f1.list();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; s.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            File f = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(dirname + &lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt; + s[i]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (f.isDirectory()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;               System.out.println(s[i] + &lt;span class=&quot;string&quot;&gt;&quot; is a directory&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;               System.out.println(s[i] + &lt;span class=&quot;string&quot;&gt;&quot; is a file&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         System.out.println(dirname + &lt;span class=&quot;string&quot;&gt;&quot; is not a directory&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;&lt;/p&gt;
    &lt;h4 id=&quot;通道&quot;&gt;&lt;a href=&quot;#通道&quot; class=&quot;headerlink&quot; title=&quot;通道&quot;&gt;&lt;/a&gt;通道&lt;/h4&gt;
    &lt;p&gt;通道作为NIO中的核心概念，在设计上比之前的流要好不少。通道相关的很多实现都是接口而不是抽象类。通道本身的抽象层次也更加合理。通道表示的是对支持I/O操作的实体的一个连接。一旦通道被打开之后，就可以执行读取和写入操作，而不需要像流那样由输入流或输出流来分别进行处理。与流相比，通道的操作使用的是Buffer而不是数组，使用更加方便灵活。通道的引入提升了I/O操作的灵活性和性能，主要体现在文件操作和网络操作上。&lt;/p&gt;
    &lt;h4 id=&quot;文件通道&quot;&gt;&lt;a href=&quot;#文件通道&quot; class=&quot;headerlink&quot; title=&quot;文件通道&quot;&gt;&lt;/a&gt;文件通道&lt;/h4&gt;
    &lt;p&gt;对文件操作方面，文件通道FileChannel提供了与其它通道之间高效传输数据的能力，比传统的基于流和字节数组作为缓冲区的做法，要来得简单和快速。比如下面的把一个网页的内容保存到本地文件的实现。&lt;br&gt;&lt;/p&gt;
    &lt;figure class=&quot;highlight java&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;FileOutputStream output = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileOutputStream(&lt;span class=&quot;string&quot;&gt;&quot;baidu.txt&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;FileChannel channel = output.getChannel();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;URL url = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;string&quot;&gt;&quot;http://www.baidu.com&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;InputStream input = url.openStream();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ReadableByteChannel readChannel = Channels.newChannel(input);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;channel.transferFrom(readChannel, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, Integer.MAX_VALUE);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;&lt;/p&gt;
    &lt;p&gt;文件通道的另外一个功能是对文件的部分片段进行加锁。当在一个文件上的某个片段加上了排它锁之后，其它进程必须等待这个锁释放之后，才能访问该文件的这个片段。文件通道上的锁是由JVM所持有的，因此适合于与其它应用程序协同时使用。比如当多个应用程序共享某个配置文件的时候，如果Java程序需要更新此文件，则可以首先获取该文件上的一个排它锁，接着进行更新操作，再释放锁即可。这样可以保证文件更新过程中不会受到其它程序的影响。&lt;/p&gt;
    &lt;p&gt;另外一个在性能方面有很大提升的功能是内存映射文件的支持。通过FileChannel的map方法可以创建出一个MappedByteBuffer对象，对这个缓冲区的操作都会直接反映到文件内容上。这点尤其适合对大文件进行读写操作。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;流&quot;&gt;&lt;a href=&quot;#流&quot; class=&quot;headerlink&quot; title=&quot;流&quot;&gt;&lt;/a&gt;流&lt;/h4&gt;
&lt;p&gt;简单的来说，流是一个连续的字节的序列。输入流是用来读取这个序列，而输出流则构建这个序列。&lt;br&gt;InputStream和OutputStream所
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://xiaolin.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础拾遗——String、日期、集合类</title>
    <link href="http://xiaolin.site/2016/05/26/java_basic1/"/>
    <id>http://xiaolin.site/2016/05/26/java_basic1/</id>
    <published>2016-05-26T13:40:42.000Z</published>
    <updated>2016-07-18T07:33:51.984Z</updated>
    
    <content type="html">&lt;h4 id=&quot;String-StringBuffer与StringBuilder的区别&quot;&gt;&lt;a href=&quot;#String-StringBuffer与StringBuilder的区别&quot; class=&quot;headerlink&quot; title=&quot;String,StringBuffer与StringBuilder的区别?&quot;&gt;&lt;/a&gt;String,StringBuffer与StringBuilder的区别?&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;String 字符串常量&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;StringBuffer 字符串变量（线程安全）&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;StringBuilder 字符串变量（非线程安全）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以为性能考虑经常改变内容的字符串最好不要用 String。&lt;br&gt;&amp;emsp;&amp;emsp;而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用
  StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String S1 = &lt;span class=&quot;string&quot;&gt;&quot;This is only a&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot; simple&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot; test&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;StringBuffer Sb = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuilder(&lt;span class=&quot;string&quot;&gt;&quot;This is only a&quot;&lt;/span&gt;).append(&lt;span class=&quot;string&quot;&gt;&quot; simple&quot;&lt;/span&gt;).append(&lt;span class=&quot;string&quot;&gt;&quot; test&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个String S1 = “This is only a” + “ simple” + “ test”;其实就是：String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String S2 = “This is only a”;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String S3 = “ simple”;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String S4 = “ test”;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String S1 = S2 +S3 + S4;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;性能上比较：&lt;/p&gt;
  &lt;font color=&quot;red&quot;&gt;在大部分情况下 StringBuffer &amp;gt; String&lt;br&gt;在大部分情况下 StringBuilder &amp;gt; StringBuffer&lt;/font&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。&lt;/p&gt;
  &lt;h4 id=&quot;Java日期时间使用总结&quot;&gt;&lt;a href=&quot;#Java日期时间使用总结&quot; class=&quot;headerlink&quot; title=&quot;Java日期时间使用总结&quot;&gt;&lt;/a&gt;Java日期时间使用总结&lt;/h4&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;85&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;86&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;87&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;88&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;89&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;90&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;91&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;92&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;93&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;94&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;95&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;96&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;97&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;98&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;99&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;100&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;101&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;102&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;103&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;104&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;105&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;106&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;107&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;108&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;109&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;110&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;111&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;112&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;113&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;114&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;115&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;116&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;117&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;118&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;119&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;120&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;121&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;122&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;123&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;124&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;125&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;126&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;127&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;128&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;129&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;130&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;131&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;132&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;133&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;134&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;135&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;136&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;137&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.text.DateFormat;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.text.ParseException;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.text.SimpleDateFormat;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Calendar;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Date;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.GregorianCalendar;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Locale;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.TimeZone;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestDate&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 1、类 java.util.Date&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Date 表示特定的瞬间，精确到毫秒。从 JDK 1.1 开始，应该使用 Calendar 类实现日期和时间字段之间转换，使用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// DateFormat&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 类来格式化和分析日期字符串。Date 中的把日期解释为年、月、日、小时、分钟和秒值的方法已废弃。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Date(long date)分配 Date 对象并初始化此对象，参数为毫秒数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Date date = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Date();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 下面仅仅列出没有过时的方法：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// boolean after(Date when)测试此日期是否在指定日期之后&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// int compareTo(Date anotherDate) 比较两个日期的顺序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// boolean equals(Object obj) 比较两个日期的相等性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	* String toString() ----Fri May 27 17:44:46 CST 2016 把此 Date 对象转换为以下形式的&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	* String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	* Wed, Thu, Fri, Sat)。 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	* mon 是月份 (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)。 dd 是一月中的某一天（01 至 31），显示为两位十进制数。 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	* hh 是一天中的小时（00 至 23），显示为两位十进制数。 mm 是小时中的分钟（00 至 59），显示为两位十进制数。 ss 是分钟中的秒数（00 至 61），显示为两位十进制数。 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	* zzz 是时区（并可以反映夏令时）。标准时区缩写包括方法 parse 识别的时区缩写。如果不提供时区信息，则 zzz 为空，即根本不包括任何字符。 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	* yyyy 是年份，显示为 4 位十进制数。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;现在的日期是 = &quot;&lt;/span&gt; + date.toString());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;自1970年1月1日0时0分0秒开始至今所经历的毫秒数 = &quot;&lt;/span&gt; + date.getTime());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 2、类 java.text.DateFormat&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 它以与语言无关的方式格式化并分析日期或时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 要格式化一个当前语言环境下的日期，可使用某个静态工厂方法：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// DateFormat df = DateFormat.getDateInstance();&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// for (int i = 0; i &amp;lt; myDate.length; ++i) &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// output.println(df.format(myDate[i]) + &quot;; &quot;);&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// &amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 要格式化不同语言环境的日期，可在 getDateInstance() 的调用中指定它。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// DateFormat df = DateFormat.getDateInstance(DateFormat.LONG,&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Locale.FRANCE);&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// SHORT 完全为数字，如 12.13.52 或 3:30pm&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// MEDIUM 较长，如 Jan 12, 1952&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// LONG 更长，如 January 12, 1952 或 3:30:32pm&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// FULL 是完全指定，如 Tuesday, April 12, 1952 AD 或 3:30:42pm PST&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);&lt;span class=&quot;comment&quot;&gt;// 默认是MEDIUM&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(df.format(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Date()));&lt;span class=&quot;comment&quot;&gt;// LONG:2016年5月27日&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;											&lt;span class=&quot;comment&quot;&gt;// FULL:2016年5月27日 星期五&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;											&lt;span class=&quot;comment&quot;&gt;// MEDIUM：2016-5-27&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;											&lt;span class=&quot;comment&quot;&gt;// SHORT:16-5-27&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 3、java.text.SimpleDateFormat（DateFormat的直接子类）的使用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 日期和时间模式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 在日期和时间模式字符串中，未加引号的字母 &#39;A&#39; 到 &#39;Z&#39; 和 &#39;a&#39; 到 &#39;z&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 被解释为模式字母，用来表示日期或时间字符串元素。文本可以使用单引号 (&#39;) 引起来，以免进行解释。&quot;&#39;&#39;&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 表示单引号。所有其他字符均不解释；只是在格式化时将它们简单复制到输出字符串，或者在分析时与输入字符串进行匹配。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// y--&amp;gt;Year&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// M--&amp;gt;Month&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// w--&amp;gt;年中的周数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// W--&amp;gt;月份中的周数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// D--&amp;gt;年中的天数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// d--&amp;gt;月份中的天数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// F--&amp;gt;月份中的星期&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// E--&amp;gt;星期中的天数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// a--&amp;gt;Am/pm 标记&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// H--&amp;gt;一天中的小时数（0-23）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// K--&amp;gt;am/pm 中的小时数（0-11）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// m--&amp;gt;小时中的分钟数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// s--&amp;gt;分钟中的秒数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// S--&amp;gt;毫秒数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 创建不同的日期格式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	DateFormat df1 = DateFormat.getInstance();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	DateFormat df2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;string&quot;&gt;&quot;yyyy-MM-dd hh:mm:ss EE&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	DateFormat df3 = DateFormat.getDateInstance(DateFormat.FULL, Locale.CHINA); &lt;span class=&quot;comment&quot;&gt;// 产生一个指定国家指定长度的日期格式，长度不同，显示的日期完整性也不同&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	DateFormat df4 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;string&quot;&gt;&quot;yyyy年MM月dd日 hh时mm分ss秒 EE&quot;&lt;/span&gt;, Locale.CHINA);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	DateFormat df5 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;string&quot;&gt;&quot;yyyy-MM-dd hh:mm:ss EEEEEE&quot;&lt;/span&gt;, Locale.US);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	DateFormat df6 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;string&quot;&gt;&quot;yyyy-MM-dd&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 将日期按照不同格式进行输出&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;-------将日期按照不同格式进行输出------&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;按照Java默认的日期格式，默认的区域                      : &quot;&lt;/span&gt; + df1.format(date));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;按照指定格式 yyyy-MM-dd hh:mm:ss EE ，系统默认区域      :&quot;&lt;/span&gt; + df2.format(date));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;按照日期的FULL模式，区域设置为中文                      : &quot;&lt;/span&gt; + df3.format(date));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;按照指定格式 yyyy年MM月dd日 hh时mm分ss秒 EE ，区域为中文 : &quot;&lt;/span&gt; + df4.format(date));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;按照指定格式 yyyy-MM-dd hh:mm:ss EE ，区域为美国        : &quot;&lt;/span&gt; + df5.format(date));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;按照指定格式 yyyy-MM-dd ，系统默认区域                  : &quot;&lt;/span&gt; + df6.format(date));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 4、java.util.Calendar（抽象类）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 它为与一组日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Calendar中些陷阱，很容易掉下去：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 1、Calendar的星期是从周日开始的，常量值为0。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 2、Calendar的月份是从一月开始的，常量值为0。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 3、Calendar的每个月的第一天值为1。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 5、java.util.GregorianCalendar（Calendar的直接子类）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// GregorianCalendar 是 Calendar 的一个具体子类，提供了世界上大多数国家使用的标准日历系统。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//创建Calendar的方式 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     Calendar now1 = Calendar.getInstance(); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     Calendar now2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; GregorianCalendar(); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     Calendar now3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; GregorianCalendar(&lt;span class=&quot;number&quot;&gt;2007&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     Calendar now4 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; GregorianCalendar(&lt;span class=&quot;number&quot;&gt;2007&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;55&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//陷阱:Calendar的月份是0~11 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     Calendar now5 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; GregorianCalendar(&lt;span class=&quot;number&quot;&gt;2007&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;55&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     Calendar now6 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; GregorianCalendar(Locale.US); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     Calendar now7 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; GregorianCalendar(TimeZone.getTimeZone(&lt;span class=&quot;string&quot;&gt;&quot;GMT-8:00&quot;&lt;/span&gt;)); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//通过日期和毫秒数设置Calendar &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     now2.setTime(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Date()); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     System.out.println(now2); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     now2.setTimeInMillis(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Date().getTime()); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     System.out.println(now2); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//定义日期的中文输出格式,并输出日期 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     df = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;string&quot;&gt;&quot;yyyy年MM月dd日 hh时mm分ss秒 E&quot;&lt;/span&gt;, Locale.CHINA); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;获取日期中文格式化化输出：&quot;&lt;/span&gt; + df.format(now5.getTime())); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;--------通过Calendar获取日期中年月日等相关信息--------&quot;&lt;/span&gt;); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;获取年：&quot;&lt;/span&gt; + now5.get(Calendar.YEAR)); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;获取月(月份是从0开始的)：&quot;&lt;/span&gt; + now5.get(Calendar.MONTH)); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;获取日：&quot;&lt;/span&gt; + now5.get(Calendar.DAY_OF_MONTH)); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;获取时：&quot;&lt;/span&gt; + now5.get(Calendar.HOUR)); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;获取分：&quot;&lt;/span&gt; + now5.get(Calendar.MINUTE)); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;获取秒：&quot;&lt;/span&gt; + now5.get(Calendar.SECOND)); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;获取上午、下午：&quot;&lt;/span&gt; + now5.get(Calendar.AM_PM)); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;获取星期数值(星期是从周日开始的)：&quot;&lt;/span&gt; + now5.get(Calendar.DAY_OF_WEEK)); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;---------通用星期中文化转换---------&quot;&lt;/span&gt;); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    String dayOfWeek[] = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;日&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;一&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;二&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;三&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;四&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;五&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;六&quot;&lt;/span&gt;&amp;#125;; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;now5对象的星期是:&quot;&lt;/span&gt; + dayOfWeek[now5.get(Calendar.DAY_OF_WEEK)]); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;h4 id=&quot;Java常用集合类&quot;&gt;&lt;a href=&quot;#Java常用集合类&quot; class=&quot;headerlink&quot; title=&quot;Java常用集合类&quot;&gt;&lt;/a&gt;Java常用集合类&lt;/h4&gt;
  &lt;h5 id=&quot;Java集合类基本概念&quot;&gt;&lt;a href=&quot;#Java集合类基本概念&quot; class=&quot;headerlink&quot; title=&quot;Java集合类基本概念&quot;&gt;&lt;/a&gt;&lt;font size=&quot;3px&quot;&gt;&lt;strong&gt;Java集合类基本概念&lt;/strong&gt;&lt;/font&gt;&lt;/h5&gt;
  &lt;p&gt;Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;Collection&lt;br&gt;一组”对立”的元素，通常这些元素都服从某种规则&lt;br&gt;① List必须保持元素特定的顺序&lt;br&gt;② Set不能有重复元素&lt;br&gt;③ Queue保持一个队列(先进先出)的顺序&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;Map&lt;br&gt;一组成对的”键值对”对象&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  &lt;p&gt;Collection和Map的区别在于容器中每个位置保存的元素个数:&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;Collection 每个位置只能保存一个元素(对象)&lt;/li&gt;
    &lt;li&gt;Map保存的是”键值对”，就像一个小型数据库。我们可以通过”键”找到该键对应的”值”&lt;/li&gt;
  &lt;/ul&gt;
  &lt;h5 id=&quot;Java集合类架构层次关系&quot;&gt;&lt;a href=&quot;#Java集合类架构层次关系&quot; class=&quot;headerlink&quot; title=&quot;Java集合类架构层次关系&quot;&gt;&lt;/a&gt;&lt;font size=&quot;3px&quot;&gt;&lt;strong&gt;Java集合类架构层次关系&lt;/strong&gt;&lt;/font&gt;&lt;/h5&gt;
  &lt;p&gt;&lt;strong&gt;1. Interface Iterable&lt;/strong&gt;&lt;br&gt;迭代器接口，这是Collection类的父接口。实现这个Iterable接口的对象允许使用foreach进行遍历，也就是说，所有的Collection集合对象都具有”foreach可遍历性”。这个Iterable接口只有一个方法: iterator()。它返回一个代表当前集合对象的泛型
    &lt;t&gt;迭代器，用于之后的遍历操作&lt;br&gt;&lt;strong&gt;1.1 Collection&lt;/strong&gt;&lt;br&gt;Collection是最基本的集合接口，一个Collection代表一组Object的集合，这些Object被称作Collection的元素。Collection是一个接口，用以提供规范定义，不能被实例化使用&lt;br&gt;&lt;strong&gt;1) Set&lt;/strong&gt;&lt;br&gt;Set集合类似于一个罐子，”丢进”Set集合里的多个对象之间没有明显的顺序。Set继承自Collection接口，不能包含有重复元素(记住，这是整个Set类层次的共有属性)。&lt;br&gt;Set判断两个对象相同不是使用”==”运算符，而是根据equals方法。也就是说，我们在加入一个新元素的时候，如果这个新元素对象和Set中已有对象进行注意equals比较都返回false，则Set就会接受这个新元素对象，否则拒绝。因为Set的这个制约，在使用Set集合的时候，应该注意两点：&lt;br&gt;1)
      为Set集合里的元素的实现类实现一个有效的equals(Object)方法;&lt;br&gt;2) 对Set的构造函数，传入的Collection参数不能包含重复的元素;&lt;br&gt;&lt;strong&gt;1.1) HashSet&lt;/strong&gt;&lt;br&gt;HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的HashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。&lt;br&gt;值得注意的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等；&lt;br&gt;&lt;strong&gt;1.1.1) LinkedHashSet&lt;/strong&gt;&lt;br&gt;LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时(遍历)将有很好的性能(链表很适合进行遍历);&lt;/t&gt;
  &lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;1.2) SortedSet&lt;/strong&gt;&lt;br&gt;此接口主要用于排序操作，即实现此接口的子类都属于排序的子类；&lt;br&gt;&lt;strong&gt;1.2.1) TreeSet&lt;/strong&gt;&lt;br&gt;TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态；&lt;br&gt;&lt;strong&gt;1.3) EnumSet&lt;/strong&gt;&lt;br&gt;EnumSet是一个专门为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。EnumSet的集合元素也是有序的，它们以枚举值在Enum类内的定义顺序来决定集合元素的顺序；&lt;br&gt;&lt;strong&gt;2) List&lt;/strong&gt;&lt;br&gt;List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引；&lt;br&gt;&lt;strong&gt;2.1) ArrayList&lt;/strong&gt;&lt;br&gt;ArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。&lt;br&gt;&lt;strong&gt;2.2) Vector&lt;/strong&gt;&lt;br&gt;Vector和ArrayList在用法上几乎完全相同，但Vector是同步的，而ArrayList则是异步的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用ArrayList是一个很好的选择，这样可以避免由于同步带
    来的不必要的性能开销。&lt;br&gt;&lt;strong&gt;2.2.1) Stack&lt;/strong&gt;&lt;br&gt;Stack是Vector提供的一个子类，用于模拟”栈”这种数据结构(LIFO后进先出)&lt;br&gt;如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。&lt;br&gt;如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。&lt;br&gt;&lt;strong&gt;3) Queue&lt;/strong&gt;&lt;br&gt;Queue用于模拟”队列”这种数据结构(先进先出
    FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念；&lt;br&gt;&lt;strong&gt;3.1) PriorityQueue&lt;/strong&gt;&lt;br&gt;PriorityQueue并不是一个比较标准的队列实现，PriorityQueue保存队列元素的顺序并不是按照加入队列的顺序，而是按照队列元素的大小进行重新排序，这点从它的类名也可以看出来；&lt;br&gt;&lt;strong&gt;3.2) Deque&lt;/strong&gt;&lt;br&gt;Deque接口代表一个”双端队列”，双端队列可以同时从两端来添加、删除元素，因此Deque的实现类既可以当成队列使用、也可以当成栈使用；&lt;br&gt;&lt;strong&gt;3.2.1) ArrayDeque&lt;/strong&gt;&lt;br&gt;是一个基于数组的双端队列，和ArrayList类似，它们的底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出该数组的容量时，系统会在底层重新分配一个Object[]数组来存储集合元素；&lt;br&gt;&lt;strong&gt;1.2 Map&lt;/strong&gt;&lt;br&gt;Map用于保存具有”映射关系”的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value。key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。&lt;br&gt;关于Map，我们要从代码复用的角度去理解，java是先实现了Set，然后通过包装了一个所有value都为null的list就实现了Map集合（key不能重复）;&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;&lt;strong&gt;hashtable与hashmap&lt;/strong&gt;&lt;br&gt;1.Hashtable是基于陈旧的Dictionary类的；&lt;br&gt;2.Hashtable是同步的，而HashMap不是同步的；&lt;br&gt;3.只有HashMap可以让你将空值作为一个表的条目的key或value；&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;&lt;strong&gt;1) HashMap&lt;/strong&gt;&lt;br&gt;和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。并且类似于HashSet判断两个key是否相等的标准也是: 两个key通过equals()方法比较返回true、同时两个key的hashCode值也必须相等；&lt;br&gt;&lt;strong&gt;1.1) LinkedHashMap&lt;/strong&gt;&lt;br&gt;LinkedHashMap也使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致(注意和TreeMap对所有的key-value进行排序进行区分)&lt;br&gt;&lt;strong&gt;2) Hashtable&lt;/strong&gt;&lt;br&gt;是一个古老的Map实现类&lt;br&gt;&lt;strong&gt;2.1) Properties&lt;/strong&gt;&lt;br&gt;Properties对象在处理属性文件时特别方便(windows平台上的.ini文件)，Properties类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入到属性文件中，也可以把属性文件中的”属性名-属性值”加载到Map对象中；&lt;br&gt;&lt;strong&gt;3) SortedMap&lt;/strong&gt;&lt;br&gt;正如Set接口派生出SortedSet子接口，SortedSet接口有一个TreeSet实现类一样，Map接口也派生出一个SortedMap子接口，SortedMap接口也有一个TreeMap实现类；&lt;br&gt;
    &lt;img src=&quot;http://images.cnitblog.com/i/532548/201404/262238192165666.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
  &lt;h5 id=&quot;Java集合类的应用场景&quot;&gt;&lt;a href=&quot;#Java集合类的应用场景&quot; class=&quot;headerlink&quot; title=&quot;Java集合类的应用场景&quot;&gt;&lt;/a&gt;&lt;font size=&quot;3px&quot;&gt;&lt;strong&gt;Java集合类的应用场景&lt;/strong&gt;&lt;/font&gt;&lt;/h5&gt;
  &lt;p&gt;&lt;strong&gt;HashSet&lt;/strong&gt;&lt;/p&gt;
  &lt;p&gt;如果两个对象通过equals()方法比较返回true，但这两个对象的hashCode()方法返回不同的hashCode值时，这将导致HashSet会把这两个对象保存在Hash表的不同位置，从而使对象可以添加成功，这就与Set集合的规则有些出入了。所以，我们要明确的是: equals()决定是否可以加入HashSet、而hashCode()决定存放的位置，它们两者必须同时满足才能允许一个新元素加入HashSet&lt;br&gt;但是要注意的是: 如果两个对象的hashCode相同，但是它们的equlas返回值不同，HashSet会在这个位置用链式结构来保存多个对象。而HashSet访问集合元素时也是根据元素的HashCode值来快速定位的，这种链式结构会导致性能下降。&lt;/p&gt;
  &lt;p&gt;所以如果需要把某个类的对象保存到HashSet集合中，我们在重写这个类的equlas()方法和hashCode()方法时，应该尽量保证两个对象通过equals()方法比较返回true时，它们的hashCode()方法返回值也相等;&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;TreeSet&lt;/strong&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.*;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeSetTest&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        TreeSet nums = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TreeSet();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//向TreeSet中添加四个Integer对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        nums.add(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        nums.add(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        nums.add(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        nums.add(-&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出集合元素，看到集合元素已经处于排序状态&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(nums);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出集合里的第一个元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(nums.first());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出集合里的最后一个元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(nums.last());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//返回小于4的子集，不包含4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(nums.headSet(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//返回大于5的子集，如果Set中包含5，子集中还包含5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(nums.tailSet(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//返回大于等于-3，小于4的子集。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(nums.subSet(-&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;与HashSet集合采用hash算法来决定元素的存储位置不同，TreeSet采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方式: 自然排序、定制排序;TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排序，即自然排序。如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则程序会抛出异常。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;EnumSet&lt;/strong&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.*;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Season&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    SPRING,SUMMER,FALL,WINTER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;EnumSetTest&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        EnumSet es1 = EnumSet.allOf(Season.class);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出[SPRING,SUMMER,FALL,WINTER]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(es1);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//创建一个EnumSet空集合，指定其集合元素是Season类的枚举值。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        EnumSet es2 = EnumSet.noneOf(Season.class); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出[]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(es2); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//手动添加两个元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        es2.add(Season.WINTER);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        es2.add(Season.SPRING);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出[SPRING,WINTER]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(es2);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//以指定枚举值创建EnumSet集合&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        EnumSet es3 = EnumSet.of(Season.SUMMER , Season.WINTER); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出[SUMMER,WINTER]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(es3);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        EnumSet es4 = EnumSet.range(Season.SUMMER , Season.WINTER); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出[SUMMER,FALL,WINTER]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(es4);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//新创建的EnumSet集合的元素和es4集合的元素有相同类型，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//es5的集合元素 + es4集合元素 = Season枚举类的全部枚举值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        EnumSet es5 = EnumSet.complementOf(es4); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出[SPRING]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(es5);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;Set集合类使用总结：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;1) HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet;&lt;/p&gt;
    &lt;p&gt;2) 对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快;&lt;/p&gt;
    &lt;p&gt;3) EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素;&lt;/p&gt;
    &lt;p&gt;4) HashSet、TreeSet、EnumSet都是”线程不安全”的，通常可以通过Collections工具类的synchronizedSortedSet方法来”包装”该Set集合&lt;br&gt;SortedSet s = Collections.synchronizedSortedSet(new TreeSet(…));&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;&lt;strong&gt;List&lt;/strong&gt;&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.*;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListTest&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        List books = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//向books集合中添加三个元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;轻量级Java EE企业应用实战&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Java讲义&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Android讲义&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(books);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//将新字符串对象插入在第二个位置&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; , &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Ajax讲义&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; books.size() ; i++ )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            System.out.println(books.get(i));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//删除第三个元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.remove(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(books);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//判断指定元素在List集合中位置：输出1，表明位于第二位&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(books.indexOf(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Ajax讲义&quot;&lt;/span&gt;)));  &lt;span class=&quot;comment&quot;&gt;//①&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//将第二个元素替换成新的字符串对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.set(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;LittleHann&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(books);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//将books集合的第二个元素（包括）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//到第三个元素（不包括）截取成子集合&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(books.subList(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;Stack栈&lt;/strong&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.*;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LinkedListTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    LinkedList books = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedList();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将字符串元素加入队列的尾部(双端队列)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    books.offer(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Java讲义&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将一个字符串元素加入栈的顶部(双端队列)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    books.push(&lt;span class=&quot;string&quot;&gt;&quot;轻量级Java EE企业应用实战&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将字符串元素添加到队列的头(相当于栈的顶部)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    books.offerFirst(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Android讲义&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; books.size(); i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      System.out.println(books.get(i));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 疯狂Android讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 轻量级Java EE企业应用实战&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 疯狂Java讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 访问、并不删除栈顶的元素       疯狂Android讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(books.peekFirst());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 访问、并不删除队列的最后一个元素     疯狂Java讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(books.peekLast());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将栈顶的元素弹出&quot;栈&quot;    疯狂Android讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(books.pop());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 下面输出将看到队列中第一个元素被删除     [轻量级Java EE企业应用实战, 疯狂Java讲义]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(books);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 访问、并删除队列的最后一个元素     疯狂Java讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(books.pollLast());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 下面输出将看到队列中只剩下中间一个元素：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 轻量级Java EE企业应用实战&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(books);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;&lt;strong&gt;Queue&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;PriorityQueue&lt;/strong&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.PriorityQueue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PriorityQueueTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    PriorityQueue pq = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PriorityQueue();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 下面代码依次向pq中加入四个元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pq.offer(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pq.offer(-&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pq.offer(&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pq.offer(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 输出pq队列，并不是按元素的加入顺序排列，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 而是按元素的大小顺序排列，输出[-3, 0, 9, 6]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(pq);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 访问队列第一个元素，其实就是队列中最小的元素：-3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(pq.poll());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;PriorityQueue不允许插入null元素，它还需要对队列元素进行排序;&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;ArrayDeque&lt;/strong&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.*;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayDequeTest&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ArrayDeque stack = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayDeque();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//依次将三个元素push入&quot;栈&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        stack.push(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Java讲义&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        stack.push(&lt;span class=&quot;string&quot;&gt;&quot;轻量级Java EE企业应用实战&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        stack.push(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Android讲义&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(stack);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//访问第一个元素，但并不将其pop出&quot;栈&quot;，输出：疯狂Android讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(stack.peek());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//依然输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(stack);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//pop出第一个元素，输出：疯狂Android讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(stack.pop());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//输出：[疯狂Java讲义, 轻量级Java EE企业应用实战]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(stack);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;List集合类总结：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;ol&gt;
      &lt;li&gt;java提供的List就是一个”线性表接口”，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现&lt;/li&gt;
      &lt;li&gt;Queue代表了队列，Deque代表了双端队列(既可以作为队列使用、也可以作为栈使用)&lt;/li&gt;
      &lt;li&gt;因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。&lt;/li&gt;
      &lt;li&gt;内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能&lt;/li&gt;
      &lt;li&gt;进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Iterable接口&lt;/strong&gt;&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;1) boolean hasNext(): 是否还有下一个未遍历过的元素&lt;br&gt;2) Object next(): 返回集合里的下一个元素&lt;br&gt;3) void remove(): 删除集合里上一次next方法返回的元素&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;iterator实现遍历:&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.*;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IteratorTest&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//创建一个集合&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Collection books = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashSet();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;string&quot;&gt;&quot;轻量级Java EE企业应用实战&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Java讲义&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Android讲义&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//获取books集合对应的迭代器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Iterator it = books.iterator();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(it.hasNext())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//it.next()方法返回的数据类型是Object类型，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//需要强制类型转换&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            String book = (String)it.next();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            System.out.println(book);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (book.equals(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Java讲义&quot;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//从集合中删除上一次next方法返回的元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                it.remove();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//对book变量赋值，不会改变集合元素本身&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            book = &lt;span class=&quot;string&quot;&gt;&quot;测试字符串&quot;&lt;/span&gt;;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(books);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;foreach实现遍历:&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.*;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ForeachTest&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//创建一个集合&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Collection books = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashSet();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;轻量级Java EE企业应用实战&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Java讲义&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        books.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Android讲义&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Object obj : books)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//此处的book变量也不是集合元素本身&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            String book = (String)obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            System.out.println(book);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (book.equals(&lt;span class=&quot;string&quot;&gt;&quot;疯狂Android讲义&quot;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//下面代码会引发ConcurrentModificationException异常&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//books.remove(book);      &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(books);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;ListIterator接口在Iterator接口的继承上增加了如下方法:&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;1) boolean hasPrevious(): 返回该迭代器关联的集合是否还有上一个元素&lt;br&gt;2) Object previous(): 返回该迭代器的上一个元素(向前迭代)&lt;br&gt;3) void add(): 在指定位置插入一个元素&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;&lt;strong&gt;HashMap、Hashtable&lt;/strong&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Hashtable;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.count = count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 根据count的值来判断两个对象是否相等。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj == &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; obj.getClass() == A.class) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      A a = (A) obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.count == a.count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 根据count来计算hashCode值。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 重写equals()方法，B对象与任何对象通过equals()方法比较都相等&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashtableTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Hashtable ht = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Hashtable();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ht.put(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; A(&lt;span class=&quot;number&quot;&gt;60000&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;疯狂Java讲义&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ht.put(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; A(&lt;span class=&quot;number&quot;&gt;87563&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;轻量级Java EE企业应用实战&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ht.put(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; A(&lt;span class=&quot;number&quot;&gt;1232&lt;/span&gt;), &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; B());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(ht);&lt;span class=&quot;comment&quot;&gt;// &amp;#123;A@ea60=疯狂Java讲义, A@1560b=轻量级Java EE企业应用实战, A@4d0=B@97d01f&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 只要两个对象通过equals比较返回true，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Hashtable就认为它们是相等的value。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 由于Hashtable中有一个B对象，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 它与任何对象通过equals比较都相等，所以下面输出true。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(ht.containsValue(&lt;span class=&quot;string&quot;&gt;&quot;测试字符串&quot;&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 只要两个A对象的count相等，它们通过equals比较返回true，且hashCode相等&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Hashtable即认为它们是相同的key，所以下面输出true。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(ht.containsKey(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; A(&lt;span class=&quot;number&quot;&gt;87563&lt;/span&gt;))); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 下面语句可以删除最后一个key-value对&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ht.remove(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; A(&lt;span class=&quot;number&quot;&gt;1232&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 通过返回Hashtable的所有key组成的Set集合，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从而遍历Hashtable每个key-value对&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Object key : ht.keySet()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      System.out.print(key + &lt;span class=&quot;string&quot;&gt;&quot;----&amp;gt;&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      System.out.print(ht.get(key) + &lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// A@ea60----&amp;gt;疯狂Java讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// A@1560b----&amp;gt;轻量级Java EE企业应用实战&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;当使用自定义类作为HashMap、Hashtable的key时，如果重写该类的equals(Object obj)和hashCode()方法，则应该保证两个方法的判断标准一致–当两个key通过equals()方法比较返回true时，两个key的hashCode()的返回值也应该相同;&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;Properties（Hashtable）&lt;/strong&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.io.FileInputStream;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.io.FileOutputStream;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Properties;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PropertiesTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Properties props = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Properties();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 向Properties中增加属性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    props.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;username&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yeeku&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    props.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;password&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;123456&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(props);&lt;span class=&quot;comment&quot;&gt;// &amp;#123;password=123456, username=yeeku&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将Properties中的key-value对保存到a.ini文件中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    props.store(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileOutputStream(&lt;span class=&quot;string&quot;&gt;&quot;a.ini&quot;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;comment line&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 新建一个Properties对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Properties props2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Properties();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 向Properties中增加属性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    props2.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;gender&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;male&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将a.ini文件中的key-value对追加到props2中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    props2.load(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileInputStream(&lt;span class=&quot;string&quot;&gt;&quot;a.ini&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(props2);&lt;span class=&quot;comment&quot;&gt;// &amp;#123;password=123456, gender=male, username=yeeku&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;Properties还可以把key-value对以XML文件的形式保存起来，也可以从XML文件中加载key-value对&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;TreeMap&lt;/strong&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.TreeMap;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.count = count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;R[count:&quot;&lt;/span&gt; + count + &lt;span class=&quot;string&quot;&gt;&quot;]&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 根据count来判断两个对象是否相等。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; == obj)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; obj.getClass() == R.class) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      R r = (R) obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; r.count == &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 根据count属性值来判断两个对象的大小。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    R r = (R) obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; count &amp;gt; r.count ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : count &amp;lt; r.count ? -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeMapTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    TreeMap tm = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TreeMap();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    tm.put(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; R(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;轻量级Java EE企业应用实战&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    tm.put(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; R(-&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;疯狂Java讲义&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    tm.put(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; R(&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;疯狂Android讲义&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(tm);&lt;span class=&quot;comment&quot;&gt;//&amp;#123;R[count:-5]=疯狂Java讲义, R[count:3]=轻量级Java EE企业应用实战, R[count:9]=疯狂Android讲义&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回该TreeMap的第一个Entry对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(tm.firstEntry());&lt;span class=&quot;comment&quot;&gt;//R[count:-5]=疯狂Java讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回该TreeMap的最后一个key值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(tm.lastKey());&lt;span class=&quot;comment&quot;&gt;//R[count:9]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回该TreeMap的比new R(2)大的最小key值。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(tm.higherKey(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; R(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)));&lt;span class=&quot;comment&quot;&gt;//R[count:3]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回该TreeMap的比new R(2)小的最大的key-value对。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(tm.lowerEntry(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; R(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)));&lt;span class=&quot;comment&quot;&gt;//R[count:-5]=疯狂Java讲义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回该TreeMap的子TreeMap&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(tm.subMap(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; R(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; R(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)));&lt;span class=&quot;comment&quot;&gt;//&amp;#123;R[count:3]=轻量级Java EE企业应用实战&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;TreeMap中判断两个key相等的标准是:&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;1) 两个key通过compareTo()方法返回0&lt;br&gt;2) equals()放回true&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;再次强调一下:&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Set和Map的关系十分密切，java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;&lt;strong&gt;EnumMap&lt;/strong&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.*;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Season&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    SPRING,SUMMER,FALL,WINTER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;EnumMapTest&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//创建一个EnumMap对象，该EnumMap的所有key&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//必须是Season枚举类的枚举值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        EnumMap enumMap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; EnumMap(Season.class);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        enumMap.put(Season.SUMMER , &lt;span class=&quot;string&quot;&gt;&quot;夏日炎炎&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        enumMap.put(Season.SPRING , &lt;span class=&quot;string&quot;&gt;&quot;春暖花开&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(enumMap);&lt;span class=&quot;comment&quot;&gt;//&amp;#123;SPRING=春暖花开, SUMMER=夏日炎炎&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;与创建普通Map有所区别的是，创建EnumMap是必须指定一个枚举类，从而将该EnumMap和指定枚举类关联起来&lt;/p&gt;
  &lt;p&gt;Map集合类总结：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;1) HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制&lt;br&gt;2) TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对&lt;br&gt;3) 使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作&lt;/p&gt;
  &lt;/blockquote&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;String-StringBuffer与StringBuilder的区别&quot;&gt;&lt;a href=&quot;#String-StringBuffer与StringBuilder的区别&quot; class=&quot;headerlink&quot; title=&quot;String,StringBuffer与
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://xiaolin.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础拾遗——注解</title>
    <link href="http://xiaolin.site/2016/05/19/java-annotation/"/>
    <id>http://xiaolin.site/2016/05/19/java-annotation/</id>
    <published>2016-05-19T09:51:25.000Z</published>
    <updated>2016-07-18T07:33:51.944Z</updated>
    
    <content type="html">&lt;h4 id=&quot;注解的作用&quot;&gt;&lt;a href=&quot;#注解的作用&quot; class=&quot;headerlink&quot; title=&quot;注解的作用&quot;&gt;&lt;/a&gt;注解的作用&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在开发Java程序，尤其是Java EE应用的时候，总是免不了与各种配置文件打交道。以Java EE中典型的S(pring)S(truts)H(ibernate)架构来说，Spring、Struts和Hibernate这三个框架都有自己的XML格式的配置文件。这些配置文件需要与Java源代码保存同步，否则的话就可能出现错误。而且这些错误有可能到了运行时刻才被发现。把同一份信息保存在两个地方，总是个坏的主意。理想的情况是在一个地方维护这些信息就好了。其它部分所需的信息则通过自动的方式来生成。JDK
  5中引入了源代码中的注解（annotation）这一机制。注解使得Java源代码中不但可以包含功能性的实现代码，还可以添加元数据。&lt;/p&gt;
&lt;h4 id=&quot;使用注解&quot;&gt;&lt;a href=&quot;#使用注解&quot; class=&quot;headerlink&quot; title=&quot;使用注解&quot;&gt;&lt;/a&gt;使用注解&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在一般的Java开发中，最常接触到的可能就是@Override和@SupressWarnings这两个注解了。使用@Override的时候只需要一个简单的声明即可。这种称为标记注解（marker annotation ），它的出现就代表了某种配置语义。而其它的注解是可以有自己的配置参数的。配置参数以名值对的方式出现。使用 @SupressWarnings的时候需要类似@SupressWarnings({“uncheck”, “unused”})这样的语法。在括号里面的是该注解可供配置的值。由于这个注解只有一个配置参数，该参数的名称默认为value，并且可以省略。而花括号则表示是数组类型。在JPA中的@Table注解使用类似@Table(name
  = “Customer”, schema = “APP”)这样的语法。从这里可以看到名值对的用法。在使用注解时候的配置参数的值必须是编译时刻的常量。&lt;br&gt;&amp;emsp;&amp;emsp;从某种角度来说，可以把注解看成是一个XML元素，该元素可以有不同的预定义的属性。而属性的值是可以在声明该元素的时候自行指定的。在代码中使用注解，就相当于把一部分元数据从XML文件移到了代码本身之中，在一个地方管理和维护。&lt;/p&gt;
&lt;h4 id=&quot;开发注解&quot;&gt;&lt;a href=&quot;#开发注解&quot; class=&quot;headerlink&quot; title=&quot;开发注解&quot;&gt;&lt;/a&gt;开发注解&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在一般的开发中，只需要通过阅读相关的API文档来了解每个注解的配置参数的含义，并在代码中正确使用即可。在有些情况下，可能会需要开发自己的注解。这在库的开发中比较常见。注解的定义有点类似接口。下面的代码给出了一个简单的描述代码分工安排的注解。通过该注解可以在源代码中记录每个类或接口的分工和进度情况。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; Assignment &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;assignee&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;effort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;finished&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; 0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型。可以通过default来声明参数的默认值。在这里可以看到@Retention和@Target这样的元注解，用来声明注解本身的行为。@Retention用来声明注解的保留策略，有CLASS、RUNTIME和SOURCE这三种，分别表示注解保存在类文件、JVM运行时刻和源代码中。只有当声明为RUNTIME的时候，才能够在运行时刻通过反射API来获取到注解的信息。@Target用来声明注解可以被添加在哪些类型的元素上，如类型、方法和域等。&lt;/p&gt;
&lt;h4 id=&quot;处理注解&quot;&gt;
  &lt;a href=&quot;#处理注解&quot; class=&quot;headerlink&quot; title=&quot;处理注解&quot;&gt;&lt;/a&gt;处理注解&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;在程序中添加的注解，可以在编译时刻或是运行时刻来进行处理。在编译时刻处理的时候，是分成多趟来进行的。如果在某趟处理中产生了新的Java源文件，那么就需要另外一趟处理来处理新生成的源文件。如此往复，直到没有新文件被生成为止。在完成处理之后，再对Java代码进行编译。JDK 5中提供了apt工具用来对注解进行处理。apt是一个命令行工具，与之配套的还有一套用来描述程序语义结构的Mirror API。Mirror API（com.sun.mirror.*）描述的是程序在编译时刻的静态结构。通过Mirror
    API可以获取到被注解的Java类型元素的信息，从而提供相应的处理逻辑。具体的处理工作交给apt工具来完成。编写注解处理器的核心是AnnotationProcessorFactory和AnnotationProcessor两个接口。后者表示的是注解处理器，而前者则是为某些注解类型创建注解处理器的工厂。&lt;br&gt;&amp;emsp;&amp;emsp;以上面的注解Assignment为例，当每个开发人员都在源代码中更新进度的话，就可以通过一个注解处理器来生成一个项目整体进度的报告。 首先是注解处理器工厂的实现。&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AssignmentApf&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AnnotationProcessorFactory&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; AnnotationProcessor &lt;span class=&quot;title&quot;&gt;getProcessorFor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Set&amp;lt;AnnotationTypeDeclaration&amp;gt; atds,? AnnotationProcessorEnvironment env)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (atds.isEmpty()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; AnnotationProcessors.NO_OP;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AssignmentAp(env); &lt;span class=&quot;comment&quot;&gt;//返回注解处理器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Collection&amp;lt;String&amp;gt; &lt;span class=&quot;title&quot;&gt;supportedAnnotationTypes&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Collections.unmodifiableList(Arrays.asList(&lt;span class=&quot;string&quot;&gt;&quot;annotation.Assignment&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Collection&amp;lt;String&amp;gt; &lt;span class=&quot;title&quot;&gt;supportedOptions&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Collections.emptySet();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
    &lt;/figure&gt;
    &lt;p&gt;&amp;emsp;&amp;emsp;AnnotationProcessorFactory接口有三个方法：getProcessorFor是根据注解的类型来返回特定的注解处理器；supportedAnnotationTypes是返回该工厂生成的注解处理器所能支持的注解类型；supportedOptions用来表示所支持的附加选项。在运行apt命令行工具的时候，可以通过-A来传递额外的参数给注解处理器，如-Averbose=true。当工厂通过 supportedOptions方法声明了所能识别的附加选项之后，注解处理器就可以在运行时刻通过AnnotationProcessorEnvironment的getOptions方法获取到选项的实际值。注解处理器本身的基本实现如下所示。&lt;/p&gt;
    &lt;figure class=&quot;highlight java&quot;&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AssignmentAp&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AnnotationProcessor&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; AnnotationProcessorEnvironment env;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; AnnotationTypeDeclaration assignmentDeclaration;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AssignmentAp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(AnnotationProcessorEnvironment env)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.env = env;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        assignmentDeclaration = (AnnotationTypeDeclaration) env.getTypeDeclaration(&lt;span class=&quot;string&quot;&gt;&quot;annotation.Assignment&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Collection&amp;lt;Declaration&amp;gt; declarations = env.getDeclarationsAnnotatedWith(assignmentDeclaration);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Declaration declaration : declarations) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           processAssignmentAnnotations(declaration);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;processAssignmentAnnotations&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Declaration declaration)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Collection&amp;lt;AnnotationMirror&amp;gt; annotations = declaration.getAnnotationMirrors();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (AnnotationMirror mirror : annotations) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mirror.getAnnotationType().getDeclaration().equals(assignmentDeclaration)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Map&amp;lt;AnnotationTypeElementDeclaration, AnnotationValue&amp;gt; values = mirror.getElementValues();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                String assignee = (String) getAnnotationValue(values, &lt;span class=&quot;string&quot;&gt;&quot;assignee&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//获取注解的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
      &lt;/figure&gt;
      &lt;p&gt;&amp;emsp;&amp;emsp;注解处理器的处理逻辑都在process方法中完成。通过一个声明（Declaration）的getAnnotationMirrors方法就可以获取到该声明上所添加的注解的实际值。得到这些值之后，处理起来就不难了。&lt;br&gt;&amp;emsp;&amp;emsp;在创建好注解处理器之后，就可以通过apt命令行工具来对源代码中的注解进行处理。 命令的运行格式是apt -classpath bin -factory annotation.apt.AssignmentApf src/annotation/work/*.java，即通过-factory来指定注解处理器工厂类的名称。实际上，apt工具在完成处理之后，会自动调用javac来编译处理完成后的源代码。&lt;br&gt;&amp;emsp;&amp;emsp;JDK
        5中的apt工具的不足之处在于它是Oracle提供的私有实现。在JDK 6中，通过JSR 269把自定义注解处理器这一功能进行了规范化，有了新的javax.annotation.processing这个新的API。对Mirror API也进行了更新，形成了新的javax.lang.model包。注解处理器的使用也进行了简化，不需要再单独运行apt这样的命令行工具，Java编译器本身就可以完成对注解的处理。对于同样的功能，如果用JSR 269的做法，只需要一个类就可以了。&lt;/p&gt;
      &lt;figure class=&quot;highlight java&quot;&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
            &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SupportedSourceVersion&lt;/span&gt;(SourceVersion.RELEASE_6)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SupportedAnnotationTypes&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;annotation.Assignment&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AssignmentProcess&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractProcessor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; TypeElement assignmentElement; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ProcessingEnvironment processingEnv)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.init(processingEnv);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Elements elementUtils = processingEnv.getElementUtils();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        assignmentElement = elementUtils.getTypeElement(&lt;span class=&quot;string&quot;&gt;&quot;annotation.Assignment&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Set&amp;lt;? extends TypeElement&amp;gt; annotations, RoundEnvironment roundEnv)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Set&amp;lt;? extends Element&amp;gt; elements = roundEnv.getElementsAnnotatedWith(assignmentElement);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Element element : elements) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            processAssignment(element);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;processAssignment&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Element element)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        List&amp;lt;? extends AnnotationMirror&amp;gt; annotations = element.getAnnotationMirrors();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (AnnotationMirror mirror : annotations) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mirror.getAnnotationType().asElement().equals(assignmentElement)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Map&amp;lt;? extends ExecutableElement, ? extends AnnotationValue&amp;gt; values = mirror.getElementValues();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                String assignee = (String) getAnnotationValue(values, &lt;span class=&quot;string&quot;&gt;&quot;assignee&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//获取注解的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;
        &lt;/figure&gt;
        &lt;p&gt;&amp;emsp;&amp;emsp;仔细比较上面两段代码，可以发现它们的基本结构是类似的。不同之处在于JDK 6中通过元注解@SupportedAnnotationTypes来声明所支持的注解类型。另外描述程序静态结构的javax.lang.model包使用了不同的类型名称。使用的时候也更加简单，只需要通过javac -processor annotation.pap.AssignmentProcess Demo1.java这样的方式即可。&lt;br&gt;&amp;emsp;&amp;emsp;上面介绍的这两种做法都是在编译时刻进行处理的。而有些时候则需要在运行时刻来完成对注解的处理。这个时候就需要用到Java的反射API。反射API提供了在运行时刻读取注解信息的支持。不过前提是注解的保留策略声明的是运行时。Java反射API的AnnotatedElement接口提供了获取类、方法和域上的注解的实用方法。比如获取到一个Class类对象之后，通过getAnnotation方法就可以获取到该类上添加的指定注解类型的注解。&lt;/p&gt;
        &lt;h4 id=&quot;实例分析&quot;&gt;
          &lt;a href=&quot;#实例分析&quot; class=&quot;headerlink&quot; title=&quot;实例分析&quot;&gt;&lt;/a&gt;实例分析&lt;/h4&gt;
          &lt;p&gt;&amp;emsp;&amp;emsp;下面通过一个具体的实例来分析说明在实践中如何来使用和处理注解。假定有一个公司的雇员信息系统，从访问控制的角度出发，对雇员的工资的更新只能由具有特定角色的用户才能完成。考虑到访问控制需求的普遍性，可以定义一个注解来让开发人员方便的在代码中声明访问控制权限。&lt;/p&gt;
          &lt;figure class=&quot;highlight java&quot;&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(ElementType.METHOD)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; RequiredRoles &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    String[] value();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/figure&gt;
          &lt;p&gt;&amp;emsp;&amp;emsp;下一步则是如何对注解进行处理，这里使用的Java的反射API并结合动态代理。下面是动态代理中的InvocationHandler接口的实现。&lt;/p&gt;
          &lt;figure class=&quot;highlight java&quot;&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AccessInvocationHandler&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; T accessObj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AccessInvocationHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T accessObj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.accessObj = accessObj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        RequiredRoles annotation = method.getAnnotation(RequiredRoles.class); &lt;span class=&quot;comment&quot;&gt;//通过反射API获取注解&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (annotation != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            String[] roles = annotation.value();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            String role = AccessControl.getCurrentRole();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!Arrays.asList(roles).contains(role)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AccessControlException(&lt;span class=&quot;string&quot;&gt;&quot;The user is not allowed to invoke this method.&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; method.invoke(accessObj, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/figure&gt;
          &lt;p&gt;&amp;emsp;&amp;emsp;在具体使用的时候，首先要通过Proxy.newProxyInstance方法创建一个EmployeeGateway的接口的代理类，使用该代理类来完成实际的操作。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;注解的作用&quot;&gt;&lt;a href=&quot;#注解的作用&quot; class=&quot;headerlink&quot; title=&quot;注解的作用&quot;&gt;&lt;/a&gt;注解的作用&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在开发Java程序，尤其是Java EE应用的时候，总是免不了与各种配置文件打交道。以Ja
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://xiaolin.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浏览器是如何工作的(翻译文章)</title>
    <link href="http://xiaolin.site/2016/05/05/how-browsers-work/"/>
    <id>http://xiaolin.site/2016/05/05/how-browsers-work/</id>
    <published>2016-05-05T08:36:26.000Z</published>
    <updated>2016-07-18T07:33:44.473Z</updated>
    
    <content type="html">&lt;h4 id=&quot;我们要讨论的浏览器&quot;&gt;&lt;a href=&quot;#我们要讨论的浏览器&quot; class=&quot;headerlink&quot; title=&quot;我们要讨论的浏览器&quot;&gt;&lt;/a&gt;我们要讨论的浏览器&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;目前主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。根据 StatCounter 浏览器统计数据，目前（2011 年 8 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率将近 60%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。&lt;/p&gt;
&lt;h4 id=&quot;浏览器的主要功能&quot;&gt;&lt;a href=&quot;#浏览器的主要功能&quot; class=&quot;headerlink&quot; title=&quot;浏览器的主要功能&quot;&gt;&lt;/a&gt;浏览器的主要功能&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。&lt;br&gt;&amp;emsp;&amp;emsp;浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。&lt;br&gt;&amp;emsp;&amp;emsp;多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。&lt;/p&gt;
&lt;h4 id=&quot;浏览器的高层结构&quot;&gt;
  &lt;a href=&quot;#浏览器的高层结构&quot; class=&quot;headerlink&quot; title=&quot;浏览器的高层结构&quot;&gt;&lt;/a&gt;浏览器的高层结构&lt;/h4&gt;
  &lt;p&gt;浏览器的主要组件为:&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;strong&gt;用户界面&lt;/strong&gt; - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;浏览器引擎&lt;/strong&gt; - 在用户界面和呈现引擎之间传送指令。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;呈现引擎&lt;/strong&gt; - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;网络&lt;/strong&gt; - 用于网络调用，比如 HTTP 请求。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;用户界面后端&lt;/strong&gt; - 用于绘制基本的窗口小部件，比如组合框和窗口。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;JavaScript 解释器&lt;/strong&gt;。用于解析和执行 JavaScript 代码。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;数据存储&lt;/strong&gt;。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“Local Storage”，这是一个完整（但是轻便）的浏览器内置数据库。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/layers.png&quot; alt=&quot;浏览器的主要组件&quot;&gt;&lt;/li&gt;
  &lt;/ol&gt;
  &lt;h4 id=&quot;呈现引擎&quot;&gt;&lt;a href=&quot;#呈现引擎&quot; class=&quot;headerlink&quot; title=&quot;呈现引擎&quot;&gt;&lt;/a&gt;呈现引擎&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;呈现引擎的作用嘛…当然就是“呈现”了，也就是在浏览器的屏幕上显示请求的内容。&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本文中我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;本文所讨论的浏览器是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;em&gt;WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。&lt;/em&gt;&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;h5 id=&quot;主流程&quot;&gt;&lt;a href=&quot;#主流程&quot; class=&quot;headerlink&quot; title=&quot;主流程&quot;&gt;&lt;/a&gt;主流程&lt;/h5&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。&lt;/p&gt;
  &lt;p&gt;然后进行如下所示的基本流程：&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/flow.png&quot; alt=&quot;呈现引擎的基本流程&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;树结构呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;树结构呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。&lt;/p&gt;
  &lt;h5 id=&quot;主流程示例&quot;&gt;&lt;a href=&quot;#主流程示例&quot; class=&quot;headerlink&quot; title=&quot;主流程示例&quot;&gt;&lt;/a&gt;主流程示例&lt;/h5&gt;
  &lt;p&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/webkitflow.png&quot; alt=&quot;WebKit 主流程&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image008.jpg&quot; alt=&quot;Mozilla 的 Gecko 呈现引擎主流程&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;从图中可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。Gecko
    将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：&lt;/p&gt;
  &lt;h5 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h5&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与上下文无关的语法。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;解析器和词法分析器的组合&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;解析的过程可以分成两个子过程：词法分析和语法分析。&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;语法分析是应用语言的语法规则的过程。&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;解析器通常将解析工作分给以下两个组件来处理：&lt;strong&gt;词法分析器&lt;/strong&gt;（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而&lt;strong&gt;解析器&lt;/strong&gt;负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image011.png&quot; alt=&quot;从源文档到解析树&quot;&gt;&lt;br&gt;&amp;emsp;&amp;emsp;解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。&lt;/p&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;翻译&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image013.png&quot; alt=&quot;编译流程&quot;&gt;&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;解析示例&lt;/strong&gt;&lt;br&gt;现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。&lt;/p&gt;
  &lt;p&gt;词汇：我们用的语言可包含整数、加号和减号。&lt;/p&gt;
  &lt;p&gt;语法：&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;构成语言的语法单位是表达式、项和运算符。&lt;/li&gt;
    &lt;li&gt;我们用的语言可以包含任意数量的表达式。&lt;br&gt;3 表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”。&lt;/li&gt;
    &lt;li&gt;运算符是加号或减号。&lt;/li&gt;
    &lt;li&gt;项是一个整数或一个表达式。&lt;/li&gt;
  &lt;/ol&gt;
  &lt;p&gt;让我们分析一下 2 + 3 - 1。&lt;br&gt;匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合“一个项接一个运算符，然后再接一个项”的规则。2 + + 不与任何规则匹配，因此是无效的输入。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;词汇和语法的正式定义&lt;/strong&gt;&lt;br&gt;词汇通常用正则表达式表示。&lt;/p&gt;
  &lt;p&gt;例如，我们的示例语言可以定义如下：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;INTEGER :0|[1-9][0-9]*&lt;br&gt;PLUS : +&lt;br&gt;MINUS: -&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;正如您所看到的，这里用正则表达式给出了整数的定义。&lt;br&gt;语法通常使用一种称为 &lt;a href=&quot;http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form&quot; title=&quot;BNF&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BNF&lt;/a&gt; 的格式来定义。我们的示例语言可以定义如下：&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;expression := term operation term&lt;br&gt;operation := PLUS | MINUS&lt;br&gt;term := INTEGER | expression&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 BNF 格式表达的语法。有关正式定义，请&lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参阅关于与上下文无关的语法的维基百科文章&lt;/a&gt;。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;解析器类型&lt;/strong&gt;&lt;br&gt;有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。&lt;/p&gt;
  &lt;p&gt;让我们来看看这两种解析器会如何解析我们的示例：&lt;/p&gt;
  &lt;p&gt;自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。&lt;/p&gt;
  &lt;p&gt;自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。&lt;/p&gt;
  &lt;p&gt;这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;自动生成解析器&lt;/strong&gt;&lt;br&gt;有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。&lt;/p&gt;
  &lt;p&gt;WebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 Flex 以及用于创建解析器的 Bison（您也可能遇到 Lex 和 Yacc 这样的别名）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。&lt;/p&gt;
  &lt;h5 id=&quot;HTML-解析器&quot;&gt;&lt;a href=&quot;#HTML-解析器&quot; class=&quot;headerlink&quot; title=&quot;HTML 解析器&quot;&gt;&lt;/a&gt;HTML 解析器&lt;/h5&gt;
  &lt;p&gt;HTML 解析器的任务是将 HTML 标记解析成解析树。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;HTML 语法定义&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;非与上下文无关的语法&lt;/strong&gt;&lt;/p&gt;
  &lt;p&gt;正如我们在解析过程的简介中已经了解到的，语法可以用 BNF 等格式进行正式定义。&lt;/p&gt;
  &lt;p&gt;很遗憾，所有的常规解析器都不适用于 HTML（我并不是开玩笑，它们可以用于解析 CSS 和 JavaScript）。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。&lt;/p&gt;
  &lt;p&gt;有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。&lt;/p&gt;
  &lt;p&gt;这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？&lt;/p&gt;
  &lt;p&gt;区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。&lt;/p&gt;
  &lt;p&gt;显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;HTML DTD&lt;/strong&gt;&lt;br&gt;HTML 的定义采用了 DTD 格式。此格式可用于定义 SGML 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD 无法构成与上下文无关的语法。&lt;/p&gt;
  &lt;p&gt;DTD 存在一些变体。严格模式完全遵守 HTML 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;DOM&lt;/strong&gt;&lt;br&gt;解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。&lt;br&gt;解析树的根节点是“Document”对象。&lt;/p&gt;
  &lt;p&gt;DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：&lt;/p&gt;
  &lt;figure class=&quot;highlight html&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      Hello World&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;example.png&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;可翻译成如下的 DOM 树：&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image015.png&quot; alt=&quot;示例标记的 DOM 树&quot;&gt;&lt;/p&gt;
  &lt;p&gt;我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;解析算法&lt;/strong&gt;&lt;br&gt;我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。&lt;/p&gt;
  &lt;p&gt;原因在于：&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;语言的宽容本质。&lt;/li&gt;
    &lt;li&gt;浏览器历来对一些常见的无效 HTML 用法采取包容态度。&lt;/li&gt;
    &lt;li&gt;解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。&lt;/li&gt;
  &lt;/ol&gt;
  &lt;p&gt;由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。&lt;/p&gt;
  &lt;p&gt;HTML5 规范详细地描述了解析算法。此算法由两个阶段组成：标记化和树构建。&lt;/p&gt;
  &lt;p&gt;标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。&lt;/p&gt;
  &lt;p&gt;标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image017.png&quot; alt=&quot;HTML 解析流程（摘自 HTML5 规范）&quot;&gt;&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;标记化算法&lt;/strong&gt;&lt;br&gt;该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。&lt;/p&gt;
  &lt;p&gt;基本示例 - 将下面的 HTML 代码标记化：&lt;/p&gt;
  &lt;figure class=&quot;highlight html&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Hello world&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;初始状态是数据状态。遇到字符 &amp;lt; 时，状态更改为“标记打开状态”。接收一个 a-z 字符会创建“起始标记”，状态更改为“标记名称状态”。这个状态会一直保持到接收 &amp;gt; 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 html 标记。&lt;/p&gt;
  &lt;p&gt;遇到 &amp;gt; 标记时，会发送当前的标记，状态改回“数据状态”。&lt;/p&gt;

  &lt;body&gt;标记也会进行同样的处理。目前 html 和 body 标记均已发出。现在我们回到“数据状态”。接收到 Hello world 中的 H 字符时，将创建并发送字符标记，直到接收&lt;/body&gt;中的 &amp;lt;。我们将为 Hello world 中的每个字符都发送一个字符标记。
  &lt;p&gt;&lt;/p&gt;
  &lt;p&gt;现在我们回到“标记打开状态”。接收下一个输入字符 / 时，会创建 end tag token 并改为“标记名称状态”。我们会再次保持这个状态，直到接收 &amp;gt;。然后将发送新的标记，并回到“数据状态”。输入也会进行同样的处理。&lt;/p&gt;
  &lt;p&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image019.png&quot; alt=&quot;对示例输入进行标记化&quot;&gt;&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;树构建算法&lt;/strong&gt;&lt;br&gt;在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。&lt;/p&gt;
  &lt;p&gt;让我们来看看示例输入的树构建过程：&lt;/p&gt;
  &lt;figure class=&quot;highlight html&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Hello world&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是“initial mode”。接收 HTML 标记后转为“before html”模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。&lt;/p&gt;
  &lt;p&gt;然后状态将改为“before head”。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。&lt;/p&gt;
  &lt;p&gt;现在我们进入了“in head”模式，然后转入“after head”模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为“in body”。&lt;/p&gt;
  &lt;p&gt;现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。&lt;/p&gt;
  &lt;p&gt;接收 body 结束标记会触发“after body”模式。现在我们将接收 HTML 结束标记，然后进入“after after body”模式。接收到文件结束标记后，解析过程就此结束。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image022.gif&quot; alt=&quot;示例 HTML 的树构建&quot;&gt;&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;解析结束后的操作&lt;/strong&gt;&lt;br&gt;在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;浏览器的容错机制&lt;/strong&gt;&lt;br&gt;您在浏览 HTML 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。&lt;/p&gt;
  &lt;p&gt;以下面的 HTML 代码为例：&lt;/p&gt;
  &lt;figure class=&quot;highlight html&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;mytag&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;mytag&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Really lousy HTML&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。&lt;/p&gt;
  &lt;p&gt;不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进/后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。&lt;/p&gt;
  &lt;p&gt;HTML5 规范定义了一部分这样的要求。WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。&lt;br&gt;遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。&lt;br&gt;我们至少要能够处理以下错误情况：&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。&lt;/li&gt;
      &lt;li&gt;我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。&lt;/li&gt;
      &lt;li&gt;向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。&lt;/li&gt;
      &lt;li&gt;如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;让我们看一些 WebKit 容错的示例：&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;使用了/br 而不是 br&lt;/strong&gt;&lt;br&gt;有些网站使用了 /br 而不是 br。为了与 IE 和 Firefox 兼容，WebKit 将其与 br 做同样的处理。&lt;br&gt;代码如下：&lt;/p&gt;
  &lt;figure class=&quot;highlight javascript&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (t-&amp;gt;isCloseTag(brTag) &amp;amp;&amp;amp; m_document-&amp;gt;inCompatMode()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     reportError(MalformedBRError);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     t-&amp;gt;beginTag = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;请注意，错误处理是在内部进行的，用户并不会看到这个过程。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;离散表格&lt;/strong&gt;&lt;br&gt;离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。&lt;br&gt;比如以下的示例：&lt;/p&gt;
  &lt;figure class=&quot;highlight html&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;inner table&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;outer table&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;WebKit 会将其层次结构更改为两个同级表格：&lt;/p&gt;
  &lt;figure class=&quot;highlight html&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;outer table&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;inner table&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;WebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;嵌套的表单元素&lt;/strong&gt;&lt;br&gt;如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;过于复杂的标记层次结构&lt;/strong&gt;&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;示例网站 www.liceo.edu.mx 嵌套了约 1500 个标记，全都来自一堆 b 标记。我们只允许最多 20 层同类型标记的嵌套，如果再嵌套更多，就会全部忽略。&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;&lt;strong&gt;放错位置的 html 或者 body 结束标记&lt;/strong&gt;&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;所以网页作者需要注意，除非您想作为反面教材出现在 WebKit 容错代码段的示例中，否则还请编写格式正确的 HTML 代码。&lt;/p&gt;
  &lt;h5 id=&quot;CSS-解析&quot;&gt;&lt;a href=&quot;#CSS-解析&quot; class=&quot;headerlink&quot; title=&quot;CSS 解析&quot;&gt;&lt;/a&gt;CSS 解析&lt;/h5&gt;
  &lt;p&gt;还记得简介中解析的概念吗？和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，CSS 规范定义了 CSS 的词法和语法。&lt;/p&gt;
  &lt;p&gt;让我们来看一些示例：&lt;br&gt;词法语法（词汇）是针对各个标记用正则表达式定义的：&lt;/p&gt;
  &lt;p&gt;comment \/*[^&lt;em&gt;]&lt;/em&gt;*+([^/&lt;em&gt;][^&lt;/em&gt;]&lt;em&gt;\&lt;/em&gt;+)&lt;em&gt;\/&lt;br&gt;num [0-9]+|[0-9]&lt;/em&gt;“.”[0-9]+&lt;br&gt;nonascii [\200-\377]&lt;br&gt;nmstart [_a-z]|{nonascii}|{escape}&lt;br&gt;nmchar [_a-z0-9-]|{nonascii}|{escape}&lt;br&gt;name {nmchar}+&lt;br&gt;ident {nmstart}{nmchar}*&lt;br&gt;“ident”是标识符
    (identifier) 的缩写，比如类名。“name”是元素的 ID（通过“#”来引用）。&lt;/p&gt;
  &lt;p&gt;语法是采用 BNF 格式描述的。&lt;br&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ruleset&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  : selector [ &amp;apos;,&amp;apos; S* selector ]*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;apos;&amp;#123;&amp;apos; S* declaration [ &amp;apos;;&amp;apos; S* declaration ]* &amp;apos;&amp;#125;&amp;apos; S*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;selector&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;simple_selector&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  : element_name [ HASH | class | attrib | pseudo ]*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | [ HASH | class | attrib | pseudo ]+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;class&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  : &amp;apos;.&amp;apos; IDENT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;element_name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  : IDENT | &amp;apos;*&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;attrib&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  : &amp;apos;[&amp;apos; S* IDENT S* [ [ &amp;apos;=&amp;apos; | INCLUDES | DASHMATCH ] S*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [ IDENT | STRING ] S* ] &amp;apos;]&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pseudo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  : &amp;apos;:&amp;apos; [ IDENT | FUNCTION S* [IDENT S*] &amp;apos;)&amp;apos; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;&lt;/p&gt;
  &lt;p&gt;解释：这是一个规则集的结构：&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;div.error , a.error &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  color:red;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  font-weight:bold;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;div.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：&lt;/p&gt;
  &lt;figure class=&quot;highlight&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ruleset&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  : selector [ &#39;,&#39; S* selector ]*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &#39;&amp;#123;&#39; S* declaration [ &#39;;&#39; S* declaration ]* &#39;&amp;#125;&#39; S*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和“选择器”将由下面的 BNF 格式定义。&lt;/p&gt;
  &lt;h5 id=&quot;WebKit-CSS-解析器&quot;&gt;&lt;a href=&quot;#WebKit-CSS-解析器&quot; class=&quot;headerlink&quot; title=&quot;WebKit CSS 解析器&quot;&gt;&lt;/a&gt;WebKit CSS 解析器&lt;/h5&gt;
  &lt;p&gt;WebKit 使用 Flex 和 Bison 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image023.png&quot; alt=&quot;解析 CSS&quot;&gt;&lt;/p&gt;
  &lt;h4 id=&quot;处理脚本和样式表的顺序&quot;&gt;&lt;a href=&quot;#处理脚本和样式表的顺序&quot; class=&quot;headerlink&quot; title=&quot;处理脚本和样式表的顺序&quot;&gt;&lt;/a&gt;处理脚本和样式表的顺序&lt;/h4&gt;
  &lt;h5 id=&quot;脚本&quot;&gt;&lt;a href=&quot;#脚本&quot; class=&quot;headerlink&quot; title=&quot;脚本&quot;&gt;&lt;/a&gt;脚本&lt;/h5&gt;
  &lt;p&gt;网络的模型是同步的。网页作者希望解析器遇到 script 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。&lt;/p&gt;
  &lt;h5 id=&quot;预解析&quot;&gt;&lt;a href=&quot;#预解析&quot; class=&quot;headerlink&quot; title=&quot;预解析&quot;&gt;&lt;/a&gt;预解析&lt;/h5&gt;
  &lt;p&gt;WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。&lt;/p&gt;
  &lt;h5 id=&quot;样式表&quot;&gt;&lt;a href=&quot;#样式表&quot; class=&quot;headerlink&quot; title=&quot;样式表&quot;&gt;&lt;/a&gt;样式表&lt;/h5&gt;
  &lt;p&gt;另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。&lt;/p&gt;
  &lt;h5 id=&quot;呈现树构建&quot;&gt;&lt;a href=&quot;#呈现树构建&quot; class=&quot;headerlink&quot; title=&quot;呈现树构建&quot;&gt;&lt;/a&gt;呈现树构建&lt;/h5&gt;
  &lt;p&gt;在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。&lt;/p&gt;
  &lt;p&gt;Firefox 将呈现树中的元素称为“框架”。WebKit 使用的术语是呈现器或呈现对象。&lt;br&gt;呈现器知道如何布局并将自身及其子元素绘制出来。&lt;br&gt;WebKits RenderObject 类是所有呈现器的基类，其定义如下：&lt;/p&gt;
  &lt;figure class=&quot;highlight c&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; RenderObject&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;paint&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PaintInfo)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; rect &lt;span class=&quot;title&quot;&gt;repaintRect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Node* node;  &lt;span class=&quot;comment&quot;&gt;//the DOM node&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  RenderStyle* style;  &lt;span class=&quot;comment&quot;&gt;// the computed style&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  RenderLayer* containgLayer; &lt;span class=&quot;comment&quot;&gt;//the containing z-index layer&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;每一个呈现器都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。&lt;br&gt;框的类型会受到与节点相关的“display”样式属性的影响（请参阅样式计算章节）。下面这段 WebKit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的呈现器。&lt;/p&gt;
  &lt;figure class=&quot;highlight c&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Document* doc = node-&amp;gt;document();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    RenderArena* arena = doc-&amp;gt;renderArena();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    RenderObject* o = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (style-&amp;gt;display()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; NONE:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; INLINE:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; (arena) RenderInline(node);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; BLOCK:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; (arena) RenderBlock(node);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; INLINE_BLOCK:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; (arena) RenderBlock(node);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; LIST_ITEM:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; (arena) RenderListItem(node);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; o;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。&lt;br&gt;在 WebKit 中，如果一个元素需要创建特殊的呈现器，就会替换 createRenderer 方法。呈现器所指向的样式对象中包含了一些和几何无关的信息。&lt;/p&gt;
  &lt;h5 id=&quot;呈现树和-DOM-树的关系&quot;&gt;&lt;a href=&quot;#呈现树和-DOM-树的关系&quot; class=&quot;headerlink&quot; title=&quot;呈现树和 DOM 树的关系&quot;&gt;&lt;/a&gt;呈现树和 DOM 树的关系&lt;/h5&gt;
  &lt;p&gt;呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。&lt;br&gt;有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。&lt;br&gt;另一个关于多呈现器的例子是格式无效的
    HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。&lt;/p&gt;
  &lt;p&gt;有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。&lt;/p&gt;
  &lt;p&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image025.png&quot; alt=&quot;呈现树及其对应的 DOM 树 (3.1)。初始容器 block 为“viewport”，而在 WebKit 中则为“RenderView”对象。&quot;&gt;&lt;/p&gt;
  &lt;h5 id=&quot;构建呈现树的流程&quot;&gt;&lt;a href=&quot;#构建呈现树的流程&quot; class=&quot;headerlink&quot; title=&quot;构建呈现树的流程&quot;&gt;&lt;/a&gt;构建呈现树的流程&lt;/h5&gt;
  &lt;p&gt;在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 FrameConstructor，由该构造器解析样式（请参阅样式计算）并创建框架。&lt;/p&gt;
  &lt;p&gt;在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。&lt;/p&gt;
  &lt;p&gt;处理 html 和 body 标记就会构建呈现树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，而 WebKit 称之为 RenderView。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。&lt;/p&gt;
  &lt;h5 id=&quot;样式计算&quot;&gt;&lt;a href=&quot;#样式计算&quot; class=&quot;headerlink&quot; title=&quot;样式计算&quot;&gt;&lt;/a&gt;样式计算&lt;/h5&gt;
  &lt;p&gt;构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。&lt;/p&gt;
  &lt;p&gt;样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。&lt;/p&gt;
  &lt;p&gt;样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在“Firefox Profile”文件夹下）。&lt;/p&gt;
  &lt;p&gt;样式计算存在以下难点：&lt;/p&gt;
  &lt;p&gt;样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。&lt;br&gt;如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。&lt;/p&gt;
  &lt;p&gt;例如下面这个组合选择器：&lt;br&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;div div div div&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;&lt;/p&gt;
  &lt;p&gt;这意味着规则适用于作为 3 个 div 元素的子代的&lt;/p&gt;
  &lt;div&gt;。如果您要检查规则是否适用于某个指定的
    &lt;div&gt;元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。
      &lt;p&gt;&lt;/p&gt;
      &lt;p&gt;应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。&lt;br&gt;让我们来看看浏览器是如何处理这些问题的：&lt;br&gt;&lt;strong&gt;共享样式数据&lt;/strong&gt;&lt;/p&gt;
      &lt;p&gt;WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：&lt;br&gt;这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）&lt;br&gt;任何元素都没有 ID&lt;br&gt;标记名称应匹配&lt;br&gt;类属性应匹配&lt;br&gt;映射属性的集合必须是完全相同的&lt;br&gt;链接状态必须匹配&lt;br&gt;焦点状态必须匹配&lt;br&gt;任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配&lt;br&gt;元素中不能有任何
        inline 样式属性&lt;br&gt;不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;Firefox 规则树&lt;/strong&gt;&lt;br&gt;为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image035.png&quot; alt=&quot;Firefox 样式上下文树&quot;&gt;&lt;br&gt;样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。&lt;/p&gt;
      &lt;p&gt;所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。&lt;/p&gt;
      &lt;p&gt;这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/tree.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B - E - I（按照此顺序）。由于我们在树中已经计算出了路径 A - B - E - I - L，因此就已经有了此路径，这就减少了现在所需的工作量。&lt;br&gt;让我们看看规则树如何帮助我们减少工作。&lt;br&gt;&lt;strong&gt;结构划分&lt;/strong&gt;&lt;br&gt;样式上下文可分割成多个结构。这些结构体包含了特定类别（如
        border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为“重置”属性）如果未进行定义，则使用默认值。&lt;/p&gt;
      &lt;p&gt;规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;使用规则树计算样式上下文&lt;/strong&gt;&lt;br&gt;在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。&lt;br&gt;如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。&lt;/p&gt;
      &lt;p&gt;如果我们找不到结构的任何定义，那么假如该结构是“继承”类型，我们会在上下文树中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。&lt;/p&gt;
      &lt;p&gt;如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。&lt;/p&gt;
      &lt;p&gt;如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享整个样式上下文。&lt;/p&gt;
      &lt;p&gt;让我们来看一个例子，假设我们有如下 HTML 代码：&lt;/p&gt;
      &lt;figure class=&quot;highlight html&quot;&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
            &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;err&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;div1&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        this is a &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;big&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; big error &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        this is also a&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;big&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; very  big  error&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt; error&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;err&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;div2&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;another error&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;
      &lt;/figure&gt;
      &lt;p&gt;还有如下规则：&lt;/p&gt;
      &lt;figure class=&quot;highlight css&quot;&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
            &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;div&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;5px&lt;/span&gt;;&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:black&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.err&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:red&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.big&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;margin-top&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;3px&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;span&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;margin-bottom&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;4px&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#div1&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:blue&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#div2&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:green&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;
      &lt;/figure&gt;
      &lt;p&gt;为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即“color”），而 margin 结构包含四条边。&lt;br&gt;形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）：&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image027.png&quot; alt=&quot;规则树&quot;&gt;&lt;/p&gt;
      &lt;p&gt;上下文树如下图所示（节点名 : 指向的规则节点）：&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image029.png&quot; alt=&quot;上下文树&quot;&gt;&lt;/p&gt;
      &lt;p&gt;假设我们解析 HTML 时遇到了第二个&lt;/p&gt;
      &lt;div&gt;标记，我们需要为此节点创建样式上下文，并填充其样式结构。&lt;br&gt;经过规则匹配，我们发现该
        &lt;div&gt;的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。&lt;br&gt;我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。
          &lt;p&gt;&lt;/p&gt;
          &lt;p&gt;现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。&lt;/p&gt;
          &lt;p&gt;我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。&lt;/p&gt;
          &lt;p&gt;第二个 &lt;span&gt;元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。&lt;/span&gt;&lt;/p&gt;
          &lt;p&gt;对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。&lt;br&gt;例如，如果我们在某个段落中添加 font 规则：&lt;br&gt;&lt;/p&gt;
          &lt;figure class=&quot;highlight&quot;&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;p &amp;#123;font-family:Verdana;font size:10px;font-weight:bold&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/figure&gt;
          &lt;p&gt;&lt;/p&gt;
          &lt;p&gt;那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font 结构（前提是该段落没有指定 font 规则）。&lt;br&gt;在 WebKit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。&lt;br&gt;因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题
            1 和问题 3。Firefox 规则树还有助于按照正确的顺序应用属性。&lt;/p&gt;
          &lt;p&gt;&lt;strong&gt;对规则进行处理以简化匹配&lt;/strong&gt;&lt;br&gt;样式规则有一些来源：&lt;/p&gt;
          &lt;ul&gt;
            &lt;li&gt;
              &lt;p&gt;外部样式表或样式元素中的 CSS 规则&lt;/p&gt;
              &lt;figure class=&quot;highlight css&quot;&gt;
                &lt;table&gt;
                  &lt;tr&gt;
                    &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                    &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:blue&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                &lt;/table&gt;
              &lt;/figure&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;p&gt;inline 样式属性及类似内容&lt;/p&gt;
              &lt;figure class=&quot;highlight html&quot;&gt;
                &lt;table&gt;
                  &lt;tr&gt;
                    &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                    &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;color:blue&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                &lt;/table&gt;
              &lt;/figure&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;p&gt;HTML 可视化属性（映射到相关的样式规则）&lt;/p&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
          &lt;figure class=&quot;highlight html&quot;&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;color:blue&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/figure&gt;
          &lt;p&gt;后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。&lt;/p&gt;
          &lt;p&gt;我们之前在第 2 个问题中提到过，CSS 规则匹配可能比较棘手。为了解决这一难题，可以对 CSS 规则进行一些处理，以便访问。&lt;/p&gt;
          &lt;p&gt;样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。&lt;br&gt;这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了 (4.1)。&lt;/p&gt;
          &lt;p&gt;我们以如下的样式规则为例：&lt;/p&gt;
          &lt;figure class=&quot;highlight css&quot;&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.error&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;:red&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#messageDiv&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;height&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;50px&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;div&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;5px&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/figure&gt;
          &lt;p&gt;第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。&lt;br&gt;对于下面的 HTML 代码段：&lt;/p&gt;
          &lt;figure class=&quot;highlight html&quot;&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;error&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;an error occurred &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;messageDiv&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;this is a message&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/figure&gt;
          &lt;p&gt;我们首先会为 p 元素寻找匹配的规则。类表中有一个“error”键，在下面可以找到“p.error”的规则。div 元素在 ID 表（键为 ID）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。&lt;br&gt;例如，如果 div 的对应规则如下：&lt;/p&gt;
          &lt;figure class=&quot;highlight html&quot;&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;table div &amp;#123;margin:5px&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/figure&gt;
          &lt;p&gt;这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。&lt;br&gt;WebKit 和 Firefox 都进行了这一处理。&lt;/p&gt;
          &lt;p&gt;&lt;strong&gt;以正确的层叠顺序应用规则&lt;/strong&gt;&lt;br&gt;样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。&lt;/p&gt;
          &lt;p&gt;如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。&lt;/p&gt;
          &lt;p&gt;&lt;strong&gt;样式表层叠顺序&lt;/strong&gt;&lt;br&gt;某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：&lt;br&gt;浏览器声明&lt;br&gt;用户普通声明&lt;br&gt;作者普通声明&lt;br&gt;作者重要声明&lt;br&gt;用户重要声明&lt;br&gt;浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据特异性进行排序，然后再是其指定顺序。HTML
            可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。&lt;/p&gt;
          &lt;p&gt;&lt;strong&gt;特异性&lt;/strong&gt;&lt;br&gt;选择器的特异性由 CSS2 规范定义如下：&lt;/p&gt;
          &lt;p&gt;如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)&lt;br&gt;记为选择器中 ID 属性的个数 (= b)&lt;br&gt;记为选择器中其他属性和伪类的个数 (= c)&lt;br&gt;记为选择器中元素名称和伪元素的个数 (= d)&lt;/p&gt;
          &lt;p&gt;将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。&lt;br&gt;您使用的进制取决于上述类别中的最高计数。&lt;br&gt;例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p …（在选择器中出现了 17 个标记，这样的可能性极低）。&lt;/p&gt;
          &lt;p&gt;一些示例：&lt;/p&gt;
          &lt;blockquote&gt;
            &lt;ul&gt;
              &lt;li&gt;{} /&lt;em&gt; a=0 b=0 c=0 d=0 -&amp;gt; specificity = 0,0,0,0 &lt;/em&gt;/&lt;br&gt;li {} /&lt;em&gt; a=0 b=0 c=0 d=1 -&amp;gt; specificity = 0,0,0,1 &lt;/em&gt;/&lt;br&gt;li:first-line {} /&lt;em&gt; a=0 b=0 c=0 d=2 -&amp;gt; specificity = 0,0,0,2 &lt;/em&gt;/&lt;br&gt;ul li {} /&lt;em&gt; a=0 b=0 c=0 d=2 -&amp;gt; specificity = 0,0,0,2 &lt;/em&gt;/&lt;br&gt;ul
                ol+li {} /&lt;em&gt; a=0 b=0 c=0 d=3 -&amp;gt; specificity = 0,0,0,3 &lt;/em&gt;/&lt;br&gt;h1 + &lt;em&gt;[rel=up]{} /&lt;/em&gt; a=0 b=0 c=1 d=1 -&amp;gt; specificity = 0,0,1,1 &lt;em&gt;/&lt;br&gt;ul ol li.red {} /&lt;/em&gt; a=0 b=0 c=1 d=3 -&amp;gt; specificity = 0,0,1,3 &lt;em&gt;/&lt;br&gt;li.red.level {} /&lt;/em&gt;                a=0 b=0 c=2 d=1 -&amp;gt; specificity = 0,0,2,1 &lt;em&gt;/&lt;br&gt;#x34y {} /&lt;/em&gt; a=0 b=1 c=0 d=0 -&amp;gt; specificity = 0,1,0,0 &lt;em&gt;/&lt;br&gt;style=”” /&lt;/em&gt; a=1 b=0 c=0 d=0 -&amp;gt; specificity = 1,0,0,0 */&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/blockquote&gt;
          &lt;p&gt;&lt;strong&gt;规则排序&lt;/strong&gt;&lt;br&gt;找到匹配的规则之后，应根据级联顺序将其排序。WebKit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，WebKit 通过替换“&amp;gt;”运算符来实现排序：&lt;/p&gt;
          &lt;figure class=&quot;highlight c&quot;&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt; &amp;gt;(CSSRuleData&amp;amp; r1, CSSRuleData&amp;amp; r2)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; spec1 = r1.selector()-&amp;gt;specificity();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; spec2 = r2.selector()-&amp;gt;specificity();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (spec1 == spec2) : r1.position() &amp;gt; r2.position() : spec1 &amp;gt; spec2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/figure&gt;
          &lt;h5 id=&quot;渐进式处理&quot;&gt;&lt;a href=&quot;#渐进式处理&quot; class=&quot;headerlink&quot; title=&quot;渐进式处理&quot;&gt;&lt;/a&gt;渐进式处理&lt;/h5&gt;
          &lt;p&gt;WebKit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。&lt;/p&gt;
          &lt;h4 id=&quot;布局&quot;&gt;&lt;a href=&quot;#布局&quot; class=&quot;headerlink&quot; title=&quot;布局&quot;&gt;&lt;/a&gt;布局&lt;/h4&gt;
          &lt;p&gt;呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。&lt;/p&gt;
          &lt;p&gt;HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (3.5)。&lt;/p&gt;
          &lt;p&gt;坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。&lt;/p&gt;
          &lt;p&gt;布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的&lt;/p&gt;
          &lt;html&gt;元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。
          &lt;p&gt;&lt;/p&gt;
          &lt;p&gt;根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。&lt;br&gt;所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。&lt;/p&gt;
          &lt;h5 id=&quot;Dirty-位系统&quot;&gt;&lt;a href=&quot;#Dirty-位系统&quot; class=&quot;headerlink&quot; title=&quot;Dirty 位系统&quot;&gt;&lt;/a&gt;Dirty 位系统&lt;/h5&gt;
          &lt;p&gt;为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。&lt;/p&gt;
          &lt;p&gt;有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。&lt;/p&gt;
          &lt;h5 id=&quot;全局布局和增量布局&quot;&gt;&lt;a href=&quot;#全局布局和增量布局&quot; class=&quot;headerlink&quot; title=&quot;全局布局和增量布局&quot;&gt;&lt;/a&gt;全局布局和增量布局&lt;/h5&gt;
          &lt;p&gt;全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：&lt;/p&gt;
          &lt;p&gt;影响所有呈现器的全局样式更改，例如字体大小更改。&lt;br&gt;屏幕大小调整。&lt;br&gt;布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。&lt;br&gt;当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/reflow.png&quot; alt=&quot;增量布局 - 只有 dirty 呈现器及其子代进行布局&quot;&gt;&lt;/p&gt;
          &lt;h5 id=&quot;异步布局和同步布局&quot;&gt;
            &lt;a href=&quot;#异步布局和同步布局&quot; class=&quot;headerlink&quot; title=&quot;异步布局和同步布局&quot;&gt;&lt;/a&gt;异步布局和同步布局&lt;/h5&gt;
            &lt;p&gt;增量布局是异步执行的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。&lt;br&gt;请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。&lt;br&gt;全局布局往往是同步触发的。&lt;br&gt;有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。&lt;/p&gt;
            &lt;h5 id=&quot;优化&quot;&gt;&lt;a href=&quot;#优化&quot; class=&quot;headerlink&quot; title=&quot;优化&quot;&gt;&lt;/a&gt;优化&lt;/h5&gt;
            &lt;p&gt;如果布局是由“大小调整”或呈现器的位置（而非大小）改变而触发的，那么可以从缓存中获取呈现器的大小，而无需重新计算。&lt;br&gt;在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。&lt;/p&gt;
            &lt;h5 id=&quot;布局处理&quot;&gt;&lt;a href=&quot;#布局处理&quot; class=&quot;headerlink&quot; title=&quot;布局处理&quot;&gt;&lt;/a&gt;布局处理&lt;/h5&gt;
            &lt;p&gt;布局通常具有以下模式：&lt;/p&gt;
            &lt;p&gt;父呈现器确定自己的宽度。&lt;br&gt;父呈现器依次处理子呈现器，并且：&lt;br&gt;放置子呈现器（设置 x,y 坐标）。&lt;br&gt;如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子呈现器的高度。&lt;br&gt;父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。&lt;br&gt;将其 dirty 位设置为 false。&lt;br&gt;Firefox 使用“state”对象 (nsHTMLReflowState)
              作为布局的参数（称为“reflow”），这其中包括了父呈现器的宽度。&lt;br&gt;Firefox 布局的输出为“metrics”对象 (nsHTMLReflowMetrics)，其包含计算得出的呈现器高度。&lt;/p&gt;
            &lt;h5 id=&quot;宽度计算&quot;&gt;&lt;a href=&quot;#宽度计算&quot; class=&quot;headerlink&quot; title=&quot;宽度计算&quot;&gt;&lt;/a&gt;宽度计算&lt;/h5&gt;
            &lt;p&gt;呈现器宽度是根据容器块的宽度、呈现器样式中的“width”属性以及边距和边框计算得出的。&lt;br&gt;例如以下 div 的宽度：&lt;/p&gt;
            &lt;figure class=&quot;highlight html&quot;&gt;
              &lt;table&gt;
                &lt;tr&gt;
                  &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                  &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;width:30%&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/table&gt;
            &lt;/figure&gt;
            &lt;p&gt;将由 WebKit 计算如下（BenderBox 类，calcWidth 方法）：&lt;br&gt;容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：&lt;/p&gt;
            &lt;figure class=&quot;highlight javascript&quot;&gt;
              &lt;table&gt;
                &lt;tr&gt;
                  &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                  &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;clientWidth() - paddingLeft() - paddingRight()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/table&gt;
            &lt;/figure&gt;
            &lt;p&gt;clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。&lt;br&gt;元素的宽度是“width”样式属性。它会根据容器宽度的百分比计算得出一个绝对值。&lt;br&gt;然后加上水平方向的边框和补白。&lt;br&gt;现在计算得出的是“preferred width”。然后需要计算最小宽度和最大宽度。&lt;br&gt;如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。&lt;br&gt;这些值会缓存起来，以用于需要布局而宽度不变的情况。&lt;/p&gt;
            &lt;h5 id=&quot;换行&quot;&gt;
              &lt;a href=&quot;#换行&quot; class=&quot;headerlink&quot; title=&quot;换行&quot;&gt;&lt;/a&gt;换行&lt;/h5&gt;
              &lt;p&gt;如果呈现器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的呈现器，并对其调用布局。&lt;/p&gt;
              &lt;h4 id=&quot;绘制&quot;&gt;&lt;a href=&quot;#绘制&quot; class=&quot;headerlink&quot; title=&quot;绘制&quot;&gt;&lt;/a&gt;绘制&lt;/h4&gt;
              &lt;p&gt;在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。&lt;/p&gt;
              &lt;h5 id=&quot;全局绘制和增量绘制&quot;&gt;&lt;a href=&quot;#全局绘制和增量绘制&quot; class=&quot;headerlink&quot; title=&quot;全局绘制和增量绘制&quot;&gt;&lt;/a&gt;全局绘制和增量绘制&lt;/h5&gt;
              &lt;p&gt;和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。&lt;/p&gt;
              &lt;h5 id=&quot;绘制顺序&quot;&gt;
                &lt;a href=&quot;#绘制顺序&quot; class=&quot;headerlink&quot; title=&quot;绘制顺序&quot;&gt;&lt;/a&gt;绘制顺序&lt;/h5&gt;
                &lt;p&gt;CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：&lt;br&gt;背景颜色&lt;br&gt;背景图片&lt;br&gt;边框&lt;br&gt;子代&lt;br&gt;轮廓&lt;/p&gt;
                &lt;h5 id=&quot;Firefox-显示列表&quot;&gt;&lt;a href=&quot;#Firefox-显示列表&quot; class=&quot;headerlink&quot; title=&quot;Firefox 显示列表&quot;&gt;&lt;/a&gt;Firefox 显示列表&lt;/h5&gt;
                &lt;p&gt;Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是呈现器的背景，然后是边框等等）包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。&lt;br&gt;Firefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。&lt;/p&gt;
                &lt;h5 id=&quot;WebKit-矩形存储&quot;&gt;&lt;a href=&quot;#WebKit-矩形存储&quot; class=&quot;headerlink&quot; title=&quot;WebKit 矩形存储&quot;&gt;&lt;/a&gt;WebKit 矩形存储&lt;/h5&gt;
                &lt;p&gt;在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。&lt;/p&gt;
                &lt;h4 id=&quot;动态变化&quot;&gt;&lt;a href=&quot;#动态变化&quot; class=&quot;headerlink&quot; title=&quot;动态变化&quot;&gt;&lt;/a&gt;动态变化&lt;/h4&gt;
                &lt;p&gt;在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。&lt;/p&gt;
                &lt;h4 id=&quot;呈现引擎的线程&quot;&gt;&lt;a href=&quot;#呈现引擎的线程&quot; class=&quot;headerlink&quot; title=&quot;呈现引擎的线程&quot;&gt;&lt;/a&gt;呈现引擎的线程&lt;/h4&gt;
                &lt;p&gt;呈现引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。&lt;br&gt;网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。&lt;/p&gt;
                &lt;h5 id=&quot;事件循环&quot;&gt;&lt;a href=&quot;#事件循环&quot; class=&quot;headerlink&quot; title=&quot;事件循环&quot;&gt;&lt;/a&gt;事件循环&lt;/h5&gt;
                &lt;p&gt;浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。&lt;/p&gt;
                &lt;h4 id=&quot;CSS2-可视化模型&quot;&gt;&lt;a href=&quot;#CSS2-可视化模型&quot; class=&quot;headerlink&quot; title=&quot;CSS2 可视化模型&quot;&gt;&lt;/a&gt;CSS2 可视化模型&lt;/h4&gt;
                &lt;h5 id=&quot;画布&quot;&gt;&lt;a href=&quot;#画布&quot; class=&quot;headerlink&quot; title=&quot;画布&quot;&gt;&lt;/a&gt;画布&lt;/h5&gt;
                &lt;p&gt;根据 CSS2 规范，“画布”这一术语是指“用来呈现格式化结构的空间”，也就是供浏览器绘制内容的区域。画布的空间尺寸大小是无限的，但是浏览器会根据视口的尺寸选择一个初始宽度。&lt;/p&gt;
                &lt;p&gt;根据 www.w3.org/TR/CSS2/zindex.html，画布如果包含在其他画布内，就是透明的；否则会由浏览器指定一种颜色。&lt;/p&gt;
                &lt;h5 id=&quot;CSS-框模型&quot;&gt;&lt;a href=&quot;#CSS-框模型&quot; class=&quot;headerlink&quot; title=&quot;CSS 框模型&quot;&gt;&lt;/a&gt;CSS 框模型&lt;/h5&gt;
                &lt;p&gt;CSS 框模型描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。&lt;br&gt;每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image046.jpg&quot; alt=&quot;CSS2 框模型&quot;&gt;&lt;br&gt;每一个节点都会生成 0..n 个这样的框。&lt;br&gt;所有元素都有一个“display”属性，决定了它们所对应生成的框类型。示例：&lt;/p&gt;
                &lt;blockquote&gt;
                  &lt;p&gt;block - generates a block box.&lt;br&gt;inline - generates one or more inline boxes.&lt;br&gt;none - no box is generated.&lt;/p&gt;
                &lt;/blockquote&gt;
                &lt;p&gt;默认值是 inline，但是浏览器样式表设置了其他默认值。例如，“div”元素的 display 属性默认值是 block。&lt;br&gt;您可以在这里找到默认样式表示例：www.w3.org/TR/CSS2/sample.html&lt;/p&gt;
                &lt;h5 id=&quot;定位方案&quot;&gt;&lt;a href=&quot;#定位方案&quot; class=&quot;headerlink&quot; title=&quot;定位方案&quot;&gt;&lt;/a&gt;定位方案&lt;/h5&gt;
                &lt;p&gt;有三种定位方案：&lt;/p&gt;
                &lt;p&gt;普通：根据对象在文档中的位置进行定位，也就是说对象在呈现树中的位置和它在 DOM 树中的位置相似，并根据其框类型和尺寸进行布局。&lt;br&gt;浮动：对象先按照普通流进行布局，然后尽可能地向左或向右移动。&lt;br&gt;绝对：对象在呈现树中的位置和它在 DOM 树中的位置不同。&lt;/p&gt;
                &lt;p&gt;定位方案是由“position”属性和“float”属性设置的。&lt;/p&gt;
                &lt;p&gt;如果值是 static 和 relative，就是普通流&lt;br&gt;如果值是 absolute 和 fixed，就是绝对定位&lt;/p&gt;
                &lt;p&gt;static 定位无需定义位置，而是使用默认定位。对于其他方案，网页作者需要指定位置：top、bottom、left、right。&lt;br&gt;框的布局方式是由以下因素决定的：&lt;/p&gt;
                &lt;p&gt;框类型&lt;br&gt;框尺寸&lt;br&gt;定位方案&lt;br&gt;外部信息，例如图片大小和屏幕大小&lt;/p&gt;
                &lt;h5 id=&quot;框类型&quot;&gt;&lt;a href=&quot;#框类型&quot; class=&quot;headerlink&quot; title=&quot;框类型&quot;&gt;&lt;/a&gt;框类型&lt;/h5&gt;
                &lt;p&gt;block 框：形成一个 block，在浏览器窗口中拥有其自己的矩形区域。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image057.png&quot; alt=&quot;block 框&quot;&gt;&lt;/p&gt;
                &lt;p&gt;inline 框：没有自己的 block，但是位于容器 block 内。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image059.png&quot; alt=&quot;inline 框&quot;&gt;&lt;/p&gt;
                &lt;p&gt;block 采用的是一个接一个的垂直格式，而 inline 采用的是水平格式。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image061.png&quot; alt=&quot;block 和 inline 格式&quot;&gt;&lt;/p&gt;
                &lt;p&gt;inline 框放置在行中或“行框”中。这些行至少和最高的框一样高，还可以更高，当框根据“底线”对齐时，这意味着元素的底部需要根据其他框中非底部的位置对齐。如果容器的宽度不够，inline 元素就会分为多行放置。在段落中经常发生这种情况。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image063.png&quot; alt=&quot;行&quot;&gt;&lt;/p&gt;
                &lt;h5 id=&quot;定位&quot;&gt;&lt;a href=&quot;#定位&quot; class=&quot;headerlink&quot; title=&quot;定位&quot;&gt;&lt;/a&gt;定位&lt;/h5&gt;
                &lt;p&gt;&lt;strong&gt;相对&lt;/strong&gt;&lt;br&gt;相对定位：先按照普通方式定位，然后根据所需偏移量进行移动。&lt;br&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image065.png&quot; alt=&quot;相对定位&quot;&gt;&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;浮动&lt;/strong&gt;&lt;br&gt;浮动框会移动到行的左边或右边。有趣的特征在于，其他框会浮动在它的周围。下面这段 HTML 代码：&lt;/p&gt;
                &lt;figure class=&quot;highlight html&quot;&gt;
                  &lt;table&gt;
                    &lt;tr&gt;
                      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;float:right&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;images/image.gif&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;width&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;100&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;height&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;100&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Lorem ipsum dolor sit amet, consectetuer...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                    &lt;/tr&gt;
                  &lt;/table&gt;
                &lt;/figure&gt;
                &lt;p&gt;显示效果如下：&lt;/p&gt;
                &lt;p&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image067.png&quot; alt=&quot;浮动&quot;&gt;&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;绝对定位和固定定位&lt;/strong&gt;&lt;br&gt;这种布局是准确定义的，与普通流无关。元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。&lt;/p&gt;
                &lt;p&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image069.png&quot; alt=&quot;固定定位&quot;&gt;&lt;/p&gt;
                &lt;p&gt;请注意，即使在文档滚动时，固定框也不会移动。&lt;/p&gt;
                &lt;h5 id=&quot;分层展示&quot;&gt;&lt;a href=&quot;#分层展示&quot; class=&quot;headerlink&quot; title=&quot;分层展示&quot;&gt;&lt;/a&gt;分层展示&lt;/h5&gt;
                &lt;p&gt;这是由 z-index CSS 属性指定的。它代表了框的第三个维度，也就是沿“z 轴”方向的位置。&lt;/p&gt;
                &lt;p&gt;这些框分散到多个堆栈（称为堆栈上下文）中。在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。&lt;br&gt;堆栈是按照 z-index 属性进行排序的。具有“z-index”属性的框形成了本地堆栈。视口具有外部堆栈。&lt;/p&gt;
                &lt;p&gt;示例：&lt;/p&gt;
                &lt;figure class=&quot;highlight html&quot;&gt;
                  &lt;table&gt;
                    &lt;tr&gt;
                      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;style&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;css&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;selector-tag&quot;&gt;div&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;position&lt;/span&gt;: absolute;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;left&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2in&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;top&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2in&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;z-index: 3;background-color:red; width: 1in; height: 1in; &quot;&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;attr&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;z-index: 1;background-color:green;width: 2in; height: 2in;&quot;&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
                    &lt;/tr&gt;
                  &lt;/table&gt;
                &lt;/figure&gt;
                &lt;p&gt;结果如下：&lt;/p&gt;
                &lt;p&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/image071.png&quot; alt=&quot;固定定位&quot;&gt;&lt;/p&gt;
                &lt;p&gt;虽然红色 div 在标记中的位置比绿色 div 靠前（按理应该在常规流程中优先绘制），但是 z-index 属性的优先级更高，因此它移动到了根框所保持的堆栈中更靠前的位置。&lt;/p&gt;
                &lt;p&gt;原文出自：&lt;br&gt;&lt;a href=&quot;http://taligarsiel.com/Projects/howbrowserswork1.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://taligarsiel.com/Projects/howbrowserswork1.htm&lt;/a&gt;&lt;/p&gt;

          &lt;/html&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;我们要讨论的浏览器&quot;&gt;&lt;a href=&quot;#我们要讨论的浏览器&quot; class=&quot;headerlink&quot; title=&quot;我们要讨论的浏览器&quot;&gt;&lt;/a&gt;我们要讨论的浏览器&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;目前主流浏览器有五个：Internet Explorer、
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="翻译" scheme="http://xiaolin.site/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>数据库优化经验总结</title>
    <link href="http://xiaolin.site/2016/04/30/db_optimization/"/>
    <id>http://xiaolin.site/2016/04/30/db_optimization/</id>
    <published>2016-04-30T02:14:29.000Z</published>
    <updated>2016-06-11T09:27:03.564Z</updated>
    
    <content type="html">&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;首先应考虑在 where 及 order by 涉及的列上建立索引以尽量避免全表扫描&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;应尽量避免在 where 子句中对字段进行 null 值判断&lt;/strong&gt;，否则将导致引擎放弃使用索引而进行全表扫描，如：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库。备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，当然如果是varchar这样的变长字段，null 不占用空间。&lt;br&gt;&amp;emsp;&amp;emsp;可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
  &lt;/figure&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;应尽量避免在 where 子句中使用 != 或 &amp;lt;&amp;gt; 操作符&lt;/strong&gt;，否则查询引擎将放弃使用索引而进行全表扫描。&lt;/li&gt;
  &lt;/ul&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;应尽量避免在 where 子句中使用 or 来连接条件，可以用union替代&lt;/strong&gt;，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：&lt;/li&gt;
  &lt;/ul&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Name&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&#39;admin&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;可以这样查询：&lt;/p&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; all&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Name&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&#39;admin&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;in 和 not in 也要慎用&lt;/strong&gt;，否则会导致全表扫描，如：&lt;/li&gt;
  &lt;/ul&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;对于连续的数值，能用 between 就不要用 in 了&lt;/strong&gt;：&lt;/li&gt;
  &lt;/ul&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;很多时候用 exists 代替 in 是一个好的选择&lt;/strong&gt;：&lt;/li&gt;
  &lt;/ul&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; b)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;可以用下面的语句替换：&lt;/p&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;exists&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; b &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt;=a.num)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;尽可能地用全文检索替代Like模糊查询，以避免低效的全表扫描&lt;/strong&gt;：&lt;/li&gt;
  &lt;/ul&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;%abc%&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;如果在 where 子句中使用参数，也会导致全表扫描&lt;/strong&gt;。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：&lt;/li&gt;
  &lt;/ul&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; = @&lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;可以改为强制查询使用索引：&lt;/p&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;(索引名)) &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; = @&lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;应尽量避免在where子句中对字段进行函数、算数运算或表达式操作&lt;/strong&gt;，否则系统将可能无法正确使用索引而进行全表扫描。如：&lt;/li&gt;
  &lt;/ul&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) = &lt;span class=&quot;string&quot;&gt;&#39;abc&#39;&lt;/span&gt;       -–&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;以abc开头的&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;datediff&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;day&lt;/span&gt;,createdate,&lt;span class=&quot;string&quot;&gt;&#39;2005-11-30&#39;&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;p&gt;应改为:&lt;/p&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;abc%&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; createdate &amp;gt;= &lt;span class=&quot;string&quot;&gt;&#39;2005-11-30&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; createdate &amp;lt; &lt;span class=&quot;string&quot;&gt;&#39;2005-12-1&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;根据&lt;strong&gt;索引的前缀匹配原则&lt;/strong&gt;，在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;Update语句，如果只更改1、2个字段，不要Update全部字段&lt;/strong&gt;，否则频繁调用会引起明显的性能消耗，同时带来大量日志。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;对于多张大数据量（这里几百条就算大了）的表JOIN，要&lt;strong&gt;先分页再JOIN&lt;/strong&gt;，否则逻辑读会很高，性能很差。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;select count(*) from table；这样&lt;strong&gt;不带任何条件的count会引起全表扫描&lt;/strong&gt;，并且没有任何业务意义，是一定要杜绝的。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;索引并不是越多越好&lt;/strong&gt;，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;应尽可能的避免更新 clustered 索引数据列&lt;/strong&gt;，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销&lt;/strong&gt;。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;尽可能的使用 varchar/nvarchar 代替 char/nchar &lt;/strong&gt;，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;任何地方都不要使用 select * from t ，用具体的字段列表代替*&lt;/strong&gt;，不要返回用不到的任何字段。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;拆分大的 DELETE 或INSERT 语句，批量提交SQL语句&lt;/strong&gt;。如果你需要在一个在线的网站上去执行一个大的DELETE或INSERT查询，你需要非常小心，要避免你的操作让你的整个网站停止响应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你的WEB服务崩溃，还可能会让你的整台服务器马上挂了。所以，如果你有一个很瞬间很大的处理请求，你一定把其拆分。（建议使用消息队列）&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;figure class=&quot;highlight sql&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;logs&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; log_date &amp;lt;= ’&lt;span class=&quot;number&quot;&gt;2012&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-11&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-01&lt;/span&gt;’ &lt;span class=&quot;keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;-- 每次只删除1000条&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;首先应考虑在 where 及 order by 涉及的列上建立索引以尽量避免全表扫描&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;应尽量避免在 where 子句中对字段进行 null
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="http://xiaolin.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>全栈工程师的价值</title>
    <link href="http://xiaolin.site/2016/04/30/full_stack/"/>
    <id>http://xiaolin.site/2016/04/30/full_stack/</id>
    <published>2016-04-30T02:14:29.000Z</published>
    <updated>2016-05-28T16:08:39.596Z</updated>
    
    <content type="html">&lt;p&gt;&amp;emsp;&amp;emsp;之前看网上有个新闻说“Facebook只招全栈工程师”，闻之比较诧异。因为全栈工程师在我工作的圈子里，大家普遍对其的评价并不高，很多时候只是茶余饭后用来调侃的对象。网上甚至有段子说全栈工程师就是懂系统、懂网络、懂研发、懂数据库、还懂架构、就是没有女朋友的屌丝战斗机。突然觉得自己也被黑了，所以忍不住站出来，替全栈工程师们说句公道话。&lt;/p&gt;
&lt;h4 id=&quot;什么样才算是全栈&quot;&gt;&lt;a href=&quot;#什么样才算是全栈&quot; class=&quot;headerlink&quot; title=&quot;什么样才算是全栈&quot;&gt;&lt;/a&gt;什么样才算是全栈&lt;/h4&gt;
&lt;p&gt;有的人说是精通前端，精通后端，又精通一个产品从设计到上线的全过程&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;按照这个标准，地球上估计已经找不出几个人了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有的人说是懂前端，懂后端&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;按照这个标准，我估计大部分目前做后端都可以称为“全栈工程师”了，毕竟哪个写后台的一个页面都没写过啊？大部分目前做app的也可以算“全栈工程师”，毕竟哪个做app的完全不知道后端怎么写啊？ 但如果这就是“全栈工程师”了，我未免觉得全栈工程师都滥大街了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;所以，如何定义“全栈工程师”就是一个很难的问题。我个人倾向于所谓的“全栈工程师”，应该是“精某端，懂另外一端”，“精”自然就是精通，能够游刃有余，熟悉各种机制；“懂”就是知道怎么一回事，知道能够完成什么工作，知道常见的功能如何完成。&lt;/p&gt;
&lt;h4 id=&quot;全栈工程师与专家的区别和联系&quot;&gt;&lt;a href=&quot;#全栈工程师与专家的区别和联系&quot; class=&quot;headerlink&quot; title=&quot;全栈工程师与专家的区别和联系&quot;&gt;&lt;/a&gt;全栈工程师与专家的区别和联系&lt;/h4&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;有人做过一个很有意思的研究就是如果依赖于20/80法则的话，那么成为专家和全栈的学习时间是相当的。在最开始的时候，我们要在我们的全栈工程和专家都在某个技术领域达到80分的水平。那么专家，还需要80%的时间去深入这个技术领域。而全栈工程师，则可以依赖于这80%的时候去开拓四个新的领域：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/expert-vs-fullstack.png&quot; alt=&quot;expert-vs-fullstack.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;到了一定程度，越往上走每提升一步所花费的代价就往往会更大。我们熟悉某件事物只需要花费我们20%的时间和精力，而为了达到精通，我们则需要花费另外80%的努力。对于编程特别是如此，全栈工程师就是那掌握20%常用技能的人，但这20%的技能会有80%的几率被用到，剩下那80%不常用的直接Google就好了。而专家则是要求尽可能在这一纵深领域达到100%的透彻，难度可想而知。&lt;br&gt;&amp;emsp;&amp;emsp;另外，现在很多专家们也在强调“一专多长”。因为单纯依靠于一个领域的技术而存在的专家已经很少了，技术专家们不得不依据于公司的需求去开拓不同的领域。毕竟公司是以盈利为目的而设立的一种组织形式，所以很多时候专家也是身不由己地需要学习很多自己领域之外的东西。&lt;/p&gt;
&lt;h4 id=&quot;全栈工程师的价值&quot;&gt;
  &lt;a href=&quot;#全栈工程师的价值&quot; class=&quot;headerlink&quot; title=&quot;全栈工程师的价值&quot;&gt;&lt;/a&gt;全栈工程师的价值&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;有人可能会说，你再能牛逼，你一个人能干10个人的活么？要知道现在一个真正的商业级应用往往是非常复杂的，会涉及到很多模块，设计、编码、测试、上线的各个环节都很复杂，所以这时分工合作就显得特别重要。很多大公司在这些环节上岗位划分非常之细，导致人浮于事的情况经常发生，导致做软件这种高大上技术活在他们那里已经沦落成了简单的钉螺丝的人海战术了。这个时候再谈全栈不是一种历史的倒退吗？&lt;br&gt;&amp;emsp;&amp;emsp;这里我要澄清的是首先我绝不反对分工明确的这种现代常见的软件开发模式，我说的是全栈工程师的价值不在于分工合作的狭窄领域，而在于全局思维、灵活性、快速反映上。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;全局性思维&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;现代项目的开发，很少说只用到一两种技术的，特别是移动互联网大潮下。随便一个互联网项目中用到的技术，就会需要用到后端开发、前端开发、界面设计、产品设计、数据库、各种移动客户端、三屏兼容、RestFul API设计和OAuth权限等等，一些比较前卫的项目，可能会用到Single Page Application、Web Socket、HTML5/CSS3这些技术，还有第三方应用平台开发，像微信公众号、微博应用等等。&lt;br&gt;Web前端也远远不是从前的切个图用个jQuery上个AJAX兼容各种浏览器那么简单了。现代的Web前端，你需要用到模块化开发、多屏兼容、MVC，各种复杂的交互与优化，甚至你需要用到Node.js来协助前端的开发。&lt;br&gt;所以说一个现代化的项目，是一个非常复杂的构成，我们需要一个人来掌控全局，他不需要是各种技术的资深专家，但他需要熟悉到各种技术。对于一个团队特别是互联网企业来说，有一个全局性思维的人是非常非常重要的。&lt;br&gt;像如果是我经手的项目，我肯定会注意到网页优化，也会考虑到API来兼容各种客户端，更会考虑到三屏兼容的问题。不会说项目中完全使用AJAX而不顾SEO，也不会为了功能性而忽略访问速度，我会很好的把握这个平衡，因为我知道它们的权重与实现成本。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;沟通成本&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;项目越大，沟通成本越高，做过项目管理的人都知道，项目中的人力是1+1&amp;lt;2的，人越多效率越低。因为沟通是需要成本的，不同技术的人各说各话，前端和后端是一定会掐架的。每个人都会为自己的利益而战，毫不为已的人是不存在的。&lt;br&gt;而全栈工程师的成本几乎为零，因为各种技术都懂，胸有成竹，一不小心自己就全做了。即使是在团队协作中，与不同技术人员的沟通也会容易得多，你让一个后端和一个前端去沟通，那完全是鸡同鸭讲，更不用说设计师与后端了。但如果有一个人懂产品懂设计懂前端懂后端，那沟通的结果显然不一样，因为他们讲的，彼此都能听得懂。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;创业公司&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;对于创业公司来说，全端工程师的价值是非常大的，创业公司不可能像大公司一样，各方面的人才都有。所以我们需要一个多面手，各种活都能一肩挑，独挡多面的万金油。对于创业公司，不可能说DBA前端后端客户端各种人才全都备齐了，很多工作请人又不饱和，不请人又没法做，外包又不放心质量，所以全端工程师是省钱的一妙招。虽然说全端工程师工资会比一般的工程师会高很多，但综合下来，成本会低很多。&lt;/p&gt;
  &lt;h4 id=&quot;全栈工程师的未来&quot;&gt;&lt;a href=&quot;#全栈工程师的未来&quot; class=&quot;headerlink&quot; title=&quot;全栈工程师的未来&quot;&gt;&lt;/a&gt;全栈工程师的未来&lt;/h4&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;技术在过去的几十年里进步很快，也将在未来的几十年里发展得更快。今天技术的门槛下降得越来越快，原本需要一个团队做出来的Web应用，现在只需要一两个人就可以了。同时，由于公司组织结构的变迁，技术的升级换代，外部市场环境的变化，也决定了每个开发者都不可能抱守自己的一片小天地就安安稳稳地活下去，要学的东西将会越来越多。所以尽管我们看到工厂化精细化分工所带来的优势，也应该看到精益思想带来的变革。正是这种变革让越来越多的专家走向全栈，让组织内部有更好的交流。&lt;br&gt;&amp;emsp;&amp;emsp;优秀的全栈工程师本身不应该仅仅局限于前端和后台的开发，而应该去&lt;strong&gt;尝试开拓更广泛的领域&lt;/strong&gt;——因为全栈本身依赖于工程师强大的学习能力，而这种优秀的学习能力也可以让他们应用到更广泛的领域中去。&lt;br&gt;&amp;emsp;&amp;emsp;很多优秀的全栈工程师本身也是公司的技术领导，除了保证技术上没有致命的短板外，还应该培养自己的&lt;strong&gt;产品思维&lt;/strong&gt;。在国内，产品经理是非常核心的角色，然而在硅谷，工程师才是灵魂，拥有产品设计的决策权。你如果招到了好的工程师，而这些工程师有好的产品思维，你的公司组织就精简了，会议沟通就少了，效率就随之提高了。&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;小团队大杠杆&lt;br&gt;工程师常常兼具产品思维&lt;br&gt;产品经理同时开发多个项目&lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;&amp;emsp;&amp;emsp;传统的大公司们都是这么做的：每个工程师会负责固定的一些系统，每个系统都有明确的界限。这里面有一个很大的问题：假如有新的优秀人才加入，他有一些很好的想法想更新一些东西，他就必须说服每个系统的负责人，这个沟通要花很多时间，也非常困难。而现在有一种更好的全栈式代码管理方式，Facebook就是这样做的：所有人轮岗，任何人都可能成为任何系统的专家，任何一个人都能够对任何一个系统提出更好的框架和方法。你以前改变一个产品，需要把每个系统的人叫来，但是全栈式管理，让三五个全栈工程师，就能把这10个系统全改了，然后推出产品，这是自组织的代码管理方式，而我相信这也将是未来中国互联网软件开发的主流方式之一。&lt;br&gt;&amp;emsp;&amp;emsp;时代在进步，社会在发展。作为软件工程师的我们也要与时俱进，寻找最适合自己发展的道路。专家
    OR 全栈？你的选择是什么？&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前看网上有个新闻说“Facebook只招全栈工程师”，闻之比较诧异。因为全栈工程师在我工作的圈子里，大家普遍对其的评价并不高，很多时候只是茶余饭后用来调侃的对象。网上甚至有段子说全栈工程师就是懂系统、懂网络、懂研发、懂数据库、还懂架构、就是没有女朋
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="全栈" scheme="http://xiaolin.site/tags/%E5%85%A8%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>记一次开源爬虫crawler4j的应用</title>
    <link href="http://xiaolin.site/2016/04/24/use_crawler4j/"/>
    <id>http://xiaolin.site/2016/04/24/use_crawler4j/</id>
    <published>2016-04-24T14:17:00.000Z</published>
    <updated>2016-05-01T07:23:29.909Z</updated>
    
    <content type="html">&lt;p&gt;crawler4j是一个开源的Java爬虫框架，通过使用其简单的接口就可以实现网站资源的多线程爬取。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;使用起来非常简单：&lt;/p&gt;
&lt;p&gt;只需要在Java项目的pom文件中添加以下片段即可：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;edu.uci.ics&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;crawler4j&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;4.2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;以下是我使用crawler4j爬取我&lt;a href=&quot;http://www.petrosoftware-class.com&quot; title=&quot;石油软件班&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;石油软件班&lt;/a&gt;历届帅哥美女们头像的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String rootFolder = &lt;span class=&quot;string&quot;&gt;&quot;d:/data2&quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//设置初始化目录&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numberOfCrawlers = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//设置爬虫的数量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String storageFolder = &lt;span class=&quot;string&quot;&gt;&quot;d:/data2/img2&quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//设置图片的存储路径&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CrawlConfig config = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CrawlConfig();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;config.setCrawlStorageFolder(rootFolder);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;config.setPolitenessDelay(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//设置每次爬取时间间隔&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * Since images are binary content, we need to set this parameter to&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * true to make sure they are included in the crawl.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;config.setIncludeBinaryContentInCrawling(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;config.setUserAgentString(&lt;span class=&quot;string&quot;&gt;&quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:41.0) Gecko/20100101 Firefox/41.0&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//https://www.zhihu.com/question/28521492&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//http://www.petrosoftware-class.com/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String[] crawlDomains = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;http://www.petrosoftware-class.com/&quot;&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PageFetcher pageFetcher = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PageFetcher(config);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RobotstxtConfig robotstxtConfig = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RobotstxtConfig();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RobotstxtServer robotstxtServer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RobotstxtServer(robotstxtConfig, pageFetcher);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CrawlController controller = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CrawlController(config, pageFetcher, robotstxtServer);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String domain : crawlDomains) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  controller.addSeed(domain);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ImageCrawler.configure(crawlDomains, storageFolder);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;controller.start(ImageCrawler.class, numberOfCrawlers);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o6fmcea8z.bkt.clouddn.com/blog/image/classmates.jpg&quot; alt=&quot;classmates.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;爬虫的原理&quot;&gt;&lt;a href=&quot;#爬虫的原理&quot; class=&quot;headerlink&quot; title=&quot;爬虫的原理&quot;&gt;&lt;/a&gt;爬虫的原理&lt;/h3&gt;
&lt;p&gt;1）首先你要明白爬虫怎样工作&lt;/p&gt;
&lt;p&gt;想象你是一只蜘蛛，现在你被放到了互联“网”上。那么，你需要把所有的网页都看一遍。怎么办呢？没问题呀，你就随便从某个地方开始，比如说人民日报的首页，这个叫initial pages，用$表示吧。&lt;/p&gt;
&lt;p&gt;在人民日报的首页，你看到那个页面引向的各种链接。于是你很开心地从爬到了“国内新闻”那个页面。太好了，这样你就已经爬完了俩页面（首页和国内新闻）！暂且不用管爬下来的页面怎么处理的，你就想象你把这个页面完完整整抄成了个html放到了你身上。&lt;/p&gt;
&lt;p&gt;突然你发现， 在国内新闻这个页面上，有一个链接链回“首页”。作为一只聪明的蜘蛛，你肯定知道你不用爬回去的吧，因为你已经看过了啊。所以，你需要用你的脑子，存下你已经看过的页面地址。这样，每次看到一个可能需要爬的新链接，你就先查查你脑子里是不是已经去过这个页面地址。如果去过，那就别去了。&lt;/p&gt;
&lt;p&gt;好的，理论上如果所有的页面可以从initial page达到的话，那么可以证明你一定可以爬完所有的网页。&lt;/p&gt;
&lt;p&gt;2）效率&lt;br&gt;如果你就这样爬的话，你会发现要爬的网页实在太多了。设想全网有N个网站，那么分析一下判重的复杂度就是N*log(N)，因为所有网页要遍历一次，而每次判重用set的话需要log(N)的复杂度。通常的判重做法是怎样呢？Bloom Filter. 简单讲它仍然是一种hash的方法，但是它的特点是，它可以使用固定的内存（不随url的数量而增长）以O(1)的效率判定url是否已经在set中。可惜天下没有白吃的午餐，它的唯一问题在于，如果这个url不在set中，BF可以100%确定这个url没有看过。但是如果这个url在set中，它会告诉你：这个url应该已经出现过，不过我有2%的不确定性。注意这里的不确定性在你分配的内存足够大的时候，可以变得很小很少。一个简单的教程:
  &lt;a href=&quot;http%3A//billmill.org/bloomfilter-tutorial/&quot; title=&quot;Bloom Filters by Example&quot;&gt;Bloom Filters by Example&lt;/a&gt;好，现在已经接近处理判重最快的方法了。另外一个瓶颈——你只有一台机器。不管你的带宽有多大，只要你的机器下载网页的速度是瓶颈的话，那么你只有加快这个速度。用一台机子不够的话——用很多台吧！当然，我们假设每台机子都已经进了最大的效率——使用多线程.&lt;/p&gt;
&lt;p&gt;3）集群化抓取&lt;/p&gt;
&lt;p&gt;据统计2013年豆瓣的page量已经达到了几百万个，如果用100多台机器昼夜不停地运行，那么需要一个月时间左右才能爬完。想象如果只用一台机子你就得运行100个月了…&lt;/p&gt;
&lt;p&gt;那么，假设你现在有100台机器可以用，怎么实现一个分布式的爬取算法呢？&lt;/p&gt;
&lt;p&gt;我们把这100台中的99台运算能力较小的机器叫作slave，另外一台较大的机器叫作master，那么回顾上面代码中的url_queue，如果我们能把这个queue放到这台master机器上，所有的slave都可以通过网络跟master联通，每当一个slave完成下载一个网页，就向master请求一个新的网页来抓取。而每次slave新抓到一个网页，就把这个网页上所有的链接送到master的queue里去。同样，bloom filter也放到master上，但是现在master只发送确定没有被访问过的url给slave。Bloom
  Filter放到master的内存里，而被访问过的url放到运行在master上的Redis里，这样保证所有操作都是O(1)。（至少平摊是O(1)，Redis的访问效率见:&lt;a href=&quot;http%3A//redis.io/commands/linsert&quot; title=&quot;LINSERT – Redis&quot;&gt;LINSERT – Redis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4）展望及后续处理&lt;/p&gt;
&lt;p&gt;虽然上面用很多“简单”，但是真正要实现一个商业规模可用的爬虫并不是一件容易的事。上面的代码用来爬一个整体的网站几乎没有太大的问题。&lt;/p&gt;
&lt;p&gt;但是如果附加上你需要这些后续处理，比如&lt;/p&gt;
&lt;p&gt;有效地存储（数据库应该怎样安排）&lt;/p&gt;
&lt;p&gt;有效地判重（这里指网页判重，咱可不想把人民日报和抄袭它的大民日报都爬一遍）&lt;/p&gt;
&lt;p&gt;有效地信息抽取（比如怎么样抽取出网页上所有的地址抽取出来，“朝阳区奋进路中华道”），搜索引擎通常不需要存储所有的信息，比如图片我存来干嘛…&lt;/p&gt;
&lt;p&gt;及时更新（预测这个网页多久会更新一次）&lt;/p&gt;
&lt;p&gt;如你所想，这里每一个点都可以供很多研究者十数年的研究。虽然如此，&lt;br&gt;“路漫漫其修远兮,吾将上下而求索”。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;crawler4j是一个开源的Java爬虫框架，通过使用其简单的接口就可以实现网站资源的多线程爬取。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://xiaolin.site/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="爬虫" scheme="http://xiaolin.site/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>忍受简单的能力</title>
    <link href="http://xiaolin.site/2016/01/15/be_simple/"/>
    <id>http://xiaolin.site/2016/01/15/be_simple/</id>
    <published>2016-01-15T14:17:29.000Z</published>
    <updated>2016-07-18T07:35:21.291Z</updated>
    
    <content type="html">&lt;blockquote&gt;
  &lt;p&gt;其实想要过好一生并没有什么特别复杂的道理，都是些简单的，但却难以坚持的东西。比如：坚持锻炼、坚持阅读、坚持自我更新每天进步一点点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;pre&gt;&lt;code&gt;对于聪明人来说，最难以忍受的情况不是一件事有多难，而是纯粹的简单。
没有难度挑战的任务，会让他们感到无所着力，继而注意力涣散，重复的练习是他们的死穴。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们向往不平凡的人生，向往随心所欲、无所不能、酣畅淋漓的人生的体验，这固然不是错，这确实是人类的本性，永远对自己的生活抱有更高的期望，也是人类不断进步的原动力。但是，平平淡淡很多时候确实才是生活的本质，而且很多时候恐怕你也不得不承认其实你并不比你身边的人太强到哪里去，你也不是小时候那个自以为自己长大以后无所不能的超人，所以往往面对生活的不完美，你也只能选择默默忍受着。假如你问一下自己一年365天，是平平淡淡的日子多还是惊心动魄的日子多，那么我想你的答案一定是前者，至于平平淡淡的日子到底比惊心动魄的日子多多少，这恐怕你比我更心知肚明。很多时候，恰恰是这些看似平平淡淡的日子充实着我们的人生，所以要如何面对这大量的平平淡淡的一天，是我们每一个平凡的人都要认真考虑的问题。&lt;/p&gt;
&lt;p&gt;你是抱怨还是默默忍受并积蓄力量？你是乐观还是悲观？你是每天坚持进步每天改善一点点还是得过且过逐渐迷失自我？人生就是不完美的，这是一个伟大的真理。面对问题、面对平凡，你会感觉到痛苦、苦闷；然而认识到这一点并接受事实才是我们心智成熟的第一步。第一步走好了，往后就好走了，至少走起来痛苦也会比原来减轻一些。&lt;/p&gt;
&lt;p&gt;认清事实并坦然接受是第一步，第二步更重要的则是学会在平淡的日子里保持耐心，踏踏实实地走好自己该走的路。而这往往很难，说难并不是说这事需要很大的智力、体力、财力或物力，而是说我们需要能够忍受目前平淡的生活，默默忍受着目前生活的不完美之处，并踏踏实实做好自己该做的事，积蓄养分，不断成长，强化自己的力量。&lt;/p&gt;
&lt;p&gt;在这个过程中，我曾看到很多聪明人，他们确实真切地感受到了生活的平淡与不完美，也很快知道自己需要做什么来改变现状，但却往往非常可惜的是，他们缺少耐心。是的，他们的大脑往往运转速度很快，但因为脑子太快了，所以需要身体下工夫的地方，往往就有种种困难。锻炼身体时，他们往往会想：[这样跑步真的有用吗？]、[有没有什么速成的锻炼方法，能够不这样枯燥乏味？]，想法多、脑子转的快本身没有错，错的是思维上的变化多端，往往就造成了行动层面的进步迟缓。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过日常的生活观察我发现真正最影响一个人的成就的因素，可能不是智商，也不是努力，而在于他有多踏实。&lt;/strong&gt;踏实的人做一件事，是一件事；学一样东西，就学得到一样东西。你只要看一门课最开始的时候，讲一些最简单的知识，哪些人可以不厌其烦地听进去，他们未来就算没有什么惊人的成就，也都不会混得太差。而聪明人往往已失去了耐心，都趴在桌子上睡觉。还记得我高中的一同桌，现在想想其实也不是一个聪明、特别厉害的人，每次数学最后一个大题他基本都做不出来，而我则隔三差五地还能碰对。然而他的成绩却每次都比我好，总是在年级前两百，从未掉过队。后来也是顺利地考上了牛叉的华中科技大学，比我强多了。我后来分析，他的成功很大程度上来源于他的踏实程度，他会把每一道错题认真记载，时常复习，每天做一套模拟卷子，雷打不动，这些都是当时年轻的我不曾有过的踏实。&lt;/p&gt;
&lt;p&gt;所以，对一个学习者来说，这是最好的时代，也是最坏的时代。今天的信息不是匮乏而是整个地泛滥了，你知道自己生活的不完美，但你很难让自己真的不去焦虑。为了克服这种焦虑，摆脱心中的弱小感，我们经常逼迫自己学习这样或那样的东西。我们看到要学的东西越之多，便感觉自己越渺小。越渺小便越不能忍受目前自己正在学习的平淡的，相比渺小的东西，便越是焦虑不安，越是无法脚踏实地，一点点地不断进步，不断突破。&lt;br&gt;所以，如果真的想学一点东西，就需要一种特别的能力。我把它叫做「&lt;strong&gt;忍受简单的能力&lt;/strong&gt;」。我不知道是叫能力还是勇气更好，因为它涉及到了一种真正意义上的放弃。——当你在某一个点上停下来，打算认真下点工夫的时候，这意味着放弃想象中的其它可能。你得到的可能只是简单的一点点，面对却是巨大的不确定性，这或许也是一种勇气吧。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
  &lt;p&gt;其实想要过好一生并没有什么特别复杂的道理，都是些简单的，但却难以坚持的东西。比如：坚持锻炼、坚持阅读、坚持自我更新每天进步一点点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://xiaolin.site/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="习惯养成" scheme="http://xiaolin.site/tags/%E4%B9%A0%E6%83%AF%E5%85%BB%E6%88%90/"/>
    
  </entry>
  
</feed>
