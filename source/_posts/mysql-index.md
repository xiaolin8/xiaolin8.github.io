---
title: mysql索引学习笔记
date: 2016-09-30 10:26:32
categories: 技术
tags: mysql
---

索引优化应该是对查询优化最有效的手段了。索引能轻易将查询性能提高几个数量级，所以，了解MySQL索引的原理对于优化数据库的查询性能至关重要。

<!--more-->

##### 索引基础
MySQL索引可以类比于一本书的目录或索引部分，你可以通过已经排序好的关键字直接找到特定记录所在的位置，而不用进行全表扫描。也就是说MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。

索引的优点:
1. 索引大大减少了服务器需要扫描的数据量；
2. 索引可以帮助服务器避免排序和临时表；
3. 索引可以将随机IO变为顺序IO；

##### 索引的类型
在MySQL中，索引是在存储引擎层实现的，不同存储引擎支持不同类型的索引，即使是多个存储引擎支持相同类型的索引，其底层实现也可能不同。在这里主要谈谈使用最广泛的InnoDB引擎的实现原理。

> 为什么索引要使用B-Tree来实现呢？
> 考虑到磁盘IO操作是个很昂贵的操作（特别是机械磁盘），因此我们要尽量减少磁盘IO操作，于是B+树就这样应运而生。

**B-Tree索引**

B-Tree通常意味着所有的值都是顺序存储的，并且每一个叶子页到根的距离相同。
![B-Tree](http://i.imgur.com/R2peify.png)

如图所示，根节点中存放了指向子节点的指针，而叶子节点比较特殊，它们的指针指向的是被索引的数据。

![B-Tree](http://tech.meituan.com/img/mysql_index/btree.jpg)

如上图，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。<u>非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项</u>，如17、35并不真实存在于数据表中。

>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。
每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
综上所述，用B-Tree作为索引结构效率是非常高的。
而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

**b+树的查找过程**

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。


**b+树性质**

1.通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。


2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

##### 索引的最左前缀匹配原则
请注意，B-Tree联合索引的排序是CREATE TABLE时定义索引的列的顺序，假设有定义索引key(last_name,name,age)，那么索引会先按last_name排序，再次按name排序，最后按age排序。
根据B-Tree联合索引的这一性质导致了我们使用索引的时候需要注意“<font color="red">索引的最左前缀匹配原则</font>”。关于这一原则的具体描述：
- 如果不是按索引的最左列开始查找，则MySQL无法使用索引；
- 不能跳过索引的列；
- 如果查询中有某个列的范围查询（BETWEEN、LIKE），则其右边所有列都无法使用索引优化查找。如果范围查询的列值数量有限，那么可以通过IN关键字来代替范围条件；

##### 如何评价一个索引的好坏
三星系统：
- 索引将相关记录放到一起则获得一星；
- 如果索引中的数据顺序与查找中的排列顺序一致则获得二星；
- 如果索引中的列包含了查询中所需要的全部列则获得三星；

##### 高性能的索引策略

**独立的列**

如果查询中的列不是独立的，那么MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。例如：

```sql
SELECT id FROM actor WHERE actor_id + 1 = 5;
```

我们应该养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。

**前缀索引和索引选择性**

如果索引很长的字符列，这会让索引变得大且慢，那么就可以索引列开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性，索引的选择性是指不重复的索引值（也称基数，cardinality）和数据表的记录总数（#T）之间的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为可以过滤过更多的行。
所以最佳实践是选择足够长的索引以保证较高的选择性，但同时不能太长以提升查询性能。

注意：前缀索引虽然是使得索引更小、更有效的办法，但是也有其缺点：MySQL无法使用前缀索引做ORDER BY、GROUP BY和覆盖扫描。

**多列索引**

一种常见的错误就是为每个列单独创建索引，或者按照错误的顺序创建多列索引，例如“把WHERE条件里的列都加上索引”实际上这种建议是非常错误的经验法则。这样一来最好的情况下也只能是“一星索引”，其性能比起真正最优的索引可能差几个数量级。

**选择合适的索引列顺序**

正确的顺序依赖于使用该索引的查询，并且需要同时考虑如何更好地满足排序和分组的需要。在一个B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列等等。所以，索引可以按照升序或者降序进行扫描，以精确满足符合列顺序的ORDER　BY、GROUP BY和DISDINCT等子句的查询需求，所以多列索引的列的顺序至关重要。
对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引的最前面。这在不考虑排序和分组时确实不错。然而，性能不只是依赖于所有索引列的选择性，也和查询条件的值的分布有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序，让整体的查询效率最高。

##### 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一结构中保存了B-Tree索引和数据行。
当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在不同的两个地方，所以一个表只能有一个聚簇索引。

![clustering_table](http://i.imgur.com/z3B3qt0.png)

如图展示了聚簇索引中的记录是如何存放的。注意，叶子节点包含了行的全部数据，但是节点页中只包含了索引列。
InnoDB通过主键聚集数据，这也就是说图中“被索引的”列就是主键列。

聚簇索引的优点：
- 可以把相关数据保存在一起；
- 数据访问更快；
- 使用覆盖索引扫描的查询通常可以直接使用页节点中的主键值；

聚簇索引的缺点：
- 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表；
- 更新聚簇索引的代价很高，因为会将每个被更新的行移动到新的位置；
- 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。所谓“页分裂”是指如果当前页已满，那么存储引擎会将该页分裂为两个页面来容纳该行；

**在InnoDB表中按主键顺序插入行**

如果表中并没有什么数据需要聚集，那么可以定义一个代理键（surrogate key）作为主键，这种主键应该是业务无关的，最简单的就是使用AUTO_INCREMENT自增列。这样可以保证数据行按顺序写入，对于根据主键做关联操作的性能也会更好。

最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于IO密集型应用。例如，从性能的角度来考虑，使用UUID作为聚簇索引会很糟糕：它使得聚簇索引的插入变得完全随机，使得数据没有任何聚集特性。

##### 覆盖索引
如果一个索引中包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。

覆盖索引的好处：

- 索引条目通常远小于数据行的大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量；
- InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询；

##### 使用索引扫描来做排序
MySQL有两种方式可以生成有序的结果：通过排序或者索引扫描。如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序。
扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回表查询一次对应的行。这基本都是随机IO，因此按索引顺序读取数据的速度通常比顺序地全表扫描要慢，尤其是在IO密集型的工作负载时。
只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能使用索引来对结果做排序。如果查询需要关联多张表，则只有ORDER BY子句引用的字段全部为第一张表的时候才能使用索引做排序。

>有一种例外情况下ORDER BY可以不满足最左前缀匹配原则就是前导列为常量的时候，如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以弥补索引的不足——WHERE date = '2016-09-30' ORDER BY inventory_id,customer_id。

##### 冗余和重复索引
重复索引是指在相同的列上面按照相同的顺序创建相同类型的索引。应该避免这种重复，发现以后也应该立即去除。
冗余索引和重复索引有一些不同。如果创建了索引（A,B），再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引。但如果再创建索引（B,A）就不是冗余索引，索引B也不是。另外，其它不同类型的索引也不会是B-Tree索引的冗余索引，不论覆盖的索引是什么。

>大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。

总之，理解索引是如何工作的很重要，应该据此来创建最合适的索引，而不是根据一些诸如“在多列索引中将选择性最高的列放在第一列”或“应该为WHERE子句中出现的所有列创建索引”之类的经验法则及其推论。

##### 建索引的几大原则

1.	最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2.	=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式.
3.	尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录.
4.	索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
5.	
5.	尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

##### 查询优化神器 - explain命令
具体用法和字段含义可以参考官网[explain-output](http://dev.mysql.com/doc/refman/5.5/en/explain-output.html)，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。

##### 慢查询优化基本步骤

0.	先运行看看是否真的很慢，注意设置SQL_NO_CACHE；
1.	where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高；
2.	explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）；
3.	order by limit 形式的sql语句让排序的表优先查；
4.	了解业务方使用场景；
5.	加索引时参照建索引的几大原则；
6.	观察结果，不符合预期继续从0分析；

##### MyISAM索引实现
MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：
![](http://i.imgur.com/gtTVR90.png)
这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：
![](http://i.imgur.com/3cYtmoQ.png)
MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。


##### InnoDB索引实现
![二叉查找树](http://i.imgur.com/OH9ANrq.png)

二叉查找树虽然理论上查找速度比较快，但是考虑到操作系统读取数据的方式，实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的。

InnoDB的数据文件本身就是索引文件。在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：
![](http://i.imgur.com/skW3BDi.png)

聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。
了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，所以如果我们将where中的条件顺序颠倒，效果是一样的。
##### 索引选择性
一般两种情况下不建议建索引。
第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。
另一种不建议建索引的情况是索引的选择性较低。
前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index
##### InnoDB的主键选择与插入优化
在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。

> 参考文献
> 
1.	http://tech.meituan.com/mysql-index.html
2.	http://blog.codinglabs.org/articles/theory-of-mysql-index.html
2.	《高性能MySql》
