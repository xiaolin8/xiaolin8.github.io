<!doctype html>
<html class="theme-next pisces use-motion">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  <link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">
  <link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="java,">
  <link rel="alternate" href="/atom.xml" title="XiaoLin's Blog" type="application/atom+xml">
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">
  <meta name="description" content="垃圾回收是个什么鬼？
&amp;emsp;&amp;emsp;拥有自动垃圾回收机制可以说是Java与C++的一项显著区别。在C++语言中，程序员必须小心谨慎地处理每一项内存分配，且内存使用完后必须手工释放曾经占用的内存空间。当内存释放不够完全时，即存在分配但永不释放的内存块，就会引起内存泄漏，严重时甚至导致程序瘫痪，而java拥有自带的垃圾回收器可以自动释放没用的对象并清除内存记录碎片以减轻编程的负担。
垃圾回收">
  <meta property="og:type" content="article">
  <meta property="og:title" content="java基础拾遗——JVM垃圾回收原理">
  <meta property="og:url" content="http://xiaolin.site/2016/05/30/jvm/index.html">
  <meta property="og:site_name" content="XiaoLin's Blog">
  <meta property="og:description" content="垃圾回收是个什么鬼？
&amp;emsp;&amp;emsp;拥有自动垃圾回收机制可以说是Java与C++的一项显著区别。在C++语言中，程序员必须小心谨慎地处理每一项内存分配，且内存使用完后必须手工释放曾经占用的内存空间。当内存释放不够完全时，即存在分配但永不释放的内存块，就会引起内存泄漏，严重时甚至导致程序瘫痪，而java拥有自带的垃圾回收器可以自动释放没用的对象并清除内存记录碎片以减轻编程的负担。
垃圾回收">
  <meta property="og:updated_time" content="2016-07-18T07:33:51.997Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="java基础拾遗——JVM垃圾回收原理">
  <meta name="twitter:description" content="垃圾回收是个什么鬼？
&amp;emsp;&amp;emsp;拥有自动垃圾回收机制可以说是Java与C++的一项显著区别。在C++语言中，程序员必须小心谨慎地处理每一项内存分配，且内存使用完后必须手工释放曾经占用的内存空间。当内存释放不够完全时，即存在分配但永不释放的内存块，就会引起内存泄漏，严重时甚至导致程序瘫痪，而java拥有自带的垃圾回收器可以自动释放没用的对象并清除内存记录碎片以减轻编程的负担。
垃圾回收">
  <script type="text/javascript" id="hexo.configuration">
    var NexT = window.NexT || {},
      CONFIG = {
        scheme: "Pisces",
        sidebar: {
          position: "left",
          display: "post"
        },
        fancybox: !0,
        motion: !0,
        duoshuo: {
          userId: 0,
          author: "博主"
        }
      }
  </script>
  <link rel="canonical" href="http://xiaolin.site/2016/05/30/jvm/">
  <title>java基础拾遗——JVM垃圾回收原理 | XiaoLin's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container one-collumn sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
        <div class="site-meta">
          <div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">XiaoLin's Blog</span> <span class="logo-line-after"><i></i></span></a></div>
          <p class="site-subtitle">回首向来萧瑟处，归去，也无风雨也无晴</p>
        </div>
        <div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div>
        <nav class="site-nav">
          <ul id="menu" class="menu">
            <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li>
            <li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li>
            <li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li>
            <li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li>
            <li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            <div id="posts" class="posts-expand">
              <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
                <header class="post-header">
                  <h1 class="post-title" itemprop="name headline">java基础拾遗——JVM垃圾回收原理</h1>
                  <div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-05-30T16:20:10+08:00" content="2016-05-30">2016-05-30 </time></span>
                    <span
                      class="post-category">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span>                      </a>
                      </span>
                      </span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/05/30/jvm/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/05/30/jvm/" itemprop="commentsCount"></span> </a>
                      </span><span id="/2016/05/30/jvm/" class="leancloud_visitors" data-flag-title="java基础拾遗——JVM垃圾回收原理">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span>
                  </div>
                </header>
                <div class="post-body" itemprop="articleBody">
                  <h4 id="垃圾回收是个什么鬼？"><a href="#垃圾回收是个什么鬼？" class="headerlink" title="垃圾回收是个什么鬼？"></a>垃圾回收是个什么鬼？</h4>
                  <p>&emsp;&emsp;拥有自动垃圾回收机制可以说是Java与C++的一项显著区别。在C++语言中，程序员必须小心谨慎地处理每一项内存分配，且内存使用完后必须手工释放曾经占用的内存空间。当内存释放不够完全时，即存在分配但永不释放的内存块，就会引起内存泄漏，严重时甚至导致程序瘫痪，而java拥有自带的垃圾回收器可以自动释放没用的对象并清除内存记录碎片以减轻编程的负担。</p>
                  <h4 id="垃圾回收器常用的算法"><a href="#垃圾回收器常用的算法" class="headerlink" title="垃圾回收器常用的算法"></a>垃圾回收器常用的算法</h4>
                  <ul>
                    <li>
                      <p><strong>引用计数法 (Reference Counting)</strong><br>引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。<br>引用计数器的实现也非常简单，只需要为每个对象配置一个整形的计数器即可。但是引用计数器有一个严重的问题，即无法处理循环引用的情况。因此，在 Java 的垃圾回收器中没有使用这种算法。<br>一个简单的循环引用问题描述如下：有对象
                        A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</p>
                    </li>
                    <li>
                      <p><strong>标记-清除算法 (Mark-Sweep)</strong><br>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。该算法最大的问题是存在大量的空间碎片，因为回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。</p>
                    </li>
                    <li>
                      <p><strong>复制算法 (Copying)</strong><br>将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，然后清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。<br>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。</p>
                    </li>
                    <li>
                      <p><strong>标记-压缩算法 (Mark-Compact)</strong><br>复制算法的高效性是建立在存活对象少而垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。<br>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。也首先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
                    </li>
                    <li>
                      <p><strong>增量算法 (Incremental Collecting)</strong><br>在垃圾回收过程中，应用软件将处于一种 CPU 消耗很高的状态。在这种 CPU 消耗很高的状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。<br>增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
                    </li>
                    <li>
                      <p><strong>分代 (Generational Collecting)</strong><br>根据垃圾回收对象的特性，不同阶段最优的方式是使用合适的算法用于本阶段的垃圾回收，分代算法即是基于这种思想，它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。以 Hot Spot 虚拟机为例，它将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。在老生代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老生代，将需要复制大量对象。再加上老生代的回收性价比也要低于新生代，因此这种做法也是不可取的。根据分代的思想，可以对老年代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。</p>
                    </li>
                  </ul>
                  <p>&emsp;&emsp;对分代算法通俗的理解就是：假设你是一个普通的 Java 对象，你出生在 Eden 区，在 Eden 区有许多和你差不多的小兄弟、小姐妹，可以把 Eden 区当成幼儿园，在这个幼儿园里大家玩了很长时间。Eden 区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到学校去上学，这里假设从小学到高中都称为 Survivor 区。开始的时候你在 Survivor 区里面划分出来的的“From”区，读到高年级了，就进了 Survivor 区的“To”区，中间由于学习成绩不稳定，还经常来回折腾。直到你
                    18 岁的时候，高中毕业了，该去社会上闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里，你生活了 20 年 (每次 GC 加一岁)，最后寿终正寝，被 GC 回收。有一点没有提，你在年老代遇到了一个同学，他的名字叫爱德华 (慕光之城里的帅哥吸血鬼)，他以及他的家族永远不会死，那么他们就生活在永生代。</p>
                  <p>从不同角度分析垃圾收集器，可以将其分为不同的类型。</p>
                  <ol>
                    <li>按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。串行垃圾回收器一次只使用一个线程进行垃圾回收；并行垃圾回收器一次将开启多个线程同时进行垃圾回收。在并行能力较强的 CPU 上，使用并行垃圾回收器可以缩短 GC 的停顿时间。</li>
                    <li>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间；独占式垃圾回收器 (Stop the world) 一旦运行，就停止应用程序中的其他所有线程，直到垃圾回收过程完全结束。</li>
                    <li>按碎片处理方式可分为压缩式垃圾回收器和非压缩式垃圾回收器。压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片；非压缩式的垃圾回收器不进行这步操作。</li>
                    <li>按工作的内存区间，又可分为新生代垃圾回收器和老年代垃圾回收器。</li>
                  </ol>
                  <p>可以用以下指标评价一个垃圾处理器的好坏。</p>
                  <p><strong>吞吐量</strong>：指在应用程序的生命周期内，应用程序所花费的时间和系统总运行时间的比值。系统总运行时间=应用程序耗时+GC 耗时。如果系统运行了 100min，GC 耗时 1min，那么系统的吞吐量就是 (100-1)/100=99%。<br><strong>垃圾回收器负载</strong>：和吞吐量相反，垃圾回收器负载指来记回收器耗时与系统运行总时间的比值。<br><strong>停顿时间</strong>：指垃圾回收器正在运行时，应用程序的暂停时间。对于独占回收器而言，停顿时间可能会比较长。使用并发的回收器时，由于垃圾回收器和应用程序交替运行，程序的停顿时间会变短，但是，由于其效率很可能不如独占垃圾回收器，故系统的吞吐量可能会较低。<br><strong>垃圾回收频率</strong>：指垃圾回收器多长时间会运行一次。一般来说，对于固定的应用而言，垃圾回收器的频率应该是越低越好。通常增大堆空间可以有效降低垃圾回收发生的频率，但是可能会增加回收产生的停顿时间。<br><strong>反应时间</strong>：指当一个对象被称为垃圾后多长时间内，它所占据的内存空间会被释放。<br><strong>堆分配</strong>：不同的垃圾回收器对堆内存的分配方式可能是不同的。一个良好的垃圾收集器应该有一个合理的堆内存区间划分。</p>
                  <h4
                    id="JVM-垃圾回收器分类">
                    <a href="#JVM-垃圾回收器分类" class="headerlink" title="JVM 垃圾回收器分类"></a>JVM 垃圾回收器分类</h4>
                    <ul>
                      <li><strong>新生代串行收集器</strong><br>&emsp;&emsp;串行收集器主要有两个特点：第一，它仅仅使用单线程进行垃圾回收；第二，它独占式的垃圾回收。<br>在串行收集器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收的完成，这样给用户体验造成较差效果。虽然如此，串行收集器却是一个成熟、经过长时间生产环境考验的极为高效的收集器。新生代串行处理器使用复制算法，实现相对简单，逻辑处理特别高效，且没有线程切换的开销。在诸如单
                        CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。在 HotSpot 虚拟机中，使用-XX：+UseSerialGC 参数可以指定使用新生代串行收集器和老年代串行收集器。当 JVM 在 Client 模式下运行时，它是默认的垃圾收集器。一次新生代串行收集器的工作输出日志类似：</li>
                    </ul>
                    <blockquote>
                      <p>[GC [DefNew: 3468K-&gt;150K(9216K), 0.0028638 secs][Tenured:<br>1562K-&gt;1712K(10240K), 0.0084220 secs] 3468K-&gt;1712K(19456K),<br>[Perm : 377K-&gt;377K(12288K)],<br>0.0113816 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</p>
                    </blockquote>
                    <p>它显示了一次垃圾回收前的新生代的内存占用量和垃圾回收后的新生代内存占用量，以及垃圾回收所消耗的时间。</p>
                    <ul>
                      <li>
                        <p><strong>老年代串行收集器</strong><br>&emsp;&emsp;老年代串行收集器使用的是标记-压缩算法。和新生代串行收集器一样，它也是一个串行的、独占式的垃圾回收器。由于老年代垃圾回收通常会使用比新生代垃圾回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序很可能会因此停顿几秒甚至更长时间。虽然如此，老年代串行回收器可以和多种新生代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。若要启用老年代串行回收器，可以尝试使用以下参数：-XX:+UseSerialGC:
                          新生代、老年代都使用串行回收器。</p>
                      </li>
                      <li>
                        <p><strong>并行收集器</strong><br>&emsp;&emsp;并行收集器是工作在新生代的垃圾收集器，它只简单地将串行回收器多线程化。它的回收策略、算法以及参数和串行回收器一样。<br>&emsp;&emsp;并行回收器也是独占式的回收器，在收集过程中，应用程序会全部暂停。但由于并行回收器使用多线程进行垃圾回收，因此，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者并发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。<br>&emsp;&emsp;开启并行回收器可以使用参数-XX:+UseParNewGC，该参数设置新生代使用并行收集器，老年代使用串行收集器。</p>
                        <blockquote>
                          <p>[GC [ParNew: 825K-&gt;161K(4928K), 0.0155258 secs][Tenured: 8704K-&gt;661K(10944K),<br>0.0071964 secs] 9017K-&gt;661K(15872K),<br>[Perm : 2049K-&gt;2049K(12288K)], 0.0228090 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]<br>Heap<br>par
                            new generation total 4992K, used 179K [0x0f010000, 0x0f570000, 0x14560000)<br>eden space 4480K, 4% used [0x0f010000, 0x0f03cda8, 0x0f470000)<br>from space 512K, 0% used [0x0f470000, 0x0f470000, 0x0f4f0000)<br>to space 512K,
                            0% used [0x0f4f0000, 0x0f4f0000, 0x0f570000)<br>tenured generation total 10944K, used 8853K [0x14560000, 0x15010000, 0x1f010000)<br>the space 10944K, 80% used [0x14560000, 0x14e057c0, 0x14e05800, 0x15010000)<br>compacting perm
                            gen total 12288K, used 2060K [0x1f010000, 0x1fc10000, 0x23010000)<br>the space 12288K, 16% used [0x1f010000, 0x1f213228, 0x1f213400, 0x1fc10000)<br>No shared spaces configured.</p>
                        </blockquote>
                      </li>
                    </ul>
                    <p>&emsp;&emsp;并行收集器工作时的线程数量可以使用-XX:ParallelGCThreads 参数指定。一般，最好与 CPU 数量相当，避免过多的线程数影响垃圾收集性能。在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 数量，大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU_Count]/8]。</p>
                    <ul>
                      <li><strong>新生代并行回收 (Parallel Scavenge) 收集器</strong></li>
                    </ul>
                    <p>&emsp;&emsp;新生代并行回收收集器也是使用复制算法的收集器。从表面上看，它和并行收集器一样都是多线程、独占式的收集器。但是，并行回收收集器有一个重要的特点：它非常关注系统的吞吐量。<br>新生代并行回收收集器可以使用以下参数启用：</p>
                    <blockquote>
                      <p>-XX:+UseParallelGC:新生代使用并行回收收集器，老年代使用串行收集器。<br>-XX:+UseParallelOldGC:新生代和老年代都是用并行回收收集器。<br>-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间，它的值是一个大于 0 的整数。收集器在工作时会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。如果希望减少停顿时间，而把这个值设置得很小，为了达到预期的停顿时间，JVM
                        可能会使用一个较小的堆 (一个小堆比一个大堆回收快)，而这将导致垃圾回收变得很频繁，从而增加了垃圾回收总时间，降低了吞吐量。<br>-XX:+GCTimeRatio：设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。比如 GCTimeRatio 等于 19，则系统用于垃圾收集的时间不超过 1/(1+19)=5%。默认情况下，它的取值是 99，即不超过
                        1%的时间用于垃圾收集。</p>
                    </blockquote>
                    <p>&emsp;&emsp;除此之外，并行回收收集器与并行收集器另一个不同之处在于，它支持一种自适应的 GC 调节策略，使用-XX:+UseAdaptiveSizePolicy 可以打开自适应 GC 策略。在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio)
                      和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。</p>
                    <ul>
                      <li>
                        <p><strong>老年代并行回收收集器</strong><br>&emsp;&emsp;老年代的并行回收收集器也是一种多线程并发的收集器。和新生代并行回收收集器一样，它也是一种关注吞吐量的收集器。老年代并行回收收集器使用标记-压缩算法，JDK1.6 之后开始启用。<br>使用-XX:+UseParallelOldGC 可以在新生代和老生代都使用并行回收收集器，这是一对非常关注吞吐量的垃圾收集器组合，在对吞吐量敏感的系统中，可以考虑使用。参数-XX:ParallelGCThreads
                          也可以用于设置垃圾回收时的线程数量。</p>
                      </li>
                      <li>
                        <p><strong>CMS 收集器</strong><br>&emsp;&emsp;与并行回收收集器不同，CMS 收集器主要关注于系统停顿时间。CMS 是 Concurrent Mark Sweep 的缩写，意为并发标记清除，从名称上可以得知，它使用的是标记-清除算法，同时它又是一个使用多线程并发回收的垃圾收集器。<br>&emsp;&emsp;CMS 工作时，主要步骤有：初始标记、并发标记、重新标记、并发清除和并发重置。其中初始标记和重新标记是独占系统资源的，而并发标记、并发清除和并发重置是可以和用户线程一起执行的。因此，从整体上来说，CMS
                          收集不是独占式的，它可以在应用程序运行过程中进行垃圾回收。<br>&emsp;&emsp;根据标记-清除算法，初始标记、并发标记和重新标记都是为了标记出需要回收的对象。并发清理则是在标记完成后，正式回收垃圾对象；并发重置是指在垃圾回收完成后，重新初始化 CMS 数据结构和数据，为下一次垃圾回收做好准备。并发标记、并发清理和并发重置都是可以和应用程序线程一起执行的。<br>&emsp;&emsp;CMS 收集器在其主要的工作阶段虽然没有暴力地彻底暂停应用程序线程，但是由于它和应用程序线程并发执行，相互抢占
                          CPU，所以在 CMS 执行期内对应用程序吞吐量造成一定影响。CMS 默认启动的线程数是 (ParallelGCThreads+3)/4),ParallelGCThreads 是新生代并行收集器的线程数，也可以通过-XX:ParallelCMSThreads 参数手工设定 CMS 的线程数量。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。<br>&emsp;&emsp;由于 CMS 收集器不是独占式的回收器，在
                          CMS 回收过程中，应用程序仍然在不停地工作。在应用程序工作过程中，又会不断地产生垃圾。这些新生成的垃圾在当前 CMS 回收过程中是无法清除的。同时，因为应用程序没有中断，所以在 CMS 回收过程中，还应该确保应用程序有足够的内存可用。因此，CMS 收集器不会等待堆内存饱和时才进行垃圾回收，而是当前堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。<br>&emsp;&emsp;这个回收阈值可以使用-XX:CMSInitiatingOccupancyFraction
                          来指定，默认是 68。即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。如果应用程序的内存使用率增长很快，在 CMS 的执行过程中，已经出现了内存不足的情况，此时，CMS 回收将会失败，JVM 将启动老年代串行收集器进行垃圾回收。如果这样，应用程序将完全中断，直到垃圾收集完成，这时，应用程序的停顿时间可能很长。因此，根据应用程序的特点，可以对-XX:CMSInitiatingOccupancyFraction 进行调优。如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低
                          CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。<br>&emsp;&emsp;标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的，为了解决这个问题，CMS 收集器还提供了几个用于内存压缩整理的算法。<br>&emsp;&emsp;-XX:+UseCMSCompactAtFullCollection
                          参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。-XX:CMSFullGCsBeforeCompaction 参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。</p>
                      </li>
                      <li>
                        <p><strong>G1 收集器 (Garbage First)</strong><br>&emsp;&emsp;G1 收集器的目标是作为一款服务器的垃圾收集器，因此，它在吞吐量和停顿控制上，预期要优于 CMS 收集器。<br>&emsp;&emsp;与 CMS 收集器相比，G1 收集器是基于标记-压缩算法的。因此，它不会产生空间碎片，也没有必要在收集完成后，进行一次独占式的碎片整理工作。G1 收集器还可以进行非常精确的停顿控制。它可以让开发人员指定当停顿时长为
                          M 时，垃圾回收时间不超过 N。使用参数-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC 来启用 G1 回收器，设置 G1 回收器的目标停顿时间：-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200。</p>
                      </li>
                    </ul>
                    <h4 id="收集器对系统性能的影响"><a href="#收集器对系统性能的影响" class="headerlink" title="收集器对系统性能的影响"></a>收集器对系统性能的影响</h4>
                    <p>&emsp;&emsp;通过运行 1 万次循环，每次分配 512*100B 空间，采用不同的垃圾回收器，输出程序运行所消耗的时间。</p>
                    <figure class="highlight java">
                      <table>
                        <tr>
                          <td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td>
                          <td
                            class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTimeTest</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">static</span> HashMap map = <span class="keyword">new</span> HashMap();</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> begintime = System.currentTimeMillis();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (map.size() * <span class="number">512</span> / <span class="number">1024</span> / <span class="number">1024</span> &gt;= <span class="number">400</span>) &#123;</div><div class="line">        map.clear();<span class="comment">// 保护内存不溢出</span></div><div class="line">        System.out.println(<span class="string">"clean map"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">byte</span>[] b1;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</div><div class="line">        b1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</div><div class="line">        map.put(System.nanoTime(), b1);<span class="comment">// 不断消耗内存</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> endtime = System.currentTimeMillis();</div><div class="line">    System.out.println(endtime - begintime);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td>
                        </tr>
                      </table>
                    </figure>
                    <p>使用参数-Xmx512M -Xms512M -XX:+UseParNewGC 运行代码，输出如下：</p>
                    <blockquote>
                      <p>clean map 8565<br>cost time=1655</p>
                    </blockquote>
                    <p>使用参数-Xmx512M -Xms512M -XX:+UseParallelOldGC –XX:ParallelGCThreads=8 运行代码，输出如下：</p>
                    <blockquote>
                      <p>clean map 8798<br>cost time=1998</p>
                    </blockquote>
                    <p>使用参数-Xmx512M -Xms512M -XX:+UseSerialGC 运行代码，输出如下：</p>
                    <blockquote>
                      <p>clean map 8864<br>cost time=1717</p>
                    </blockquote>
                    <p>使用参数-Xmx512M -Xms512M -XX:+UseConcMarkSweepGC 运行代码，输出如下：</p>
                    <blockquote>
                      <p>clean map 8862<br>cost time=1530</p>
                    </blockquote>
                    <p>&emsp;&emsp;上面例子的 GC 输出可以看出，采用不同的垃圾回收机制及设定不同的线程数，对于代码段的整体执行时间有较大的影响。需要读者有针对性地选用适合自己代码段的垃圾回收机制。</p>
                    <h4 id="GC-相关参数总结"><a href="#GC-相关参数总结" class="headerlink" title="GC 相关参数总结"></a>GC 相关参数总结</h4>
                    <ol>
                      <li>
                        <p>与串行回收器相关的参数</p>
                        <blockquote>
                          <p>-XX:+UseSerialGC:在新生代和老年代使用串行回收器。<br>-XX:+SuivivorRatio:设置 eden 区大小和 survivor 区大小的比例。<br>-XX:+PretenureSizeThreshold:设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。<br>-XX:MaxTenuringThreshold:设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。</p>
                        </blockquote>
                      </li>
                      <li>
                        <p>与并行 GC 相关的参数</p>
                        <blockquote>
                          <p>-XX:+UseParNewGC: 在新生代使用并行收集器。<br>-XX:+UseParallelOldGC: 老年代使用并行回收收集器。<br>-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。<br>-XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java
                            堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。<br>-XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。<br>-XX:+UseAdaptiveSizePolicy:打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
                        </blockquote>
                      </li>
                      <li>
                        <p>与 CMS 回收器相关的参数</p>
                        <blockquote>
                          <p>-XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS+串行收集器。<br>-XX:+ParallelCMSThreads: 设定 CMS 的线程数量。<br>-XX:+CMSInitiatingOccupancyFraction:设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。<br>-XX:+UseFullGCsBeforeCompaction:设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。<br>-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收。<br>-XX:+CMSParallelRemarkEndable:启用并行重标记。<br>-XX:CMSInitatingPermOccupancyFraction:当永久区占用率达到这一百分比后，启动
                            CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。<br>-XX:UseCMSInitatingOccupancyOnly:表示只在到达阈值的时候，才进行 CMS 回收。<br>-XX:+CMSIncrementalMode:使用增量模式，比较适合单 CPU。</p>
                        </blockquote>
                      </li>
                      <li>
                        <p>与 G1 回收器相关的参数</p>
                        <blockquote>
                          <p>-XX:+UseG1GC：使用 G1 回收器。<br>-XX:+UnlockExperimentalVMOptions:允许使用实验性参数。<br>-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间。<br>-XX:+GCPauseIntervalMills:设置停顿间隔时间。</p>
                        </blockquote>
                      </li>
                      <li>
                        <p>其他参数</p>
                        <blockquote>
                          <p>-XX:+DisableExplicitGC: 禁用显示 GC。</p>
                        </blockquote>
                      </li>
                    </ol>
                </div>
                <div></div>
                <div></div>
                <footer class="post-footer">
                  <div class="post-tags"><a href="/tags/java/" rel="tag">#java</a></div>
                  <div class="post-nav">
                    <div class="post-nav-next post-nav-item"><a href="/2016/05/30/java-generic/" rel="next" title="java基础拾遗——泛型"><i class="fa fa-chevron-left"></i> java基础拾遗——泛型</a></div>
                    <div class="post-nav-prev post-nav-item"><a href="/2016/05/30/jvm-optimal/" rel="prev" title="java基础拾遗——JVM优化经验总结">java基础拾遗——JVM优化经验总结 <i class="fa fa-chevron-right"></i></a></div>
                  </div>
                </footer>
              </article>
              <div class="post-spread"></div>
            </div>
          </div>
          <div class="comments" id="comments">
            <div class="ds-thread" data-thread-key="2016/05/30/jvm/" data-title="java基础拾遗——JVM垃圾回收原理" data-url="http://xiaolin.site/2016/05/30/jvm/"></div>
          </div>
        </div>
        <div class="sidebar-toggle">
          <div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div>
        </div>
        <aside id="sidebar" class="sidebar">
          <div class="sidebar-inner">
            <ul class="sidebar-nav motion-element">
              <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li>
              <li class="sidebar-nav-overview" data-target="site-overview">站点概览</li>
            </ul>
            <section class="site-overview sidebar-panel">
              <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://o6fmcea8z.bkt.clouddn.com/blog/image/me.png" alt="XiaoLin">
                <p class="site-author-name" itemprop="name">XiaoLin</p>
                <p class="site-description motion-element" itemprop="description">XiaoLin's Blog</p>
              </div>
              <nav class="site-state motion-element">
                <div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">23</span> <span class="site-state-item-name">日志</span></a></div>
                <div class="site-state-item site-state-categories"><a href="/categories"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div>
                <div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div>
              </nav>
              <div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div>
              <div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xiaolin8" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://www.zhihu.com/people/wuxun-yi" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i> 知乎</a></span></div>
            </section>
            <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
              <div class="post-toc">
                <div class="post-toc-content">
                  <ol class="nav">
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾回收是个什么鬼？"><span class="nav-number">1.</span> <span class="nav-text">垃圾回收是个什么鬼？</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾回收器常用的算法"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收器常用的算法</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-垃圾回收器分类"><span class="nav-number">3.</span> <span class="nav-text">JVM 垃圾回收器分类</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#收集器对系统性能的影响"><span class="nav-number">4.</span> <span class="nav-text">收集器对系统性能的影响</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#GC-相关参数总结"><span class="nav-number">5.</span> <span class="nav-text">GC 相关参数总结</span></a></li>
                  </ol>
                </div>
              </div>
            </section>
          </div>
        </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2016</span> <span class="with-love"><i class="fa fa-heart"></i> </span><a class="author" itemprop="copyrightHolder" href="/about">XiaoLin</a></div>
      </div>
    </footer>
    <div class="back-to-top"><i class="fa fa-arrow-up"></i></div>
  </div>
  <script type="text/javascript">
    "[object Function]" !== Object.prototype.toString.call(window.Promise) && (window.Promise = null)
  </script>
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>
  <script type="text/javascript">
    var duoshuoQuery = {
      short_name: "xiaolin"
    };
    ! function() {
      var t = document.createElement("script");
      t.type = "text/javascript", t.async = !0, t.id = "duoshuo-script", t.src = ("https:" == document.location.protocol ? "https:" : "http:") + "//static.duoshuo.com/embed.js", t.charset = "UTF-8", (document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(t)
    }()
  </script>
  <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
  <script src="/js/src/hook-duoshuo.js"></script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>
    AV.initialize("8ea8d1qFz1ngcfqFfHDtD9OK-gzGzoHsz", "oqupQn89j1bemr3K6Xp9SpS5")
  </script>
  <script>
    function showTime(e) {
      var t = new AV.Query(e),
        n = [],
        o = $(".leancloud_visitors");
      o.each(function() {
        n.push($(this).attr("id").trim())
      }), t.containedIn("url", n), t.find().done(function(e) {
        var t = ".leancloud-visitors-count";
        if (0 === e.length) return void o.find(t).text(0);
        for (var i = 0; i < e.length; i++) {
          var r = e[i],
            s = r.get("url"),
            l = r.get("time"),
            c = document.getElementById(s);
          $(c).find(t).text(l)
        }
        for (var i = 0; i < n.length; i++) {
          var s = n[i],
            c = document.getElementById(s),
            u = $(c).find(t);
          "" == u.text() && u.text(0)
        }
      }).fail(function(e, t) {
        console.log("Error: " + t.code + " " + t.message)
      })
    }

    function addCount(e) {
      var t = $(".leancloud_visitors"),
        n = t.attr("id").trim(),
        o = t.attr("data-flag-title").trim(),
        i = new AV.Query(e);
      i.equalTo("url", n), i.find({
        success: function(t) {
          if (t.length > 0) {
            var i = t[0];
            i.fetchWhenSave(!0), i.increment("time"), i.save(null, {
              success: function(e) {
                var t = $(document.getElementById(n));
                t.find(".leancloud-visitors-count").text(e.get("time"))
              },
              error: function(e, t) {
                console.log("Failed to save Visitor num, with error message: " + t.message)
              }
            })
          } else {
            var r = new e,
              s = new AV.ACL;
            s.setPublicReadAccess(!0), s.setPublicWriteAccess(!0), r.setACL(s), r.set("title", o), r.set("url", n), r.set("time", 1), r.save(null, {
              success: function(e) {
                var t = $(document.getElementById(n));
                t.find(".leancloud-visitors-count").text(e.get("time"))
              },
              error: function(e, t) {
                console.log("Failed to create")
              }
            })
          }
        },
        error: function(e) {
          console.log("Error:" + e.code + " " + e.message)
        }
      })
    }
    $(function() {
      var e = AV.Object.extend("Counter");
      1 == $(".leancloud_visitors").length ? addCount(e) : $(".post-title-link").length > 1 && showTime(e)
    })
  </script>
</body>

</html>