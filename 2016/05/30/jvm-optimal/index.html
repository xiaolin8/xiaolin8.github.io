<!doctype html>
<html class="theme-next pisces use-motion">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  <link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">
  <link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="java,">
  <link rel="alternate" href="/atom.xml" title="XiaoLin's Blog" type="application/atom+xml">
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">
  <meta name="description" content="&amp;emsp;&amp;emsp;之前的文章《java基础拾遗——JVM垃圾回收原理》中已经介绍过年轻代、年老代、永生代，本文主要讲讲如何运用这些区域，为系统性能提供更好的帮助。本文不再赘述这些概念，直接进入主题。
如何将新对象预留在年轻代
&amp;emsp;&amp;emsp;众所周知，由于 Full GC 的成本远远高于 Minor GC，因此某些情况下需要尽可能将对象分配在年轻代，这在很多情况下是一个明智的选择。虽">
  <meta property="og:type" content="article">
  <meta property="og:title" content="java基础拾遗——JVM优化经验总结">
  <meta property="og:url" content="http://xiaolin.site/2016/05/30/jvm-optimal/index.html">
  <meta property="og:site_name" content="XiaoLin's Blog">
  <meta property="og:description" content="&amp;emsp;&amp;emsp;之前的文章《java基础拾遗——JVM垃圾回收原理》中已经介绍过年轻代、年老代、永生代，本文主要讲讲如何运用这些区域，为系统性能提供更好的帮助。本文不再赘述这些概念，直接进入主题。
如何将新对象预留在年轻代
&amp;emsp;&amp;emsp;众所周知，由于 Full GC 的成本远远高于 Minor GC，因此某些情况下需要尽可能将对象分配在年轻代，这在很多情况下是一个明智的选择。虽">
  <meta property="og:updated_time" content="2016-07-18T07:33:51.992Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="java基础拾遗——JVM优化经验总结">
  <meta name="twitter:description" content="&amp;emsp;&amp;emsp;之前的文章《java基础拾遗——JVM垃圾回收原理》中已经介绍过年轻代、年老代、永生代，本文主要讲讲如何运用这些区域，为系统性能提供更好的帮助。本文不再赘述这些概念，直接进入主题。
如何将新对象预留在年轻代
&amp;emsp;&amp;emsp;众所周知，由于 Full GC 的成本远远高于 Minor GC，因此某些情况下需要尽可能将对象分配在年轻代，这在很多情况下是一个明智的选择。虽">
  <script type="text/javascript" id="hexo.configuration">
    var NexT = window.NexT || {},
      CONFIG = {
        scheme: "Pisces",
        sidebar: {
          position: "left",
          display: "post"
        },
        fancybox: !0,
        motion: !0,
        duoshuo: {
          userId: 0,
          author: "博主"
        }
      }
  </script>
  <link rel="canonical" href="http://xiaolin.site/2016/05/30/jvm-optimal/">
  <title>java基础拾遗——JVM优化经验总结 | XiaoLin's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container one-collumn sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
        <div class="site-meta">
          <div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">XiaoLin's Blog</span> <span class="logo-line-after"><i></i></span></a></div>
          <p class="site-subtitle">回首向来萧瑟处，归去，也无风雨也无晴</p>
        </div>
        <div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div>
        <nav class="site-nav">
          <ul id="menu" class="menu">
            <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li>
            <li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li>
            <li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li>
            <li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li>
            <li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            <div id="posts" class="posts-expand">
              <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
                <header class="post-header">
                  <h1 class="post-title" itemprop="name headline">java基础拾遗——JVM优化经验总结</h1>
                  <div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-05-30T21:47:38+08:00" content="2016-05-30">2016-05-30 </time></span>
                    <span
                      class="post-category">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span>                      </a>
                      </span>
                      </span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/05/30/jvm-optimal/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/05/30/jvm-optimal/" itemprop="commentsCount"></span></a>
                      </span>
                  </div>
                </header>
                <div class="post-body" itemprop="articleBody">
                  <p>&emsp;&emsp;之前的文章<a href="http://xiaolin.site/2016/05/30/jvm/">《java基础拾遗——JVM垃圾回收原理》</a>中已经介绍过年轻代、年老代、永生代，本文主要讲讲如何运用这些区域，为系统性能提供更好的帮助。本文不再赘述这些概念，直接进入主题。</p>
                  <h4 id="如何将新对象预留在年轻代"><a href="#如何将新对象预留在年轻代" class="headerlink" title="如何将新对象预留在年轻代"></a>如何将新对象预留在年轻代</h4>
                  <p>&emsp;&emsp;众所周知，由于 Full GC 的成本远远高于 Minor GC，因此某些情况下需要尽可能将对象分配在年轻代，这在很多情况下是一个明智的选择。虽然在大部分情况下，JVM 会尝试在 Eden 区分配对象，但是由于空间紧张等问题，很可能不得不将部分年轻对象提前向年老代压缩。因此，在 JVM 参数调优时可以为应用程序分配一个合理的年轻代空间，以最大限度避免新对象直接进入年老代的情况发生。如下尝试分配 4MB 内存空间，观察一下它的内存使用情况。</p>
                  <figure
                    class="highlight java">
                    <table>
                      <tr>
                        <td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td>
                        <td
                          class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PutInEden</span> </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"> <span class="keyword">byte</span>[] b1,b2,b3,b4;<span class="comment">//定义变量</span></div><div class="line"> b1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];<span class="comment">//分配 1MB 堆空间，考察堆空间的使用情况</span></div><div class="line"> b2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</div><div class="line"> b3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</div><div class="line"> b4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td>
                      </tr>
                    </table>
                    </figure>
                    <p>&emsp;&emsp;使用 JVM 参数-XX:+PrintGCDetails -Xmx20M -Xms20M 运行以上代码，输出如下所示。</p>
                    <blockquote>
                      <p>[GC [DefNew: 5504K-&gt;640K(6144K), 0.0114236 secs] 5504K-&gt;5352K(19840K),<br>0.0114595 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]<br>[GC [DefNew: 6144K-&gt;640K(6144K), 0.0131261 secs] 10856K-&gt;10782K(19840K),<br>0.0131612
                        secs] [Times: user=0.02 sys=0.00, real=0.02 secs]<br>[GC [DefNew: 6144K-&gt;6144K(6144K), 0.0000170 secs][Tenured: 10142K-&gt;13695K(13696K),<br>0.1069249 secs] 16286K-&gt;15966K(19840K), [Perm : 376K-&gt;376K(12288K)],<br>0.1070058
                        secs] [Times: user=0.03 sys=0.00, real=0.11 secs]<br>[Full GC [Tenured: 13695K-&gt;13695K(13696K), 0.0302067 secs] 19839K-&gt;19595K(19840K),<br>[Perm : 376K-&gt;376K(12288K)], 0.0302635 secs] [Times: user=0.03 sys=0.00, real=0.03
                        secs]<br>[Full GC [Tenured: 13695K-&gt;13695K(13696K), 0.0311986 secs] 19839K-&gt;19839K(19840K),<br>[Perm : 376K-&gt;376K(12288K)], 0.0312515 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]<br>[Full GC [Tenured: 13695K-&gt;13695K(13696K),
                        0.0358821 secs] 19839K-&gt;19825K(19840K),<br>[Perm : 376K-&gt;371K(12288K)], 0.0359315 secs] [Times: user=0.05 sys=0.00, real=0.05 secs]<br>[Full GC [Tenured: 13695K-&gt;13695K(13696K), 0.0283080 secs] 19839K-&gt;19839K(19840K),<br>[Perm
                        : 371K-&gt;371K(12288K)], 0.0283723 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>[Full GC [Tenured: 13695K-&gt;13695K(13696K), 0.0284469 secs] 19839K-&gt;19839K(19840K),<br>[Perm : 371K-&gt;371K(12288K)], 0.0284990 secs]
                        [Times: user=0.03 sys=0.00, real=0.03 secs]<br>[Full GC [Tenured: 13695K-&gt;13695K(13696K), 0.0283005 secs] 19839K-&gt;19839K(19840K),<br>[Perm : 371K-&gt;371K(12288K)], 0.0283475 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]<br>[Full
                        GC [Tenured: 13695K-&gt;13695K(13696K), 0.0287757 secs] 19839K-&gt;19839K(19840K),<br>[Perm : 371K-&gt;371K(12288K)], 0.0288294 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]<br>[Full GC [Tenured: 13695K-&gt;13695K(13696K),
                        0.0288219 secs] 19839K-&gt;19839K(19840K),<br>[Perm : 371K-&gt;371K(12288K)], 0.0288709 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]<br>[Full GC [Tenured: 13695K-&gt;13695K(13696K), 0.0293071 secs] 19839K-&gt;19839K(19840K),<br>[Perm
                        : 371K-&gt;371K(12288K)], 0.0293607 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]<br>[Full GC [Tenured: 13695K-&gt;13695K(13696K), 0.0356141 secs] 19839K-&gt;19838K(19840K),<br>[Perm : 371K-&gt;371K(12288K)], 0.0356654 secs]
                        [Times: user=0.01 sys=0.00, real=0.03 secs]<br>Heap<br>def new generation total 6144K, used 6143K [0x35c10000, 0x362b0000, 0x362b0000)<br>eden space 5504K, 100% used [0x35c10000, 0x36170000, 0x36170000)<br>from space 640K, 99%
                        used [0x36170000, 0x3620fc80, 0x36210000)<br>to space 640K, 0% used [0x36210000, 0x36210000, 0x362b0000)<br>tenured generation total 13696K, used 13695K [0x362b0000, 0x37010000, 0x37010000)<br>the space 13696K, 99% used [0x362b0000,
                        0x3700fff8, 0x37010000, 0x37010000)<br>compacting perm gen total 12288K, used 371K [0x37010000, 0x37c10000, 0x3b010000)<br>the space 12288K, 3% used [0x37010000, 0x3706cd20, 0x3706ce00, 0x37c10000)<br>ro space 10240K, 51% used
                        [0x3b010000, 0x3b543000, 0x3b543000, 0x3ba10000)<br>rw space 12288K, 55% used [0x3ba10000, 0x3c0ae4f8, 0x3c0ae600, 0x3c610000)</p>
                    </blockquote>
                    <p>&emsp;&emsp;日志输出显示年轻代 Eden 的大小有 5MB 左右。通过设置一个较大的年轻代预留新对象，设置合理的 Survivor 区并且提供 Survivor 区的使用率，可以将年轻对象保存在年轻代。一般来说，Survivor 区的空间不够，或者占用量达到 50%时，就会使对象进入年老代 (不管它的年龄有多大)。</p>
                    <h4 id="如何让大对象进入年老代"><a href="#如何让大对象进入年老代" class="headerlink" title="如何让大对象进入年老代"></a>如何让大对象进入年老代</h4>
                    <p>&emsp;&emsp;我们在大部分情况下都会选择将对象分配在年轻代。但是，对于占用内存较多的大对象而言，它的选择可能就不是这样的。因为大对象出现在年轻代很可能扰乱年轻代 GC，并破坏年轻代原有的对象结构。因为尝试在年轻代分配大对象，很可能导致空间不足，为了有足够的空间容纳大对象，JVM 不得不将年轻代中的年轻对象挪到年老代。因为大对象占用空间多，所以可能需要移动大量小的年轻对象进入年老代，这对 GC 相当不利。基于以上原因，可以将大对象直接分配到年老代，保持年轻代对象结构的完整性，这样可以提高
                      GC 的效率。如果一个大对象同时又是一个短命的对象，假设这种情况出现很频繁，那对于 GC 来说会是一场灾难。原本应该用于存放永久对象的年老代，被短命的对象塞满，这也意味着对堆空间进行了洗牌，扰乱了分代内存回收的基本思路。因此，在软件开发过程中，应该尽可能避免使用短命的大对象。可以使用参数-XX:PetenureSizeThreshold 设置大对象直接进入年老代的阈值。当对象的大小超过这个值时，将直接在年老代分配。参数-XX:PetenureSizeThreshold
                      只对串行收集器和年轻代并行收集器有效，并行回收收集器不识别这个参数。</p>
                    <p>&emsp;&emsp;创建一个大对象</p>
                    <figure class="highlight java">
                      <table>
                        <tr>
                          <td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td>
                          <td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigObj2Old</span> </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"> <span class="keyword">byte</span>[] b;</div><div class="line"> b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];<span class="comment">//分配一个 1MB 的对象</span></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td>
                        </tr>
                      </table>
                    </figure>
                    <p>&emsp;&emsp;使用 JVM 参数-XX:+PrintGCDetails –Xmx20M –Xms20MB 运行，可以得到如下日志输出：</p>
                    <blockquote>
                      <p>Heap<br>def new generation total 6144K, used 1378K [0x35c10000, 0x362b0000, 0x362b0000)<br>eden space 5504K, 25% used [0x35c10000, 0x35d689e8, 0x36170000)<br>from space 640K, 0% used [0x36170000, 0x36170000, 0x36210000)<br>to space
                        640K, 0% used [0x36210000, 0x36210000, 0x362b0000)<br>tenured generation total 13696K, used 0K [0x362b0000, 0x37010000, 0x37010000)<br>the space 13696K, 0% used [0x362b0000, 0x362b0000, 0x362b0200, 0x37010000)<br>compacting perm
                        gen total 12288K, used 374K [0x37010000, 0x37c10000, 0x3b010000)<br>the space 12288K, 3% used [0x37010000, 0x3706dac8, 0x3706dc00, 0x37c10000)<br>ro space 10240K, 51% used [0x3b010000, 0x3b543000, 0x3b543000, 0x3ba10000)<br>rw
                        space 12288K, 55% used [0x3ba10000, 0x3c0ae4f8, 0x3c0ae600, 0x3c610000)</p>
                    </blockquote>
                    <p>&emsp;&emsp;可以看到该对象被分配在了年轻代，占用了 25%的空间。如果需要将 1MB 以上的对象直接在年老代分配，设置-XX:PetenureSizeThreshold=1000000，程序运行后输出如下所示：</p>
                    <blockquote>
                      <p>Heap<br>def new generation total 6144K, used 354K [0x35c10000, 0x362b0000, 0x362b0000)<br>eden space 5504K, 6% used [0x35c10000, 0x35c689d8, 0x36170000)<br>from space 640K, 0% used [0x36170000, 0x36170000, 0x36210000)<br>to space
                        640K, 0% used [0x36210000, 0x36210000, 0x362b0000)<br>tenured generation total 13696K, used 1024K [0x362b0000, 0x37010000, 0x37010000)<br>the space 13696K, 7% used [0x362b0000, 0x363b0010, 0x363b0200, 0x37010000)<br>compacting
                        perm gen total 12288K, used 374K [0x37010000, 0x37c10000, 0x3b010000)<br>the space 12288K, 3% used [0x37010000, 0x3706dac8, 0x3706dc00, 0x37c10000)<br>ro space 10240K, 51% used [0x3b010000, 0x3b543000, 0x3b543000, 0x3ba10000)<br>rw
                        space 12288K, 55% used [0x3ba10000, 0x3c0ae4f8, 0x3c0ae600, 0x3c610000)</p>
                    </blockquote>
                    <p>&emsp;&emsp;可以看到当满 1MB 时进入到了年老代。</p>
                    <h4 id="如何设置对象进入年老代的年龄"><a href="#如何设置对象进入年老代的年龄" class="headerlink" title="如何设置对象进入年老代的年龄"></a>如何设置对象进入年老代的年龄</h4>
                    <p>&emsp;&emsp;堆中的每一个对象都有自己的年龄。一般情况下，年轻对象存放在年轻代，年老对象存放在年老代。为了做到这点，虚拟机为每个对象都维护一个年龄。如果对象在 Eden 区，经过一次 GC 后依然存活，则被移动到 Survivor 区中，对象年龄加 1。以后，如果对象每经过一次 GC 依然存活，则年龄再加 1。当对象年龄达到阈值时，就移入年老代，成为老年对象。这个阈值的最大值可以通过参数-XX:MaxTenuringThreshold 来设置，默认值是
                      15。虽然-XX:MaxTenuringThreshold 的值可能是 15 或者更大，但这不意味着新对象非要达到这个年龄才能进入年老代。事实上，对象实际进入年老代的年龄是虚拟机在运行时根据内存使用情况动态计算的，这个参数指定的是阈值年龄的最大值。即，实际晋升年老代年龄等于动态计算所得的年龄与-XX:MaxTenuringThreshold 中较小的那个。如下代码为 3 个对象申请了若干内存。<br>&emsp;&emsp;<strong>申请内存</strong><br></p>
                    <figure
                      class="highlight java">
                      <table>
                        <tr>
                          <td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td>
                          <td
                            class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTenuringThreshold</span> </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line"> <span class="keyword">byte</span>[] b1,b2,b3;</div><div class="line"> b1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">512</span>];</div><div class="line"> b2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>];</div><div class="line"> b3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">4</span>];</div><div class="line"> b3 = <span class="keyword">null</span>;</div><div class="line"> b3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">4</span>];</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td>
                        </tr>
                      </table>
                      </figure>
                      <p></p>
                      <p>&emsp;&emsp;参数设置为：-XX:+PrintGCDetails -Xmx20M -Xms20M -Xmn10M -XX:SurvivorRatio=2</p>
                      <blockquote>
                        <p>[GC [DefNew: 2986K-&gt;690K(7680K), 0.0246816 secs] 2986K-&gt;2738K(17920K),<br>0.0247226 secs] [Times: user=0.00 sys=0.02, real=0.03 secs]<br>[GC [DefNew: 4786K-&gt;690K(7680K), 0.0016073 secs] 6834K-&gt;2738K(17920K),<br>0.0016436
                          secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br>def new generation total 7680K, used 4888K [0x35c10000, 0x36610000, 0x36610000)<br>eden space 5120K, 82% used [0x35c10000, 0x36029a18, 0x36110000)<br>from space 2560K,
                          26% used [0x36110000, 0x361bc950, 0x36390000)<br>to space 2560K, 0% used [0x36390000, 0x36390000, 0x36610000)<br>tenured generation total 10240K, used 2048K [0x36610000, 0x37010000, 0x37010000)<br>the space 10240K, 20% used [0x36610000,
                          0x36810010, 0x36810200, 0x37010000)<br>compacting perm gen total 12288K, used 374K [0x37010000, 0x37c10000, 0x3b010000)<br>the space 12288K, 3% used [0x37010000, 0x3706db50, 0x3706dc00, 0x37c10000)<br>ro space 10240K, 51% used
                          [0x3b010000, 0x3b543000, 0x3b543000, 0x3ba10000)<br>rw space 12288K, 55% used [0x3ba10000, 0x3c0ae4f8, 0x3c0ae600, 0x3c610000)</p>
                      </blockquote>
                      <p>&emsp;&emsp;更改参数为-XX:+PrintGCDetails -Xmx20M -Xms20M -Xmn10M -XX:SurvivorRatio=2 -XX:MaxTenuringThreshold=1。第一次运行时 b1 对象在程序结束后依然保存在年轻代。第二次运行前，我们减小了对象晋升年老代的年龄，设置为 1。即，所有经过一次 GC 的对象都可以直接进入年老代。程序运行后，可以发现 b1 对象已经被分配到年老代。如果希望对象尽可能长时间地停留在年轻代，可以设置一个较大的阈值。</p>
                      <h4
                        id="稳定的-Java-堆-VS-动荡的-Java-堆">
                        <a href="#稳定的-Java-堆-VS-动荡的-Java-堆" class="headerlink" title="稳定的 Java 堆 VS 动荡的 Java 堆"></a>稳定的 Java 堆 VS 动荡的 Java 堆</h4>
                        <p>&emsp;&emsp;一般来说，稳定的堆大小对垃圾回收是有利的。获得一个稳定的堆大小的方法是使-Xms 和-Xmx 的大小一致，即最大堆和最小堆 (初始堆) 一样。如果这样设置，系统在运行时堆大小理论上是恒定的，稳定的堆空间可以减少 GC 的次数。因此，很多服务端应用都会将最大堆和最小堆设置为相同的数值。但是，一个不稳定的堆并非毫无用处。稳定的堆大小虽然可以减少 GC 次数，但同时也增加了每次 GC 的时间。让堆大小在一个区间中震荡，在系统不需要使用大内存时，压缩堆空间，使
                          GC 应对一个较小的堆，可以加快单次 GC 的速度。基于这样的考虑，JVM 还提供了两个参数用于压缩和扩展堆空间。</p>
                        <ul>
                          <li>-XX:MinHeapFreeRatio 参数用来设置堆空间最小空闲比例，默认值是 40。当堆空间的空闲内存小于这个数值时，JVM 便会扩展堆空间。</li>
                          <li>-XX:MaxHeapFreeRatio 参数用来设置堆空间最大空闲比例，默认值是 70。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆。</li>
                          <li>当-Xmx 和-Xms 相等时，-XX:MinHeapFreeRatio 和-XX:MaxHeapFreeRatio 两个参数无效。</li>
                        </ul>
                        <h4 id="增大吞吐量提升系统性能"><a href="#增大吞吐量提升系统性能" class="headerlink" title="增大吞吐量提升系统性能"></a>增大吞吐量提升系统性能</h4>
                        <p>&emsp;&emsp;吞吐量优先的方案将会尽可能减少系统执行垃圾回收的总时间，故可以考虑关注系统吞吐量的并行回收收集器。在拥有高性能的计算机上，进行吞吐量优先优化，可以使用参数：</p>
                        <blockquote>
                          <p>java –Xmx3800m –Xms3800m –Xmn2G –Xss128k –XX:+UseParallelGC<br>–XX:ParallelGC-Threads=20 –XX:+UseParallelOldGC</p>
                        </blockquote>
                        <ul>
                          <li>–Xmx380m –Xms3800m：设置 Java 堆的最大值和初始值。一般情况下，为了避免堆内存的频繁震荡，导致系统性能下降，我们的做法是设置最大堆等于最小堆。假设这里把最小堆减少为最大堆的一半，即 1900m，那么 JVM 会尽可能在 1900MB 堆空间中运行，如果这样，发生 GC 的可能性就会比较高；</li>
                          <li>-Xss128k：减少线程栈的大小，这样可以使剩余的系统内存支持更多的线程；</li>
                          <li>-Xmn2g：设置年轻代区域大小为 2GB；</li>
                          <li>–XX:+UseParallelGC：年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能地减少 GC 时间。</li>
                          <li>–XX:ParallelGC-Threads：设置用于垃圾回收的线程数，通常情况下，可以设置和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的；</li>
                          <li>–XX:+UseParallelOldGC：设置年老代使用并行回收收集器。</li>
                        </ul>
                        <h4 id="尝试使用大的内存分页"><a href="#尝试使用大的内存分页" class="headerlink" title="尝试使用大的内存分页"></a>尝试使用大的内存分页</h4>
                        <p>&emsp;&emsp;CPU 是通过寻址来访问内存的。32 位 CPU 的寻址宽度是 0~0xFFFFFFFF ，计算后得到的大小是 4G，也就是说可支持的物理内存最大是 4G。但在实践过程中，碰到了这样的问题，程序需要使用 4G 内存，而可用物理内存小于 4G，导致程序不得不降低内存占用。为了解决此类问题，现代 CPU 引入了 MMU（Memory Management Unit 内存管理单元）。MMU 的核心思想是利用虚拟地址替代物理地址，即
                          CPU 寻址时使用虚址，由 MMU 负责将虚址映射为物理地址。MMU 的引入，解决了对物理内存的限制，对程序来说，就像自己在使用 4G 内存一样。内存分页 (Paging) 是在使用 MMU 的基础上，提出的一种内存管理机制。它将虚拟地址和物理地址按固定大小（4K）分割成页 (page) 和页帧 (page frame)，并保证页与页帧的大小相同。这种机制，从数据结构上，保证了访问内存的高效，并使 OS 能支持非连续性的内存分配。在程序内存不够用时，还可以将不常用的物理内存页转移到其他存储设备上，比如磁盘，这就是大家耳熟能详的虚拟内存。<br>&emsp;&emsp;在
                          Solaris 系统中，JVM 可以支持 Large Page Size 的使用。使用大的内存分页可以增强 CPU 的内存寻址能力，从而提升系统的性能。</p>
                        <blockquote>
                          <p>java –Xmx2506m –Xms2506m –Xmn1536m –Xss128k –XX:++UseParallelGC<br>–XX:ParallelGCThreads=20 –XX:+UseParallelOldGC –XX:+LargePageSizeInBytes=256m</p>
                        </blockquote>
                        <ul>
                          <li>–XX:+LargePageSizeInBytes：设置大页的大小。<br>过大的内存分页会导致 JVM 在计算 Heap 内部分区（perm, new, old）内存占用比例时，会出现超出正常值的划分，最坏情况下某个区会多占用一个页的大小。</li>
                        </ul>
                        <h4 id="使用非占有的垃圾回收器"><a href="#使用非占有的垃圾回收器" class="headerlink" title="使用非占有的垃圾回收器"></a>使用非占有的垃圾回收器</h4>
                        <p>&emsp;&emsp;为降低应用软件的垃圾回收时的停顿，首先考虑的是使用关注系统停顿的 CMS 回收器，其次，为了减少 Full GC 次数，应尽可能将对象预留在年轻代，因为年轻代 Minor GC 的成本远远小于年老代的 Full GC。</p>
                        <blockquote>
                          <p>java –Xmx3550m –Xms3550m –Xmn2g –Xss128k –XX:ParallelGCThreads=20<br>–XX:+UseConcMarkSweepGC –XX:+UseParNewGC –XX:+SurvivorRatio=8 –XX:TargetSurvivorRatio=90<br>–XX:MaxTenuringThreshold=31</p>
                        </blockquote>
                        <ul>
                          <li>–XX:ParallelGCThreads=20：设置 20 个线程进行垃圾回收；</li>
                          <li>–XX:+UseParNewGC：年轻代使用并行回收器；</li>
                          <li>–XX:+UseConcMarkSweepGC：年老代使用 CMS 收集器降低停顿；</li>
                          <li>–XX:+SurvivorRatio：设置 Eden 区和 Survivor 区的比例为 8:1。稍大的 Survivor 空间可以提高在年轻代回收生命周期较短的对象的可能性，如果 Survivor 不够大，一些短命的对象可能直接进入年老代，这对系统来说是不利的。</li>
                          <li>–XX:TargetSurvivorRatio=90：设置 Survivor 区的可使用率。这里设置为 90%，则允许 90%的 Survivor 空间被使用。默认值是 50%。故该设置提高了 Survivor 区的使用率。当存放的对象超过这个百分比，则对象会向年老代压缩。因此，这个选项更有助于将对象留在年轻代。</li>
                          <li>–XX:MaxTenuringThreshold：设置年轻对象晋升到年老代的年龄。默认值是 15 次，即对象经过 15 次 Minor GC 依然存活，则进入年老代。这里设置为 31，目的是让对象尽可能地保存在年轻代区域。</li>
                        </ul>
                </div>
                <div></div>
                <div></div>
                <footer class="post-footer">
                  <div class="post-tags"><a href="/tags/java/" rel="tag">#java</a></div>
                  <div class="post-nav">
                    <div class="post-nav-next post-nav-item"><a href="/2016/05/30/jvm/" rel="next" title="java基础拾遗——JVM垃圾回收原理"><i class="fa fa-chevron-left"></i> java基础拾遗——JVM垃圾回收原理</a></div>
                    <div class="post-nav-prev post-nav-item"><a href="/2016/05/31/cache/" rel="prev" title="Web缓存概述（一）">Web缓存概述（一） <i class="fa fa-chevron-right"></i></a></div>
                  </div>
                </footer>
              </article>
              <div class="post-spread"></div>
            </div>
          </div>
          <div class="comments" id="comments">
            <div class="ds-thread" data-thread-key="2016/05/30/jvm-optimal/" data-title="java基础拾遗——JVM优化经验总结" data-url="http://xiaolin.site/2016/05/30/jvm-optimal/"></div>
          </div>
        </div>
        <div class="sidebar-toggle">
          <div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div>
        </div>
        <aside id="sidebar" class="sidebar">
          <div class="sidebar-inner">
            <ul class="sidebar-nav motion-element">
              <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li>
              <li class="sidebar-nav-overview" data-target="site-overview">站点概览</li>
            </ul>
            <section class="site-overview sidebar-panel">
              <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://o6fmcea8z.bkt.clouddn.com/blog/image/me.png" alt="XiaoLin">
                <p class="site-author-name" itemprop="name">XiaoLin</p>
                <p class="site-description motion-element" itemprop="description">XiaoLin's Blog</p>
              </div>
              <nav class="site-state motion-element">
                <div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div>
                <div class="site-state-item site-state-categories"><a href="/categories"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div>
                <div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">10</span> <span class="site-state-item-name">标签</span></a></div>
              </nav>
              <div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div>
              <div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xiaolin8" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://www.zhihu.com/people/wuxun-yi" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i> 知乎</a></span></div>
            </section>
            <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
              <div class="post-toc">
                <div class="post-toc-content">
                  <ol class="nav">
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#如何将新对象预留在年轻代"><span class="nav-number">1.</span> <span class="nav-text">如何将新对象预留在年轻代</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#如何让大对象进入年老代"><span class="nav-number">2.</span> <span class="nav-text">如何让大对象进入年老代</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#如何设置对象进入年老代的年龄"><span class="nav-number">3.</span> <span class="nav-text">如何设置对象进入年老代的年龄</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#稳定的-Java-堆-VS-动荡的-Java-堆"><span class="nav-number">4.</span> <span class="nav-text">稳定的 Java 堆 VS 动荡的 Java 堆</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#增大吞吐量提升系统性能"><span class="nav-number">5.</span> <span class="nav-text">增大吞吐量提升系统性能</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#尝试使用大的内存分页"><span class="nav-number">6.</span> <span class="nav-text">尝试使用大的内存分页</span></a></li>
                    <li class="nav-item nav-level-4"><a class="nav-link" href="#使用非占有的垃圾回收器"><span class="nav-number">7.</span> <span class="nav-text">使用非占有的垃圾回收器</span></a></li>
                  </ol>
                </div>
              </div>
            </section>
          </div>
        </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2016</span> <span class="with-love"><i class="fa fa-heart"></i> </span><a class="author" itemprop="copyrightHolder" href="/about">XiaoLin</a></div>
      </div>
    </footer>
    <div class="back-to-top"><i class="fa fa-arrow-up"></i></div>
  </div>
  <script type="text/javascript">
    "[object Function]" !== Object.prototype.toString.call(window.Promise) && (window.Promise = null)
  </script>
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>
  <script type="text/javascript">
    var duoshuoQuery = {
      short_name: "xiaolin"
    };
    ! function() {
      var t = document.createElement("script");
      t.type = "text/javascript", t.async = !0, t.id = "duoshuo-script", t.src = ("https:" == document.location.protocol ? "https:" : "http:") + "//static.duoshuo.com/embed.js", t.charset = "UTF-8", (document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(t)
    }()
  </script>
  <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
  <script src="/js/src/hook-duoshuo.js"></script>
</body>

</html>