<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="google-site-verification" content="zo1hRA1JFAQXW4rIvduGGzeUnKq0s29R8K0L9IE7weA">
  <title>java基础拾遗——多线程 | XiaoLin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <meta name="author" content="XiaoLin">
  <meta name="description" content="什么是线程？
&amp;emsp;&amp;emsp;简单的说进程就是在某种程度上相互隔离的、独立运行的程序，而线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，是CPU调度的基本单位，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。&amp;emsp;&amp;emsp;进程可以支持多个线程">
  <meta property="og:type" content="article">
  <meta property="og:title" content="java基础拾遗——多线程">
  <meta property="og:url" content="http://xiaolin.site/2016/05/29/java-thread/index.html">
  <meta property="og:site_name" content="XiaoLin's Blog">
  <meta property="og:description" content="什么是线程？
&amp;emsp;&amp;emsp;简单的说进程就是在某种程度上相互隔离的、独立运行的程序，而线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，是CPU调度的基本单位，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。&amp;emsp;&amp;emsp;进程可以支持多个线程">
  <meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg">
  <meta property="og:updated_time" content="2016-06-01T07:07:48.552Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="java基础拾遗——多线程">
  <meta name="twitter:description" content="什么是线程？
&amp;emsp;&amp;emsp;简单的说进程就是在某种程度上相互隔离的、独立运行的程序，而线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，是CPU调度的基本单位，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。&amp;emsp;&amp;emsp;进程可以支持多个线程">
  <meta name="twitter:image" content="http://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg">
  <link rel="alternative" href="/atom.xml" title="XiaoLin&#39;s Blog" type="application/atom+xml">
  <link rel="icon" href="/img/favicon.ico">
  <link rel="apple-touch-icon" href="/img/jacman.jpg">
  <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="canonical" href="http://xiaolin.site/2016/05/29/java-thread/">
</head>

</html>

<body>
  <header>
    <!--[if lt IE 9]><div style="background-color:#f1c40f;padding-bottom:1.5em;color:#fff;padding-top:1.5em;text-align:center"><strong>你的浏览器都成古董了!</strong> 为什么不 <a href="http://www.firefox.com.cn/download/">升级一下</a>以便享受更好的体验呢?</div><![endif]-->
    <div>
      <div id="imglogo">
        <a href="/"><img src="/img/logo.png" alt="XiaoLin&#39;s Blog" title="XiaoLin&#39;s Blog"></a>
      </div>
      <div id="textlogo">
        <h1 class="site-name"><a href="/" title="XiaoLin&#39;s Blog">XiaoLin&#39;s Blog</a></h1>
        <h2 class="blog-motto">亲爱的小肥羊，欢迎光临啊</h2></div>
      <div class="navbar">
        <a class="navbutton navmobile" href="#" title="菜单"></a>
      </div>
      <nav class="animated">
        <ul>
          <ul>
            <li><a href="/">主页 | Home</a></li>
            <li><a href="/archives">归档 | Archives</a></li>
            <li><a href="/about">简介 | About</a></li>
            <li>
              <form class="search" action="/search/index.html" method="get" accept-charset="utf-8"><label>Search</label><input type="text" id="search" class="st-default-search-input" maxlength="20" placeholder="Search"></form>
            </li>
          </ul>
        </ul>
      </nav>
    </div>
  </header>
  <div id="container">
    <div id="main" class="post" itemscope itemprop="blogPost">
      <article itemprop="articleBody">
        <header class="article-info clearfix">
          <h1 itemprop="name"><a href="/2016/05/29/java-thread/" title="java基础拾遗——多线程" itemprop="url">java基础拾遗——多线程</a></h1>
          <p class="article-author">By <a href="/about" title="XiaoLin" target="_blank" itemprop="author">XiaoLin</a></p>
          <p class="article-time"><time datetime="2016-05-29T01:42:47.000Z" itemprop="datePublished">发表于 2016-05-29</time></p>
        </header>
        <div class="article-content">
          <div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong>
            <ol class="toc">
              <li class="toc-item toc-level-4"><a class="toc-link" href="#什么是线程？"><span class="toc-number">1.</span> <span class="toc-text">什么是线程？</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#为什么使用线程？"><span class="toc-number">2.</span> <span class="toc-text">为什么使用线程？</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#无处不在的线程"><span class="toc-number">3.</span> <span class="toc-text">无处不在的线程</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#多线程的一些坑"><span class="toc-number">4.</span> <span class="toc-text">多线程的一些坑</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#线程的生命周期"><span class="toc-number">5.</span> <span class="toc-text">线程的生命周期</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#线程的优先级"><span class="toc-number">6.</span> <span class="toc-text">线程的优先级</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#Thread-方法"><span class="toc-number">7.</span> <span class="toc-text">Thread 方法</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#Java线程的同步"><span class="toc-number">8.</span> <span class="toc-text">Java线程的同步</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#死锁"><span class="toc-number">9.</span> <span class="toc-text">死锁</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#线程间通信"><span class="toc-number">10.</span> <span class="toc-text">线程间通信</span></a></li>
              <li class="toc-item toc-level-4"><a class="toc-link" href="#线程组与线程池"><span class="toc-number">11.</span> <span class="toc-text">线程组与线程池</span></a></li>
            </ol>
          </div>
          <h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4>
          <p>&emsp;&emsp;简单的说进程就是在某种程度上相互隔离的、独立运行的程序，而线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，是CPU调度的基本单位，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。<br>&emsp;&emsp;进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，但你必须小心，确保它们不会妨碍同一进程里的其它线程。</p>
          <h4
            id="为什么使用线程？">
            <a href="#为什么使用线程？" class="headerlink" title="为什么使用线程？"></a>为什么使用线程？</h4>
            <ul>
              <li><strong>使 UI 响应更快</strong><br>当需要完成一些耗时的操作时，把这些工作交给另一个线程去完成，而UI线程只关注UI事件，这样就不会使得程序看来似乎停滞了，让用户感到蒙圈。</li>
              <li><strong>利用多处理器系统</strong><br>如果某个程序只有一个活动的线程，它一次只能在一个处理器上运行。如果某个程序有多个活动线程，那么可以同时调度多个线程。在精心设计的程序中，使用多个线程可以提高程序吞吐量和性能。</li>
              <li><strong>异步或后台处理</strong></li>
            </ul>
            <h4 id="无处不在的线程"><a href="#无处不在的线程" class="headerlink" title="无处不在的线程"></a>无处不在的线程</h4>
            <p>&emsp;&emsp;每个 Java 程序都至少有一个线程 ― 主线程。当一个 Java 程序启动时，JVM 会创建主线程，并在该线程中调用程序的 main() 方法。<br><strong>TimerTask 工具</strong><br>&emsp;&emsp;JDK 1.3 中，引入了TimerTask 工具。这个便利的工具让你可以稍后在某个时间执行任务（例如从现在起十秒后运行一次任务），或者定期执行任务（例如每隔十秒运行任务）。<br>TimerTask 线程被标记成守护程序线程，这样它就不会阻止程序退出。<br></p>
            <figure
              class="highlight java">
              <table>
                <tr>
                  <td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td>
                  <td
                    class="code"><pre><div class="line">Timer timer = <span class="keyword">new</span> Timer();</div><div class="line"><span class="keyword">final</span> CalculatePrimes calculator = <span class="keyword">new</span> CalculatePrimes();</div><div class="line">calculator.start();</div><div class="line">timer.schedule(</div><div class="line">        <span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">            &#123;</div><div class="line">                calculator.finished = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;, TEN_SECONDS);</div></pre></td>
                </tr>
              </table>
              </figure>
              <p></p>
              <h4 id="多线程的一些坑"><a href="#多线程的一些坑" class="headerlink" title="多线程的一些坑"></a>多线程的一些坑</h4>
              <ul>
                <li>当多个线程访问同一数据项（如静态字段、可全局访问对象的实例字段或共享集合）时，需要确保它们协调了对数据的访问，这样它们都可以看到数据的一致视图，而且相互不会干扰另一方的更改，也就是必须确保对该访问正确地进行了同步。对于简单变量，将变量声明成 volatile 也许就足够了，但在大多数情况下，需要使用同步。</li>
                <li>如果要使用同步来保护对共享变量的访问，那么必须确保在程序中所有访问该变量的地方都使用同步。</li>
                <li>过度使用线程可能会危及程序的性能及其可维护性;<br>CPU上下文的切换开销也很重要，如果你创建了太多的线程，CPU花费在上下文的切换的时间将多于执行程序的时间！尤其在单处理器系统中，使用多个线程不会使主要消耗 CPU 资源的程序运行得更快。</li>
              </ul>
              <h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4>
              <p><img src="http://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg" alt=""></p>
              <ul>
                <li>新建状态:<br>有两种方式创建一个新的线程：一种是继承java.lang.Thread类并覆写其中的run()方法，另外一种则是在创建java.lang.Thread类的对象的时候，在构造函数中提供一个实现了java.lang.Runnable接口的类的对象。在得到了java.lang.Thread类的对象之后，通过调用其
                  <font color="red">start()方法</font>就可以启动这个线程的执行。</li>
              </ul>
              <figure class="highlight java">
                <table>
                  <tr>
                    <td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td>
                    <td
                      class="code"><pre><div class="line"><span class="comment">// 创建一个新的线程</span></div><div class="line"><span class="comment">// 你可以重写该方法，重要的是理解的run()可以调用其他方法，使用其他类，并声明变量，就像主线程一样</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    System.out.println(<span class="string">"Child Thread1"</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个新的线程</span></div><div class="line"><span class="comment">// 继承类必须重写run()方法，该方法是新线程的入口点。它也必须调用start()方法才能执行</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    System.out.println(<span class="string">"Child Thread2"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> NewThread().run();</div><div class="line"><span class="keyword">new</span> NewThread2().run();</div></pre></td>
                  </tr>
                </table>
              </figure>
              <p>&emsp;&emsp;实现Runnable接口比继承Thread类所具有的优势：</p>
              <blockquote>
                <p>适合多个相同的程序代码的线程去处理同一个资源;<br>可以避免java中的单继承的限制;<br>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立;</p>
              </blockquote>
              <ul>
                <li>就绪状态:<br>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</li>
                <li>运行状态:<br>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</li>
                <li>阻塞状态:<br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。</li>
                <li>死亡状态:<br>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</li>
              </ul>
              <h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4>
              <ul>
                <li>Java线程的优先级是一个整数，其取值范围是1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</li>
                <li>默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。</li>
                <li>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。只能将优先级作为一种很粗略的工具使用。最后的控制可以通过明智地使用 yield() 函数来完成。<strong>通常情况下，请不要依靠线程优先级来控制线程的状态。</strong></li>
              </ul>
              <h4 id="Thread-方法"><a href="#Thread-方法" class="headerlink" title="Thread 方法"></a>Thread 方法</h4>
              <ul>
                <li><strong>start()</strong><br>使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</li>
                <li><strong>run()</strong><br>如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。run 方法就相当于传统程序中的 main() 方法；线程会持续运行，直到 run() 返回为止，此时该线程便死了。</li>
                <li><strong>setPriority(int priority)</strong><br>更改线程的优先级。</li>
                <li><strong>setDaemon(boolean on)</strong><br>将该线程标记为守护线程或用户线程。<br>我们提到过当 Java 程序的所有线程都完成时，该程序就退出，但这并不完全正确。系统线程，如垃圾收集线程称作守护程序线程。Java 程序实际上是在它的所有非守护程序线程完成后退出的。</li>
                <li><strong>join(long millisec)</strong><br>等待该线程终止的时间最长为 millis 毫秒。当调用 Thread.join() 时，调用线程将阻塞，直到目标线程完成为止。</li>
                <li><strong>interrupt()</strong><br>中断线程。</li>
                <li><strong>boolean isAlive()</strong><br>测试线程是否处于活动状态。</li>
              </ul>
              <p>上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。</p>
              <ul>
                <li><strong>yield()</strong><br>暂停当前正在执行的线程对象，将当前的线程从处理器中移出到准备就绪队列中，并执行其他线程。当较高优先级的线程调用 Thread.yield() 时，较低优先级的线程就不会运行。</li>
                <li><strong>sleep(long millisec)</strong><br>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</li>
                <li><strong>boolean holdsLock(Object x)</strong><br>当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</li>
                <li><strong>Thread currentThread()</strong><br>返回对当前正在执行的线程对象的引用。</li>
              </ul>
              <font color="red">stop()、suspend() 和 resume() 函数已不提倡使用。</font>
              <h4 id="Java线程的同步"><a href="#Java线程的同步" class="headerlink" title="Java线程的同步"></a>Java线程的同步</h4>
              <p>&emsp;&emsp;要跨线程维护数据的一致性，如要在几个线程之间共享非 final 变量，就必须使用 synchronized（或 volatile）以确保一个线程可以看见另一个线程做的更改。<br>&emsp;&emsp;Synchronized 有两个重要含义：它确保了一次只有一个线程可以执行代码的受保护部分，而且它确保了一个线程更改的数据对于其它线程是可见的（更改的可见性）。<br>&emsp;&emsp;Volatile 比同步更简单，只适合于控制对基本变量（整数、布尔变量等）的单个实例的访问。当一个变量被声明成
                volatile，任何对该变量的写操作都会绕过高速缓存，直接写入主内存，而任何对该变量的读取也都绕过高速缓存，直接取自主内存。这表示所有线程在任何时候看到的 volatile 变量值都相同。</p>
              <p>&emsp;&emsp;采用同步的话，可以使用同步代码块和同步方法两种来完成。<br>创建 synchronized 块的最简单方法是将方法声明成 synchronized。这表示在进入方法主体之前，调用者必须获得锁：<br></p>
              <figure class="highlight java">
                <table>
                  <tr>
                    <td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td>
                    <td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div></pre></td>
                  </tr>
                </table>
              </figure>
              <p></p>
              <p>&emsp;&emsp;对于普通的 synchronized方法，这个锁是一个对象，将针对它调用方法。对于静态 synchronized 方法，这个锁是与 Class 对象相关的监控器，在该对象中声明了方法。<br>&emsp;&emsp;synchronized 块的语法比 synchronized 方法稍微复杂一点，因为还需要显式地指定锁要保护哪个块：<br></p>
              <figure class="highlight java">
                <table>
                  <tr>
                    <td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td>
                    <td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.x = x;</div><div class="line">      <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td>
                  </tr>
                </table>
              </figure>
              <p></p>
              <p>使用 this 引用作为锁很常见，但这并不是必需的。这表示该代码块将与这个类中的 synchronized 方法使用同一个锁。</p>
              <h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4>
              <p>&emsp;&emsp;只要你拥有多个进程，而且它们要争用对<strong>多个锁</strong>的独占访问，那么就有可能发生死锁。如果有一组进程或线程，其中每个都在等待一个只有其它进程或线程才可以执行的操作，那么就称它们被<strong>死锁</strong>了。<br>&emsp;&emsp;假设有两个线程，分别代表两个饥饿的人，他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁：共享刀和共享叉的锁。假如线程 “A” 获得了刀，而线程 “B” 获得了叉。线程 A 就会进入阻塞状态来等待获得叉，而线程
                B 则阻塞来等待 A 所拥有的刀。这两个线程永远都不会获得第二个锁，或者释放第一个锁。它们只会永远等待下去。</p>
              <p><strong>死锁的应对策略</strong></p>
              <ul>
                <li>让所有的线程按照同样的顺序获得一组锁。这种方法消除了 A 和 B 的拥有者分别等待对方的资源的问题;</li>
                <li>将多个锁组成一组并放到同一个锁下。前面死锁的例子中，可以创建一个银器对象的锁。于是在获得刀或叉之前都必须获得这个银器的锁;</li>
                <li>将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得银器对象的锁时，就可以通过检查变量来判断是否整个银器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试;</li>
              </ul>
              <p><strong>同步代码准则</strong><br>&emsp;&emsp;当编写 synchronized 块时，有几个简单的准则可以遵循，这些准则在避免死锁和性能危险的风险方面大有帮助：</p>
              <ul>
                <li><strong>使代码块保持简短</strong>。Synchronized 块应该简短 ― 在保证相关数据操作的完整性的同时，尽量简短。把不随线程变化的预处理和后处理移出synchronized 块。</li>
                <li><strong>不要阻塞</strong>。 不要在 synchronized 块或方法中调用可能引起阻塞的方法，如 InputStream.read()。</li>
                <li><strong>在持有锁的时候，不要对其它对象调用方法</strong>。这听起来可能有些极端，但它消除了最常见的死锁源头。</li>
              </ul>
              <h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4>
              <p>&emsp;&emsp;除了使用轮询（它可能消耗大量 CPU 资源，而且具有计时不精确的特征），Object 类还包括一些方法，可以让线程相互通知事件的发生。<br>&emsp;&emsp;Object 类定义了 wait()、notify() 和 notifyAll() 方法。要执行这些方法，必须拥有相关对象的锁。<br>&emsp;&emsp;Wait() 会让调用线程休眠，直到用 Thread.interrupt() 中断它、过了指定的时间、或者另一个线程用 notify()
                或 notifyAll() 唤醒它。<br>&emsp;&emsp;当对某个对象调用 notify() 时，如果有任何线程正在通过 wait() 等待该对象，那么就会唤醒其中一个线程。当对某个对象调用notifyAll() 时，会唤醒所有正在等待该对象的线程。<br>&emsp;&emsp;使用 notify() 来代替notifyAll() 是有风险的。除非你确实知道正在做什么，否则就使用 notifyAll()。</p>
              <p>&emsp;&emsp;其实与其使用 wait() 和 notify() 来编写自己的调度程序、线程池、队列和锁，倒不如使用 JDK1.5中引入的util.concurrent 包，这是一个被广泛使用的开放源码工具箱，里面都是有用的并发性实用程序。</p>
              <h4 id="线程组与线程池"><a href="#线程组与线程池" class="headerlink" title="线程组与线程池"></a>线程组与线程池</h4>
              <p>&emsp;&emsp;线程是被个别创建的，但可以将它们归类到 线程组中，以便于调试和监视。只能在创建线程的同时将它与一个线程组相关联。在使用大量线程的程序中，使用线程组组织线程可能很有帮助。可以将它们看作是计算机上的目录和文件结构。<br>&emsp;&emsp;在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资源”技术产生的原因。</p>
        </div>
        <footer class="article-footer clearfix">
          <div class="article-catetags">
            <div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Java基础/">Java基础</a></div>
            <div class="article-tags"><span></span> <a href="/tags/多线程/">多线程</a></div>
          </div>
          <div class="article-share" id="share">
            <div data-url="http://xiaolin.site/2016/05/29/java-thread/" data-title="java基础拾遗——多线程 | XiaoLin&#39;s Blog" data-tsina="undefined" class="share clearfix"></div>
          </div>
        </footer>
      </article>
      <nav class="article-nav clearfix">
        <div class="prev"><a href="/2016/05/29/java-reflection/" title="java基础拾遗——反射"><strong>上一篇：</strong><br><span>java基础拾遗——反射</span></a></div>
        <div class="next"><a href="/2016/05/28/java-basic2/" title="java基础拾遗——IO流"><strong>下一篇：</strong><br><span>java基础拾遗——IO流</span></a></div>
      </nav>
      <section id="comments" class="comment">
        <div class="ds-thread" data-thread-key="2016/05/29/java-thread/" data-title="java基础拾遗——多线程" data-url="http://xiaolin.site/2016/05/29/java-thread/"></div>
      </section>
    </div>
    <div class="openaside">
      <a class="navbutton" href="#" title="显示侧边栏"></a>
    </div>
    <div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong>
      <ol class="toc">
        <li class="toc-item toc-level-4"><a class="toc-link" href="#什么是线程？"><span class="toc-number">1.</span> <span class="toc-text">什么是线程？</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#为什么使用线程？"><span class="toc-number">2.</span> <span class="toc-text">为什么使用线程？</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#无处不在的线程"><span class="toc-number">3.</span> <span class="toc-text">无处不在的线程</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#多线程的一些坑"><span class="toc-number">4.</span> <span class="toc-text">多线程的一些坑</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#线程的生命周期"><span class="toc-number">5.</span> <span class="toc-text">线程的生命周期</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#线程的优先级"><span class="toc-number">6.</span> <span class="toc-text">线程的优先级</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#Thread-方法"><span class="toc-number">7.</span> <span class="toc-text">Thread 方法</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#Java线程的同步"><span class="toc-number">8.</span> <span class="toc-text">Java线程的同步</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#死锁"><span class="toc-number">9.</span> <span class="toc-text">死锁</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#线程间通信"><span class="toc-number">10.</span> <span class="toc-text">线程间通信</span></a></li>
        <li class="toc-item toc-level-4"><a class="toc-link" href="#线程组与线程池"><span class="toc-number">11.</span> <span class="toc-text">线程组与线程池</span></a></li>
      </ol>
    </div>
    <div id="asidepart">
      <div class="closeaside">
        <a class="closebutton" href="#" title="隐藏侧边栏"></a>
      </div>
      <aside class="clearfix">
        <div class="github-card">
          <p class="asidetitle">Github 名片</p>
          <div class="github-card" data-github="xiaolin8" data-width="220" data-height="119" data-theme="medium">
            <script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
          </div>
        </div>
        <div class="categorieslist">
          <p class="asidetitle">分类</p>
          <ul>
            <li><a href="/categories/Java基础/" title="Java基础">Java基础<sup>9</sup></a></li>
            <li><a href="/categories/NoSQL/" title="NoSQL">NoSQL<sup>1</sup></a></li>
            <li><a href="/categories/Web开发/" title="Web开发">Web开发<sup>1</sup></a></li>
            <li><a href="/categories/前端/" title="前端">前端<sup>1</sup></a></li>
            <li><a href="/categories/思考/" title="思考">思考<sup>2</sup></a></li>
            <li><a href="/categories/技术/" title="技术">技术<sup>3</sup></a></li>
          </ul>
        </div>
        <div class="tagslist">
          <p class="asidetitle">标签</p>
          <ul class="clearfix">
            <li><a href="/tags/java/" title="java">java<sup>8</sup></a></li>
            <li><a href="/tags/习惯养成/" title="习惯养成">习惯养成<sup>1</sup></a></li>
            <li><a href="/tags/缓存/" title="缓存">缓存<sup>1</sup></a></li>
            <li><a href="/tags/数据库/" title="数据库">数据库<sup>1</sup></a></li>
            <li><a href="/tags/全栈/" title="全栈">全栈<sup>1</sup></a></li>
            <li><a href="/tags/翻译/" title="翻译">翻译<sup>1</sup></a></li>
            <li><a href="/tags/多线程/" title="多线程">多线程<sup>1</sup></a></li>
            <li><a href="/tags/redis/" title="redis">redis<sup>1</sup></a></li>
            <li><a href="/tags/思考/" title="思考">思考<sup>1</sup></a></li>
            <li><a href="/tags/爬虫/" title="爬虫">爬虫<sup>1</sup></a></li>
          </ul>
        </div>
        <div class="rsspart"><a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a></div>
      </aside>
    </div>
  </div>
  <footer>
    <div id="footer">
      <div class="line"><span></span>
        <div class="author"></div>
      </div>
      <section class="info">
        <p>Hello ,I&#39;m XiaoLin.<br>This is my blog,welcome!</p>
      </section>
      <div class="social-font" class="clearfix">
        <a href="https://github.com/xiaolin8" target="_blank" class="icon-github" title="github"></a>
        <a href="https://www.linkedin.com/in/孝林-胡-19634ba0" target="_blank" class="icon-linkedin" title="linkedin"></a>
        <a href="http://www.zhihu.com/people/wuxun-yi" target="_blank" class="icon-zhihu" title="知乎"></a>
        <a href="mailto:hu_xiao_lin@163.com" target="_blank" class="icon-email" title="Email Me"></a>
      </div>
      <p class="copyright">All right reserved © 2016 <a href="/about" target="_blank" title="XiaoLin">XiaoLin</a></p>
      <script type="text/javascript">
        ! function(t, e, n, s, c, i, o) {
          t.SwiftypeObject = c, t[c] = t[c] || function() {
            (t[c].q = t[c].q || []).push(arguments)
          }, i = e.createElement(n), o = e.getElementsByTagName(n)[0], i.async = 1, i.src = s, o.parentNode.insertBefore(i, o)
        }(window, document, "script", "//s.swiftypecdn.com/install/v2/st.js", "_st"), _st("install", "xboTgqPs9MSHz8WAFgnF", "2.0.0")
      </script>
    </div>
  </footer>
  <script src="/js/jquery-2.0.3.min.js"></script>
  <script src="/js/jquery.imagesloaded.min.js"></script>
  <script src="/js/gallery.js"></script>
  <script src="/js/jquery.qrcode-0.12.0.min.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      function e() {
        "number" == typeof window.innerWidth ? n = window.innerWidth : document.documentElement && document.documentElement.clientWidth && (n = document.documentElement.clientWidth)
      }
      $(".navbar").click(function() {
        $("header nav").toggleClass("shownav")
      });
      var n = 0,
        s = $("#main"),
        a = $("#asidepart"),
        o = $(".closeaside"),
        d = $(".openaside");
      o.click(function() {
        a.addClass("fadeOut").css("display", "none"), d.css("display", "block").addClass("fadeIn"), s.addClass("moveMain")
      }), d.click(function() {
        d.css("display", "none").removeClass("beforeFadeIn"), a.css("display", "block").removeClass("fadeOut").addClass("fadeIn"), s.removeClass("moveMain")
      }), $(window).scroll(function() {
        d.css("top", Math.max(80, 260 - $(this).scrollTop()))
      }), $(window).resize(function() {
        e(), n >= 1024 ? $("header nav").removeClass("shownav") : (s.removeClass("moveMain"), a.css("display", "block").removeClass("fadeOut"), d.css("display", "none"), $("#toc.toc-aside").css("display", "none"))
      })
    })
  </script>
  <script type="text/javascript">
    $(document).ready(function() {
      var c = $(".article-content>iframe"),
        n = $(".article-content>embed"),
        o = ($("#toc"), $("#toc.toc-aside")),
        e = $(".openaside"),
        i = $(".closeaside");
      c.length > 0 && c.wrap('<div class="video-container" />'), n.length > 0 && n.wrap('<div class="video-container" />'), i.click(function() {
        o.css("display", "block").addClass("fadeIn")
      }), e.click(function() {
        o.css("display", "none")
      }), $(window).scroll(function() {
        o.css("top", Math.max(140, 320 - $(this).scrollTop()))
      })
    })
  </script>
  <script type="text/javascript">
    $(document).ready(function() {
      function e() {
        "number" == typeof window.innerWidth ? n = window.innerWidth : document.documentElement && document.documentElement.clientWidth && (n = document.documentElement.clientWidth);
        var e = n > 1024 ? 200 : 100,
          t = {
            render: "image",
            size: e,
            fill: "#2ca6cb",
            text: r,
            radius: .5,
            quiet: 1
          },
          a = $(".article-share-qrcode").position();
        $(".hoverqrcode").empty().css("width", e).css("height", e).css("left", a.left - e / 2 + 20).css("top", a.top - e - 10).qrcode(t)
      }
      var t = $(".share"),
        r = t.attr("data-url"),
        a = encodeURIComponent(r),
        i = t.attr("data-title"),
        c = t.attr("data-tsina"),
        o = (t.attr("description"), ['<div class="hoverqrcode clearfix"></div>', '<a class="overlay" id="qrcode"></a>', '<a href="https://www.facebook.com/sharer.php?u=' + a + '" class="article-share-facebook" target="_blank" title="Facebook"></a>', '<a href="https://twitter.com/intent/tweet?url=' + a + '" class="article-share-twitter" target="_blank" title="Twitter"></a>', '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>', '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + a + "&srcUrl=" + a + "&title=" + i + '" class="article-share-renren" target="_blank" title="人人"></a>', '<a href="http://service.weibo.com/share/share.php?title=' + i + "&url=" + a + "&ralateUid=" + c + '&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="微博"></a>', '<span title="Share to"></span>'].join(""));
      t.append(o), $(".hoverqrcode").hide();
      var n = 0;
      $(window).resize(function() {
        $(".hoverqrcode").hide()
      }), $(".article-share-qrcode").click(function() {
        e(), $(".hoverqrcode").toggle()
      }), $(".article-share-qrcode").hover(function() {}, function() {
        $(".hoverqrcode").hide()
      })
    })
  </script>
  <script type="text/javascript">
    var duoshuoQuery = {
      short_name: "xiaolin"
    };
    ! function() {
      var e = document.createElement("script");
      e.type = "text/javascript", e.async = !0, e.src = "//static.duoshuo.com/embed.js", e.charset = "UTF-8", (document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(e)
    }()
  </script>
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $(".article-content").each(function(a) {
        $(this).find("img").each(function() {
          if (!$(this).parent().hasClass("fancybox")) {
            var a = this.alt;
            a && $(this).after('<span class="caption">' + a + "</span>"), $(this).wrap('<a href="' + this.src + '" title="' + a + '" class="fancybox"></a>')
          }
        }), $(this).find(".fancybox").each(function() {
          $(this).attr("rel", "article" + a)
        })
      }), $.fancybox && $(".fancybox").fancybox()
    })
  </script>
  <script type="text/javascript">
    ! function(e, a, n, t, c, i, o) {
      e.GoogleAnalyticsObject = c, e[c] = e[c] || function() {
        (e[c].q = e[c].q || []).push(arguments)
      }, e[c].l = 1 * new Date, i = a.createElement(n), o = a.getElementsByTagName(n)[0], i.async = 1, i.src = t, o.parentNode.insertBefore(i, o)
    }(window, document, "script", "//www.google-analytics.com/analytics.js", "ga"), ga("create", "UA-75883223-1", "xiaolin8.github.io"), ga("send", "pageview")
  </script>
  <div id="totop">
    <a title="返回顶部"><img src="/img/scrollup.png"></a>
  </div>
  <script src="/js/totop.js"></script>
</body>